; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\spifi\lpc43xx_i2c.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\lpc43xx_i2c.d --cpu=Cortex-M4 --apcs=interwork -O0 -I. -I..\libpixy -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\spifi\lpc43xx_i2c.crf ..\libpixy\lpc43xx_i2c.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  I2C_getNum PROC
;;;132     *********************************************************************/
;;;133    static int32_t I2C_getNum(LPC_I2Cn_Type *I2Cx){
000000  4601              MOV      r1,r0
;;;134    	if (I2Cx == LPC_I2C0) {
000002  48f7              LDR      r0,|L1.992|
000004  4281              CMP      r1,r0
000006  d101              BNE      |L1.12|
;;;135    		return (0);
000008  2000              MOVS     r0,#0
                  |L1.10|
;;;136    	} else if (I2Cx == LPC_I2C1) {
;;;137    		return (1);
;;;138    	}
;;;139    	return (-1);
;;;140    }
00000a  4770              BX       lr
                  |L1.12|
00000c  48f5              LDR      r0,|L1.996|
00000e  4281              CMP      r1,r0                 ;136
000010  d101              BNE      |L1.22|
000012  2001              MOVS     r0,#1                 ;137
000014  e7f9              B        |L1.10|
                  |L1.22|
000016  f04f30ff          MOV      r0,#0xffffffff        ;139
00001a  e7f6              B        |L1.10|
;;;141    
                          ENDP

                  I2C_Start PROC
;;;149     *********************************************************************/
;;;150    static uint32_t I2C_Start (LPC_I2Cn_Type *I2Cx)
00001c  4601              MOV      r1,r0
;;;151    {
;;;152    	I2Cx->CONCLR = I2C_I2CONCLR_SIC; // Clear interrupt
00001e  2008              MOVS     r0,#8
000020  6188              STR      r0,[r1,#0x18]
;;;153    	I2Cx->CONSET = I2C_I2CONSET_STA; // Send "Start"
000022  2020              MOVS     r0,#0x20
000024  6008              STR      r0,[r1,#0]
;;;154    
;;;155    	// Wait for complete
;;;156    	while (!(I2Cx->CONSET & I2C_I2CONSET_SI));
000026  bf00              NOP      
                  |L1.40|
000028  6808              LDR      r0,[r1,#0]
00002a  f0000008          AND      r0,r0,#8
00002e  2800              CMP      r0,#0
000030  d0fa              BEQ      |L1.40|
;;;157    	I2Cx->CONCLR = I2C_I2CONCLR_STAC;
000032  2020              MOVS     r0,#0x20
000034  6188              STR      r0,[r1,#0x18]
;;;158    	return (I2Cx->STAT & I2C_STAT_CODE_BITMASK);
000036  6848              LDR      r0,[r1,#4]
000038  f00000f8          AND      r0,r0,#0xf8
;;;159    }
00003c  4770              BX       lr
;;;160    
                          ENDP

                  I2C_Stop PROC
;;;168     *********************************************************************/
;;;169    static void I2C_Stop (LPC_I2Cn_Type *I2Cx)
00003e  6801              LDR      r1,[r0,#0]
;;;170    {
;;;171    
;;;172    	/* Make sure start bit is not active */
;;;173    	if (I2Cx->CONSET & I2C_I2CONSET_STA)
000040  f0010120          AND      r1,r1,#0x20
000044  b109              CBZ      r1,|L1.74|
;;;174    	{
;;;175    		I2Cx->CONCLR = I2C_I2CONCLR_STAC;
000046  2120              MOVS     r1,#0x20
000048  6181              STR      r1,[r0,#0x18]
                  |L1.74|
;;;176    	}
;;;177    	I2Cx->CONSET = I2C_I2CONSET_STO;
00004a  2110              MOVS     r1,#0x10
00004c  6001              STR      r1,[r0,#0]
;;;178    	I2Cx->CONCLR = I2C_I2CONCLR_SIC;
00004e  2108              MOVS     r1,#8
000050  6181              STR      r1,[r0,#0x18]
;;;179    }
000052  4770              BX       lr
;;;180    
                          ENDP

                  I2C_SendByte PROC
;;;189     *********************************************************************/
;;;190    static uint32_t I2C_SendByte (LPC_I2Cn_Type *I2Cx, uint8_t databyte)
000054  4602              MOV      r2,r0
;;;191    {
;;;192    	/* Make sure start bit is not active */
;;;193    	if (I2Cx->CONSET & I2C_I2CONSET_STA)
000056  6810              LDR      r0,[r2,#0]
000058  f0000020          AND      r0,r0,#0x20
00005c  b108              CBZ      r0,|L1.98|
;;;194    	{
;;;195    		I2Cx->CONCLR = I2C_I2CONCLR_STAC;
00005e  2020              MOVS     r0,#0x20
000060  6190              STR      r0,[r2,#0x18]
                  |L1.98|
;;;196    	}
;;;197    	I2Cx->DAT = databyte & I2C_I2DAT_BITMASK;
000062  b2c8              UXTB     r0,r1
000064  6090              STR      r0,[r2,#8]
;;;198    	I2Cx->CONCLR = I2C_I2CONCLR_SIC;
000066  2008              MOVS     r0,#8
000068  6190              STR      r0,[r2,#0x18]
;;;199    
;;;200    	while (!(I2Cx->CONSET & I2C_I2CONSET_SI));
00006a  bf00              NOP      
                  |L1.108|
00006c  6810              LDR      r0,[r2,#0]
00006e  f0000008          AND      r0,r0,#8
000072  2800              CMP      r0,#0
000074  d0fa              BEQ      |L1.108|
;;;201    	return (I2Cx->STAT & I2C_STAT_CODE_BITMASK);
000076  6850              LDR      r0,[r2,#4]
000078  f00000f8          AND      r0,r0,#0xf8
;;;202    }
00007c  4770              BX       lr
;;;203    
                          ENDP

                  I2C_GetByte PROC
;;;213     *********************************************************************/
;;;214    static uint32_t I2C_GetByte (LPC_I2Cn_Type *I2Cx, uint8_t *retdat, Bool ack)
00007e  4603              MOV      r3,r0
;;;215    {
;;;216    	if (ack == TRUE)
000080  2a01              CMP      r2,#1
000082  d102              BNE      |L1.138|
;;;217    	{
;;;218    		I2Cx->CONSET = I2C_I2CONSET_AA;
000084  2004              MOVS     r0,#4
000086  6018              STR      r0,[r3,#0]
000088  e001              B        |L1.142|
                  |L1.138|
;;;219    	}
;;;220    	else
;;;221    	{
;;;222    		I2Cx->CONCLR = I2C_I2CONCLR_AAC;
00008a  2004              MOVS     r0,#4
00008c  6198              STR      r0,[r3,#0x18]
                  |L1.142|
;;;223    	}
;;;224    	I2Cx->CONCLR = I2C_I2CONCLR_SIC;
00008e  2008              MOVS     r0,#8
000090  6198              STR      r0,[r3,#0x18]
;;;225    
;;;226    	while (!(I2Cx->CONSET & I2C_I2CONSET_SI));
000092  bf00              NOP      
                  |L1.148|
000094  6818              LDR      r0,[r3,#0]
000096  f0000008          AND      r0,r0,#8
00009a  2800              CMP      r0,#0
00009c  d0fa              BEQ      |L1.148|
;;;227    	*retdat = (uint8_t) (I2Cx->DAT & I2C_I2DAT_BITMASK);
00009e  6898              LDR      r0,[r3,#8]
0000a0  7008              STRB     r0,[r1,#0]
;;;228    	return (I2Cx->STAT & I2C_STAT_CODE_BITMASK);
0000a2  6858              LDR      r0,[r3,#4]
0000a4  f00000f8          AND      r0,r0,#0xf8
;;;229    }
0000a8  4770              BX       lr
;;;230    
                          ENDP

                  I2C_Init PROC
;;;247     *********************************************************************/
;;;248    void I2C_Init(LPC_I2Cn_Type *I2Cx, uint32_t clockrate)
0000aa  b570              PUSH     {r4-r6,lr}
;;;249    {
0000ac  4604              MOV      r4,r0
0000ae  460d              MOV      r5,r1
;;;250    	uint32_t tem;
;;;251    
;;;252    	CHECK_PARAM(PARAM_I2Cx(I2Cx));
;;;253    
;;;254    	if (I2Cx==LPC_I2C0)
0000b0  48cb              LDR      r0,|L1.992|
0000b2  4284              CMP      r4,r0
0000b4  d110              BNE      |L1.216|
;;;255    	{
;;;256    		/* Set up clock for I2C0 module */
;;;257    		//LPC_CGU->BASE_VPB1_CLK = (SRC_PL160M_0<<24) | (1<<11);
;;;258    		CGU_EntityConnect(CGU_CLKSRC_PLL1, CGU_BASE_APB1);
0000b6  211a              MOVS     r1,#0x1a
0000b8  2009              MOVS     r0,#9
0000ba  f7fffffe          BL       CGU_EntityConnect
;;;259    		/* Select weather standard, fast, fast plus mode*/
;;;260    		if(clockrate>=1000000)// Fast mode plus: 1MHz, high speed 3.4MHz
0000be  48ca              LDR      r0,|L1.1000|
0000c0  4285              CMP      r5,r0
0000c2  d304              BCC      |L1.206|
;;;261    			LPC_SCU->SFSI2C0 = SFSI2C0_CONFIGURE_FASTPLUS_HIGHSPEED_MODE;
0000c4  f640408c          MOV      r0,#0xc8c
0000c8  49c8              LDR      r1,|L1.1004|
0000ca  6008              STR      r0,[r1,#0]
0000cc  e016              B        |L1.252|
                  |L1.206|
;;;262    		else				  // standard 100KHz, fast 400KHz
;;;263    			LPC_SCU->SFSI2C0 = SFSI2C0_CONFIGURE_STANDARD_FAST_MODE;
0000ce  f6400008          MOV      r0,#0x808
0000d2  49c6              LDR      r1,|L1.1004|
0000d4  6008              STR      r0,[r1,#0]
0000d6  e011              B        |L1.252|
                  |L1.216|
;;;264    	}
;;;265    	else if (I2Cx==LPC_I2C1)
0000d8  48c2              LDR      r0,|L1.996|
0000da  4284              CMP      r4,r0
0000dc  d10d              BNE      |L1.250|
;;;266    	{
;;;267    		/* Set up clock for I2C1 module */
;;;268    		//LPC_CGU->BASE_VPB3_CLK = (SRC_PL160M_0<<24) | (1<<11);
;;;269    		CGU_EntityConnect(CGU_CLKSRC_PLL1, CGU_BASE_APB3);
0000de  211b              MOVS     r1,#0x1b
0000e0  2009              MOVS     r0,#9
0000e2  f7fffffe          BL       CGU_EntityConnect
;;;270    		/* Configure pin function for I2C1*/
;;;271    		LPC_SCU->SFSP2_3 = SFSP2_3_CONFIGURE_I2C1_SDA;			/* SDA */
0000e6  20c1              MOVS     r0,#0xc1
0000e8  49c1              LDR      r1,|L1.1008|
0000ea  6008              STR      r0,[r1,#0]
;;;272    		LPC_SCU->SFSP2_4 = SFSP2_4_CONFIGURE_I2C1_SCL;			/* SCL */
0000ec  49c1              LDR      r1,|L1.1012|
0000ee  f8c10110          STR      r0,[r1,#0x110]
;;;273    		/* Check if I2C1 run fast mode*/
;;;274      		if(clockrate != 400000)
0000f2  48c1              LDR      r0,|L1.1016|
0000f4  4285              CMP      r5,r0
0000f6  d001              BEQ      |L1.252|
                  |L1.248|
;;;275      			return;
;;;276    	}
;;;277    	else {
;;;278    		// Up-Support this device
;;;279    		return;
;;;280    	}
;;;281    
;;;282        /* Set clock rate */
;;;283    	if(clockrate<1000)	//make sure SCLH,SCLL not exceed its 16bit value
;;;284    		return;
;;;285        I2Cx->CONCLR = (I2C_I2CONCLR_AAC |I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC | I2C_I2CONCLR_I2ENC);
;;;286    
;;;287    	tem = CGU_GetPCLKFrequency(CGU_PERIPHERAL_M3CORE) / clockrate;
;;;288    	I2Cx->SCLH = (uint32_t)(tem / 2);
;;;289    	I2Cx->SCLL = (uint32_t)(tem - I2Cx->SCLH);
;;;290        /* Set I2C operation to default */
;;;291    }
0000f8  bd70              POP      {r4-r6,pc}
                  |L1.250|
0000fa  e7fd              B        |L1.248|
                  |L1.252|
0000fc  f5b57f7a          CMP      r5,#0x3e8             ;283
000100  d200              BCS      |L1.260|
000102  e7f9              B        |L1.248|
                  |L1.260|
000104  206c              MOVS     r0,#0x6c              ;285
000106  61a0              STR      r0,[r4,#0x18]         ;285
000108  2011              MOVS     r0,#0x11              ;287
00010a  f7fffffe          BL       CGU_GetPCLKFrequency
00010e  fbb0f6f5          UDIV     r6,r0,r5              ;287
000112  0870              LSRS     r0,r6,#1              ;288
000114  6120              STR      r0,[r4,#0x10]         ;288
000116  6920              LDR      r0,[r4,#0x10]         ;289
000118  1a30              SUBS     r0,r6,r0              ;289
00011a  6160              STR      r0,[r4,#0x14]         ;289
00011c  bf00              NOP      
00011e  e7eb              B        |L1.248|
;;;292    
                          ENDP

                  I2C_DeInit PROC
;;;301     **********************************************************************/
;;;302    void I2C_DeInit(LPC_I2Cn_Type* I2Cx)
000120  2140              MOVS     r1,#0x40
;;;303    {
;;;304    	CHECK_PARAM(PARAM_I2Cx(I2Cx));
;;;305    
;;;306    	/* Disable I2C control */
;;;307    	I2Cx->CONCLR = I2C_I2CONCLR_I2ENC;
000122  6181              STR      r1,[r0,#0x18]
;;;308    
;;;309    }
000124  4770              BX       lr
;;;310    
                          ENDP

                  I2C_Cmd PROC
;;;321     **********************************************************************/
;;;322    void I2C_Cmd(LPC_I2Cn_Type* I2Cx, FunctionalState NewState)
000126  2901              CMP      r1,#1
;;;323    {
;;;324    	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;325    	CHECK_PARAM(PARAM_I2Cx(I2Cx));
;;;326    
;;;327    	if (NewState == ENABLE)
000128  d102              BNE      |L1.304|
;;;328    	{
;;;329    		I2Cx->CONSET = I2C_I2CONSET_I2EN;
00012a  2240              MOVS     r2,#0x40
00012c  6002              STR      r2,[r0,#0]
00012e  e001              B        |L1.308|
                  |L1.304|
;;;330    	}
;;;331    	else
;;;332    	{
;;;333    		I2Cx->CONCLR = I2C_I2CONCLR_I2ENC;
000130  2240              MOVS     r2,#0x40
000132  6182              STR      r2,[r0,#0x18]
                  |L1.308|
;;;334    	}
;;;335    }
000134  4770              BX       lr
;;;336    
                          ENDP

                  I2C_IntCmd PROC
;;;348     **********************************************************************/
;;;349    void I2C_IntCmd (LPC_I2Cn_Type *I2Cx, Bool NewState)
000136  b570              PUSH     {r4-r6,lr}
;;;350    {
000138  4604              MOV      r4,r0
00013a  460d              MOV      r5,r1
;;;351    	if (NewState)
00013c  b16d              CBZ      r5,|L1.346|
;;;352    	{
;;;353    		if(I2Cx == LPC_I2C0)
00013e  48a8              LDR      r0,|L1.992|
000140  4284              CMP      r4,r0
000142  d103              BNE      |L1.332|
;;;354    		{
;;;355    			NVIC_EnableIRQ(I2C0_IRQn);
000144  2012              MOVS     r0,#0x12
000146  f7fffffe          BL       NVIC_EnableIRQ
00014a  e013              B        |L1.372|
                  |L1.332|
;;;356    		}
;;;357    		else if (I2Cx == LPC_I2C1)
00014c  48a5              LDR      r0,|L1.996|
00014e  4284              CMP      r4,r0
000150  d110              BNE      |L1.372|
;;;358    		{
;;;359    			NVIC_EnableIRQ(I2C1_IRQn);
000152  2013              MOVS     r0,#0x13
000154  f7fffffe          BL       NVIC_EnableIRQ
000158  e00c              B        |L1.372|
                  |L1.346|
;;;360    		}
;;;361    	}
;;;362    	else
;;;363    	{
;;;364    		if(I2Cx == LPC_I2C0)
00015a  48a1              LDR      r0,|L1.992|
00015c  4284              CMP      r4,r0
00015e  d103              BNE      |L1.360|
;;;365    		{
;;;366    			NVIC_DisableIRQ(I2C0_IRQn);
000160  2012              MOVS     r0,#0x12
000162  f7fffffe          BL       NVIC_DisableIRQ
000166  e005              B        |L1.372|
                  |L1.360|
;;;367    		}
;;;368    		else if (I2Cx == LPC_I2C1)
000168  489e              LDR      r0,|L1.996|
00016a  4284              CMP      r4,r0
00016c  d102              BNE      |L1.372|
;;;369    		{
;;;370    			NVIC_DisableIRQ(I2C1_IRQn);
00016e  2013              MOVS     r0,#0x13
000170  f7fffffe          BL       NVIC_DisableIRQ
                  |L1.372|
;;;371    		}
;;;372    	}
;;;373        return;
;;;374    }
000174  bd70              POP      {r4-r6,pc}
;;;375    
                          ENDP

                  I2C_MasterHandler PROC
;;;383     **********************************************************************/
;;;384    void I2C_MasterHandler (LPC_I2Cn_Type  *I2Cx)
000176  e92d41f0          PUSH     {r4-r8,lr}
;;;385    {
00017a  4605              MOV      r5,r0
;;;386    	int32_t tmp;
;;;387    	uint8_t returnCode;
;;;388    	I2C_M_SETUP_Type *txrx_setup;
;;;389    
;;;390    	tmp = I2C_getNum(I2Cx);
00017c  4628              MOV      r0,r5
00017e  f7fffffe          BL       I2C_getNum
000182  4606              MOV      r6,r0
;;;391    	txrx_setup = (I2C_M_SETUP_Type *) i2cdat[tmp].txrx_setup;
000184  489d              LDR      r0,|L1.1020|
000186  f8504036          LDR      r4,[r0,r6,LSL #3]
;;;392    
;;;393    	returnCode = (I2Cx->STAT & I2C_STAT_CODE_BITMASK);
00018a  6868              LDR      r0,[r5,#4]
00018c  f00007f8          AND      r7,r0,#0xf8
;;;394    	// Save current status
;;;395    	txrx_setup->status = returnCode;
000190  6267              STR      r7,[r4,#0x24]
;;;396    	// there's no relevant information
;;;397    	if (returnCode == I2C_I2STAT_NO_INF){
000192  2ff8              CMP      r7,#0xf8
000194  d103              BNE      |L1.414|
;;;398    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
000196  2008              MOVS     r0,#8
000198  61a8              STR      r0,[r5,#0x18]
                  |L1.410|
;;;399    		return;
;;;400    	}
;;;401    
;;;402    	/* ----------------------------- TRANSMIT PHASE --------------------------*/
;;;403    	if (i2cdat[tmp].dir == 0){
;;;404    		switch (returnCode)
;;;405    		{
;;;406    		/* A start/repeat start condition has been transmitted -------------------*/
;;;407    		case I2C_I2STAT_M_TX_START:
;;;408    		case I2C_I2STAT_M_TX_RESTART:
;;;409    			I2Cx->CONCLR = I2C_I2CONCLR_STAC;
;;;410    			/*
;;;411    			 * If there's any transmit data, then start to
;;;412    			 * send SLA+W right now, otherwise check whether if there's
;;;413    			 * any receive data for next state.
;;;414    			 */
;;;415    			if ((txrx_setup->tx_data != NULL) && (txrx_setup->tx_length != 0)){
;;;416    				I2Cx->DAT = (txrx_setup->sl_addr7bit << 1);
;;;417    				I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;418    			} else {
;;;419    				goto next_stage;
;;;420    			}
;;;421    			break;
;;;422    
;;;423    		/* SLA+W has been transmitted, ACK has been received ----------------------*/
;;;424    		case I2C_I2STAT_M_TX_SLAW_ACK:
;;;425    		/* Data has been transmitted, ACK has been received */
;;;426    		case I2C_I2STAT_M_TX_DAT_ACK:
;;;427    			/* Send more data */
;;;428    			if ((txrx_setup->tx_count < txrx_setup->tx_length) \
;;;429    					&& (txrx_setup->tx_data != NULL)){
;;;430    				I2Cx->DAT =  *(uint8_t *)(txrx_setup->tx_data + txrx_setup->tx_count);
;;;431    				txrx_setup->tx_count++;
;;;432    				I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;433    			}
;;;434    			// no more data, switch to next stage
;;;435    			else {
;;;436    next_stage:
;;;437    				// change direction
;;;438    				i2cdat[tmp].dir = 1;
;;;439    				// Check if any data to receive
;;;440    				if ((txrx_setup->rx_length != 0) && (txrx_setup->rx_data != NULL)){
;;;441    						// check whether if we need to issue an repeat start
;;;442    						if ((txrx_setup->tx_length != 0) && (txrx_setup->tx_data != NULL)){
;;;443    							// Send out an repeat start command
;;;444    							I2Cx->CONSET = I2C_I2CONSET_STA;
;;;445    							I2Cx->CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC;
;;;446    						}
;;;447    						// Don't need issue an repeat start, just goto send SLA+R
;;;448    						else {
;;;449    							goto send_slar;
;;;450    						}
;;;451    				}
;;;452    				// no more data send, the go to end stage now
;;;453    				else {
;;;454    					// success, goto end stage
;;;455    					txrx_setup->status |= I2C_SETUP_STATUS_DONE;
;;;456    					goto end_stage;
;;;457    				}
;;;458    			}
;;;459    			break;
;;;460    
;;;461    		/* SLA+W has been transmitted, NACK has been received ----------------------*/
;;;462    		case I2C_I2STAT_M_TX_SLAW_NACK:
;;;463    		/* Data has been transmitted, NACK has been received -----------------------*/
;;;464    		case I2C_I2STAT_M_TX_DAT_NACK:
;;;465    			// update status
;;;466    			txrx_setup->status |= I2C_SETUP_STATUS_NOACKF;
;;;467    			goto retry;
;;;468    		/* Arbitration lost in SLA+R/W or Data bytes -------------------------------*/
;;;469    		case I2C_I2STAT_M_TX_ARB_LOST:
;;;470    			// update status
;;;471    			txrx_setup->status |= I2C_SETUP_STATUS_ARBF;
;;;472    		default:
;;;473    			goto retry;
;;;474    		}
;;;475    	}
;;;476    
;;;477    	/* ----------------------------- RECEIVE PHASE --------------------------*/
;;;478    	else if (i2cdat[tmp].dir == 1){
;;;479    		switch (returnCode){
;;;480    			/* A start/repeat start condition has been transmitted ---------------------*/
;;;481    		case I2C_I2STAT_M_RX_START:
;;;482    		case I2C_I2STAT_M_RX_RESTART:
;;;483    			I2Cx->CONCLR = I2C_I2CONCLR_STAC;
;;;484    			/*
;;;485    			 * If there's any receive data, then start to
;;;486    			 * send SLA+R right now, otherwise check whether if there's
;;;487    			 * any receive data for end of state.
;;;488    			 */
;;;489    			if ((txrx_setup->rx_data != NULL) && (txrx_setup->rx_length != 0)){
;;;490    send_slar:
;;;491    				I2Cx->DAT = (txrx_setup->sl_addr7bit << 1) | 0x01;
;;;492    				I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;493    			} else {
;;;494    				// Success, goto end stage
;;;495    				txrx_setup->status |= I2C_SETUP_STATUS_DONE;
;;;496    				goto end_stage;
;;;497    			}
;;;498    			break;
;;;499    
;;;500    		/* SLA+R has been transmitted, ACK has been received -----------------*/
;;;501    		case I2C_I2STAT_M_RX_SLAR_ACK:
;;;502    			if (txrx_setup->rx_count < (txrx_setup->rx_length - 1)) {
;;;503    				/*Data will be received,  ACK will be return*/
;;;504    				I2Cx->CONSET = I2C_I2CONSET_AA;
;;;505    			}
;;;506    			else {
;;;507    				/*Last data will be received,  NACK will be return*/
;;;508    				I2Cx->CONCLR = I2C_I2CONSET_AA;
;;;509    			}
;;;510    			I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;511    			break;
;;;512    
;;;513    		/* Data has been received, ACK has been returned ----------------------*/
;;;514    		case I2C_I2STAT_M_RX_DAT_ACK:
;;;515    			// Note save data and increase counter first, then check later
;;;516    			/* Save data  */
;;;517    			if ((txrx_setup->rx_data != NULL) && (txrx_setup->rx_count < txrx_setup->rx_length)){
;;;518    				*(uint8_t *)(txrx_setup->rx_data + txrx_setup->rx_count) = (I2Cx->DAT & I2C_I2DAT_BITMASK);
;;;519    				txrx_setup->rx_count++;
;;;520    			}
;;;521    			if (txrx_setup->rx_count < (txrx_setup->rx_length - 1)) {
;;;522    				/*Data will be received,  ACK will be return*/
;;;523    				I2Cx->CONSET = I2C_I2CONSET_AA;
;;;524    			}
;;;525    			else {
;;;526    				/*Last data will be received,  NACK will be return*/
;;;527    				I2Cx->CONCLR = I2C_I2CONSET_AA;
;;;528    			}
;;;529    
;;;530    			I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;531    			break;
;;;532    
;;;533    		/* Data has been received, NACK has been return -------------------------*/
;;;534    		case I2C_I2STAT_M_RX_DAT_NACK:
;;;535    			/* Save the last data */
;;;536    			if ((txrx_setup->rx_data != NULL) && (txrx_setup->rx_count < txrx_setup->rx_length)){
;;;537    				*(uint8_t *)(txrx_setup->rx_data + txrx_setup->rx_count) = (I2Cx->DAT & I2C_I2DAT_BITMASK);
;;;538    				txrx_setup->rx_count++;
;;;539    			}
;;;540    			// success, go to end stage
;;;541    			txrx_setup->status |= I2C_SETUP_STATUS_DONE;
;;;542    			goto end_stage;
;;;543    
;;;544    		/* SLA+R has been transmitted, NACK has been received ------------------*/
;;;545    		case I2C_I2STAT_M_RX_SLAR_NACK:
;;;546    			// update status
;;;547    			txrx_setup->status |= I2C_SETUP_STATUS_NOACKF;
;;;548    			goto retry;
;;;549    
;;;550    		/* Arbitration lost ----------------------------------------------------*/
;;;551    		case I2C_I2STAT_M_RX_ARB_LOST:
;;;552    			// update status
;;;553    			txrx_setup->status |= I2C_SETUP_STATUS_ARBF;
;;;554    		default:
;;;555    retry:
;;;556    			// check if retransmission is available
;;;557    			if (txrx_setup->retransmissions_count < txrx_setup->retransmissions_max){
;;;558    				// Clear tx count
;;;559    				txrx_setup->tx_count = 0;
;;;560    				I2Cx->CONSET = I2C_I2CONSET_STA;
;;;561    				I2Cx->CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC;
;;;562    				txrx_setup->retransmissions_count++;
;;;563    			}
;;;564    			// End of stage
;;;565    			else {
;;;566    end_stage:
;;;567    				// Disable interrupt
;;;568    				I2C_IntCmd(I2Cx, FALSE);
;;;569    				// Send stop
;;;570    				I2C_Stop(I2Cx);
;;;571    				
;;;572    				I2C_MasterComplete[tmp] = TRUE;
;;;573    			}
;;;574    			break;
;;;575    		}
;;;576    	}
;;;577    }
00019a  e8bd81f0          POP      {r4-r8,pc}
                  |L1.414|
00019e  4897              LDR      r0,|L1.1020|
0001a0  eb0000c6          ADD      r0,r0,r6,LSL #3       ;403
0001a4  6840              LDR      r0,[r0,#4]            ;403
0001a6  2800              CMP      r0,#0                 ;403
0001a8  d157              BNE      |L1.602|
0001aa  2f20              CMP      r7,#0x20              ;404
0001ac  d048              BEQ      |L1.576|
0001ae  dc06              BGT      |L1.446|
0001b0  2f08              CMP      r7,#8                 ;404
0001b2  d00b              BEQ      |L1.460|
0001b4  2f10              CMP      r7,#0x10              ;404
0001b6  d00a              BEQ      |L1.462|
0001b8  2f18              CMP      r7,#0x18              ;404
0001ba  d14c              BNE      |L1.598|
0001bc  e015              B        |L1.490|
                  |L1.446|
0001be  2f28              CMP      r7,#0x28              ;404
0001c0  d014              BEQ      |L1.492|
0001c2  2f30              CMP      r7,#0x30              ;404
0001c4  d03d              BEQ      |L1.578|
0001c6  2f38              CMP      r7,#0x38              ;404
0001c8  d145              BNE      |L1.598|
0001ca  e03f              B        |L1.588|
                  |L1.460|
0001cc  bf00              NOP                            ;408
                  |L1.462|
0001ce  2020              MOVS     r0,#0x20              ;409
0001d0  61a8              STR      r0,[r5,#0x18]         ;409
0001d2  6860              LDR      r0,[r4,#4]            ;415
0001d4  b138              CBZ      r0,|L1.486|
0001d6  68a0              LDR      r0,[r4,#8]            ;415
0001d8  b128              CBZ      r0,|L1.486|
0001da  6820              LDR      r0,[r4,#0]            ;416
0001dc  0040              LSLS     r0,r0,#1              ;416
0001de  60a8              STR      r0,[r5,#8]            ;416
0001e0  2008              MOVS     r0,#8                 ;417
0001e2  61a8              STR      r0,[r5,#0x18]         ;417
0001e4  e000              B        |L1.488|
                  |L1.486|
0001e6  e012              B        |L1.526|
                  |L1.488|
0001e8  e036              B        |L1.600|
                  |L1.490|
0001ea  bf00              NOP                            ;426
                  |L1.492|
0001ec  e9d41002          LDRD     r1,r0,[r4,#8]         ;428
0001f0  4288              CMP      r0,r1                 ;428
0001f2  d20b              BCS      |L1.524|
0001f4  6860              LDR      r0,[r4,#4]            ;429
0001f6  b148              CBZ      r0,|L1.524|
0001f8  68e1              LDR      r1,[r4,#0xc]          ;430
0001fa  6860              LDR      r0,[r4,#4]            ;430
0001fc  5c40              LDRB     r0,[r0,r1]            ;430
0001fe  60a8              STR      r0,[r5,#8]            ;430
000200  68e0              LDR      r0,[r4,#0xc]          ;431
000202  1c40              ADDS     r0,r0,#1              ;431
000204  60e0              STR      r0,[r4,#0xc]          ;431
000206  2008              MOVS     r0,#8                 ;432
000208  61a8              STR      r0,[r5,#0x18]         ;432
00020a  e018              B        |L1.574|
                  |L1.524|
00020c  bf00              NOP                            ;436
                  |L1.526|
00020e  2001              MOVS     r0,#1                 ;438
000210  497a              LDR      r1,|L1.1020|
000212  eb0101c6          ADD      r1,r1,r6,LSL #3       ;438
000216  6048              STR      r0,[r1,#4]            ;438
000218  6960              LDR      r0,[r4,#0x14]         ;440
00021a  b158              CBZ      r0,|L1.564|
00021c  6920              LDR      r0,[r4,#0x10]         ;440
00021e  b148              CBZ      r0,|L1.564|
000220  68a0              LDR      r0,[r4,#8]            ;442
000222  b130              CBZ      r0,|L1.562|
000224  6860              LDR      r0,[r4,#4]            ;442
000226  b120              CBZ      r0,|L1.562|
000228  2020              MOVS     r0,#0x20              ;444
00022a  6028              STR      r0,[r5,#0]            ;444
00022c  200c              MOVS     r0,#0xc               ;445
00022e  61a8              STR      r0,[r5,#0x18]         ;445
000230  e005              B        |L1.574|
                  |L1.562|
000232  e031              B        |L1.664|
                  |L1.564|
000234  6a60              LDR      r0,[r4,#0x24]         ;455
000236  f4406080          ORR      r0,r0,#0x400          ;455
00023a  6260              STR      r0,[r4,#0x24]         ;455
00023c  e08d              B        |L1.858|
                  |L1.574|
00023e  e00b              B        |L1.600|
                  |L1.576|
000240  bf00              NOP                            ;464
                  |L1.578|
000242  6a60              LDR      r0,[r4,#0x24]         ;466
000244  f4407000          ORR      r0,r0,#0x200          ;466
000248  6260              STR      r0,[r4,#0x24]         ;466
00024a  e077              B        |L1.828|
                  |L1.588|
00024c  6a60              LDR      r0,[r4,#0x24]         ;471
00024e  f4407080          ORR      r0,r0,#0x100          ;471
000252  6260              STR      r0,[r4,#0x24]         ;471
000254  bf00              NOP                            ;472
                  |L1.598|
000256  e071              B        |L1.828|
                  |L1.600|
000258  e08c              B        |L1.884|
                  |L1.602|
00025a  4868              LDR      r0,|L1.1020|
00025c  eb0000c6          ADD      r0,r0,r6,LSL #3       ;478
000260  6840              LDR      r0,[r0,#4]            ;478
000262  2801              CMP      r0,#1                 ;478
000264  d1f8              BNE      |L1.600|
000266  2f40              CMP      r7,#0x40              ;479
000268  d024              BEQ      |L1.692|
00026a  dc06              BGT      |L1.634|
00026c  2f08              CMP      r7,#8                 ;479
00026e  d00b              BEQ      |L1.648|
000270  2f10              CMP      r7,#0x10              ;479
000272  d00a              BEQ      |L1.650|
000274  2f38              CMP      r7,#0x38              ;479
000276  d160              BNE      |L1.826|
000278  e05a              B        |L1.816|
                  |L1.634|
00027a  2f48              CMP      r7,#0x48              ;479
00027c  d053              BEQ      |L1.806|
00027e  2f50              CMP      r7,#0x50              ;479
000280  d025              BEQ      |L1.718|
000282  2f58              CMP      r7,#0x58              ;479
000284  d159              BNE      |L1.826|
000286  e03c              B        |L1.770|
                  |L1.648|
000288  bf00              NOP                            ;482
                  |L1.650|
00028a  2020              MOVS     r0,#0x20              ;483
00028c  61a8              STR      r0,[r5,#0x18]         ;483
00028e  6920              LDR      r0,[r4,#0x10]         ;489
000290  b150              CBZ      r0,|L1.680|
000292  6960              LDR      r0,[r4,#0x14]         ;489
000294  b140              CBZ      r0,|L1.680|
000296  bf00              NOP                            ;490
                  |L1.664|
000298  2101              MOVS     r1,#1                 ;491
00029a  6820              LDR      r0,[r4,#0]            ;491
00029c  eb010040          ADD      r0,r1,r0,LSL #1       ;491
0002a0  60a8              STR      r0,[r5,#8]            ;491
0002a2  2008              MOVS     r0,#8                 ;492
0002a4  61a8              STR      r0,[r5,#0x18]         ;492
0002a6  e004              B        |L1.690|
                  |L1.680|
0002a8  6a60              LDR      r0,[r4,#0x24]         ;495
0002aa  f4406080          ORR      r0,r0,#0x400          ;495
0002ae  6260              STR      r0,[r4,#0x24]         ;495
0002b0  e053              B        |L1.858|
                  |L1.690|
0002b2  e05e              B        |L1.882|
                  |L1.692|
0002b4  e9d40105          LDRD     r0,r1,[r4,#0x14]      ;502
0002b8  1e40              SUBS     r0,r0,#1              ;502
0002ba  4281              CMP      r1,r0                 ;502
0002bc  d202              BCS      |L1.708|
0002be  2004              MOVS     r0,#4                 ;504
0002c0  6028              STR      r0,[r5,#0]            ;504
0002c2  e001              B        |L1.712|
                  |L1.708|
0002c4  2004              MOVS     r0,#4                 ;508
0002c6  61a8              STR      r0,[r5,#0x18]         ;508
                  |L1.712|
0002c8  2008              MOVS     r0,#8                 ;510
0002ca  61a8              STR      r0,[r5,#0x18]         ;510
0002cc  e051              B        |L1.882|
                  |L1.718|
0002ce  6920              LDR      r0,[r4,#0x10]         ;517
0002d0  b150              CBZ      r0,|L1.744|
0002d2  e9d41005          LDRD     r1,r0,[r4,#0x14]      ;517
0002d6  4288              CMP      r0,r1                 ;517
0002d8  d206              BCS      |L1.744|
0002da  68a8              LDR      r0,[r5,#8]            ;518
0002dc  69a2              LDR      r2,[r4,#0x18]         ;518
0002de  6921              LDR      r1,[r4,#0x10]         ;518
0002e0  5488              STRB     r0,[r1,r2]            ;518
0002e2  69a0              LDR      r0,[r4,#0x18]         ;519
0002e4  1c40              ADDS     r0,r0,#1              ;519
0002e6  61a0              STR      r0,[r4,#0x18]         ;519
                  |L1.744|
0002e8  e9d40105          LDRD     r0,r1,[r4,#0x14]      ;521
0002ec  1e40              SUBS     r0,r0,#1              ;521
0002ee  4281              CMP      r1,r0                 ;521
0002f0  d202              BCS      |L1.760|
0002f2  2004              MOVS     r0,#4                 ;523
0002f4  6028              STR      r0,[r5,#0]            ;523
0002f6  e001              B        |L1.764|
                  |L1.760|
0002f8  2004              MOVS     r0,#4                 ;527
0002fa  61a8              STR      r0,[r5,#0x18]         ;527
                  |L1.764|
0002fc  2008              MOVS     r0,#8                 ;530
0002fe  61a8              STR      r0,[r5,#0x18]         ;530
000300  e037              B        |L1.882|
                  |L1.770|
000302  6920              LDR      r0,[r4,#0x10]         ;536
000304  b150              CBZ      r0,|L1.796|
000306  e9d41005          LDRD     r1,r0,[r4,#0x14]      ;536
00030a  4288              CMP      r0,r1                 ;536
00030c  d206              BCS      |L1.796|
00030e  68a8              LDR      r0,[r5,#8]            ;537
000310  69a2              LDR      r2,[r4,#0x18]         ;537
000312  6921              LDR      r1,[r4,#0x10]         ;537
000314  5488              STRB     r0,[r1,r2]            ;537
000316  69a0              LDR      r0,[r4,#0x18]         ;538
000318  1c40              ADDS     r0,r0,#1              ;538
00031a  61a0              STR      r0,[r4,#0x18]         ;538
                  |L1.796|
00031c  6a60              LDR      r0,[r4,#0x24]         ;541
00031e  f4406080          ORR      r0,r0,#0x400          ;541
000322  6260              STR      r0,[r4,#0x24]         ;541
000324  e019              B        |L1.858|
                  |L1.806|
000326  6a60              LDR      r0,[r4,#0x24]         ;547
000328  f4407000          ORR      r0,r0,#0x200          ;547
00032c  6260              STR      r0,[r4,#0x24]         ;547
00032e  e005              B        |L1.828|
                  |L1.816|
000330  6a60              LDR      r0,[r4,#0x24]         ;553
000332  f4407080          ORR      r0,r0,#0x100          ;553
000336  6260              STR      r0,[r4,#0x24]         ;553
000338  bf00              NOP                            ;554
                  |L1.826|
00033a  bf00              NOP                            ;555
                  |L1.828|
00033c  e9d41007          LDRD     r1,r0,[r4,#0x1c]      ;557
000340  4288              CMP      r0,r1                 ;557
000342  d209              BCS      |L1.856|
000344  2000              MOVS     r0,#0                 ;559
000346  60e0              STR      r0,[r4,#0xc]          ;559
000348  2020              MOVS     r0,#0x20              ;560
00034a  6028              STR      r0,[r5,#0]            ;560
00034c  200c              MOVS     r0,#0xc               ;561
00034e  61a8              STR      r0,[r5,#0x18]         ;561
000350  6a20              LDR      r0,[r4,#0x20]         ;562
000352  1c40              ADDS     r0,r0,#1              ;562
000354  6220              STR      r0,[r4,#0x20]         ;562
000356  e00b              B        |L1.880|
                  |L1.856|
000358  bf00              NOP                            ;566
                  |L1.858|
00035a  2100              MOVS     r1,#0                 ;568
00035c  4628              MOV      r0,r5                 ;568
00035e  f7fffffe          BL       I2C_IntCmd
000362  4628              MOV      r0,r5                 ;570
000364  f7fffffe          BL       I2C_Stop
000368  2001              MOVS     r0,#1                 ;572
00036a  4925              LDR      r1,|L1.1024|
00036c  f8410026          STR      r0,[r1,r6,LSL #2]     ;572
                  |L1.880|
000370  bf00              NOP                            ;574
                  |L1.882|
000372  bf00              NOP                            ;498
                  |L1.884|
000374  bf00              NOP      
000376  e710              B        |L1.410|
;;;578    
                          ENDP

                  I2C_SlaveHandler PROC
;;;586     **********************************************************************/
;;;587    void I2C_SlaveHandler (LPC_I2Cn_Type  *I2Cx)
000378  e92d41f0          PUSH     {r4-r8,lr}
;;;588    {
00037c  4604              MOV      r4,r0
;;;589    	int32_t tmp;
;;;590    	uint8_t returnCode;
;;;591    	I2C_S_SETUP_Type *txrx_setup;
;;;592    	uint32_t timeout;
;;;593    
;;;594    	tmp = I2C_getNum(I2Cx);
00037e  4620              MOV      r0,r4
000380  f7fffffe          BL       I2C_getNum
000384  4680              MOV      r8,r0
;;;595    	txrx_setup = (I2C_S_SETUP_Type *) i2cdat[tmp].txrx_setup;
000386  481d              LDR      r0,|L1.1020|
000388  f8505038          LDR      r5,[r0,r8,LSL #3]
;;;596    
;;;597    	returnCode = (I2Cx->STAT & I2C_STAT_CODE_BITMASK);
00038c  6860              LDR      r0,[r4,#4]
00038e  f00006f8          AND      r6,r0,#0xf8
;;;598    	// Save current status
;;;599    	txrx_setup->status = returnCode;
000392  61ae              STR      r6,[r5,#0x18]
;;;600    	// there's no relevant information
;;;601    	if (returnCode == I2C_I2STAT_NO_INF){
000394  2ef8              CMP      r6,#0xf8
000396  d103              BNE      |L1.928|
;;;602    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
000398  2008              MOVS     r0,#8
00039a  61a0              STR      r0,[r4,#0x18]
                  |L1.924|
;;;603    		return;
;;;604    	}
;;;605    
;;;606    
;;;607    	switch (returnCode)
;;;608    	{
;;;609    
;;;610    	/* No status information */
;;;611    	case I2C_I2STAT_NO_INF:
;;;612    		I2Cx->CONSET = I2C_I2CONSET_AA;
;;;613    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;614    		break;
;;;615    
;;;616    	/* Reading phase -------------------------------------------------------- */
;;;617    	/* Own SLA+R has been received, ACK has been returned */
;;;618    	case I2C_I2STAT_S_RX_SLAW_ACK:
;;;619    	/* General call address has been received, ACK has been returned */
;;;620    	case I2C_I2STAT_S_RX_GENCALL_ACK:
;;;621    		I2Cx->CONSET = I2C_I2CONSET_AA;
;;;622    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;623    		break;
;;;624    
;;;625    	/* Previously addressed with own SLA;
;;;626    	 * DATA byte has been received;
;;;627    	 * ACK has been returned */
;;;628    	case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:
;;;629    	/* DATA has been received, ACK hasn been return */
;;;630    	case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:
;;;631    		/*
;;;632    		 * All data bytes that over-flow the specified receive
;;;633    		 * data length, just ignore them.
;;;634    		 */
;;;635    		if ((txrx_setup->rx_count < txrx_setup->rx_length) \
;;;636    				&& (txrx_setup->rx_data != NULL)){
;;;637    			*(uint8_t *)(txrx_setup->rx_data + txrx_setup->rx_count) = (uint8_t)I2Cx->DAT;
;;;638    			txrx_setup->rx_count++;
;;;639    		}
;;;640    		I2Cx->CONSET = I2C_I2CONSET_AA;
;;;641    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;642    		break;
;;;643    
;;;644    	/* Previously addressed with own SLA;
;;;645    	 * DATA byte has been received;
;;;646    	 * NOT ACK has been returned */
;;;647    	case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:
;;;648    	/* DATA has been received, NOT ACK has been returned */
;;;649    	case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:
;;;650    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;651    		break;
;;;652    
;;;653    	/*
;;;654    	 * Note that: Return code only let us know a stop condition mixed
;;;655    	 * with a repeat start condition in the same code value.
;;;656    	 * So we should provide a time-out. In case this is really a stop
;;;657    	 * condition, this will return back after time out condition. Otherwise,
;;;658    	 * next session that is slave receive data will be completed.
;;;659    	 */
;;;660    
;;;661    	/* A Stop or a repeat start condition */
;;;662    	case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:
;;;663    		// Temporally lock the interrupt for timeout condition
;;;664    		I2C_IntCmd(I2Cx, FALSE);
;;;665    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;666    		// enable time out
;;;667    		timeout = I2C_SLAVE_TIME_OUT;
;;;668    		while(1){
;;;669    			if (I2Cx->CONSET & I2C_I2CONSET_SI){
;;;670    				// re-Enable interrupt
;;;671    				I2C_IntCmd(I2Cx, TRUE);
;;;672    				break;
;;;673    			} else {
;;;674    				timeout--;
;;;675    				if (timeout == 0){
;;;676    					// timeout occur, it's really a stop condition
;;;677    					txrx_setup->status |= I2C_SETUP_STATUS_DONE;
;;;678    					goto s_int_end;
;;;679    				}
;;;680    			}
;;;681    		}
;;;682    		break;
;;;683    
;;;684    	/* Writing phase -------------------------------------------------------- */
;;;685    	/* Own SLA+R has been received, ACK has been returned */
;;;686    	case I2C_I2STAT_S_TX_SLAR_ACK:
;;;687    	/* Data has been transmitted, ACK has been received */
;;;688    	case I2C_I2STAT_S_TX_DAT_ACK:
;;;689    		/*
;;;690    		 * All data bytes that over-flow the specified receive
;;;691    		 * data length, just ignore them.
;;;692    		 */
;;;693    		if ((txrx_setup->tx_count < txrx_setup->tx_length) \
;;;694    				&& (txrx_setup->tx_data != NULL)){
;;;695    			I2Cx->DAT = *(uint8_t *) (txrx_setup->tx_data + txrx_setup->tx_count);
;;;696    			txrx_setup->tx_count++;
;;;697    		}
;;;698    		I2Cx->CONSET = I2C_I2CONSET_AA;
;;;699    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;700    		break;
;;;701    
;;;702    	/* Data has been transmitted, NACK has been received,
;;;703    	 * that means there's no more data to send, exit now */
;;;704    	/*
;;;705    	 * Note: Don't wait for stop event since in slave transmit mode,
;;;706    	 * since there no proof lets us know when a stop signal has been received
;;;707    	 * on slave side.
;;;708    	 */
;;;709    	case I2C_I2STAT_S_TX_DAT_NACK:
;;;710    		I2Cx->CONSET = I2C_I2CONSET_AA;
;;;711    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;712    		txrx_setup->status |= I2C_SETUP_STATUS_DONE;
;;;713    		goto s_int_end;
;;;714    
;;;715    	// Other status must be captured
;;;716    	default:
;;;717    s_int_end:
;;;718    		// Disable interrupt
;;;719    		I2C_IntCmd(I2Cx, FALSE);
;;;720    		I2Cx->CONCLR = I2C_I2CONCLR_AAC | I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
;;;721    		I2C_SlaveComplete[tmp] = TRUE;
;;;722    		break;
;;;723    	}
;;;724    }
00039c  e8bd81f0          POP      {r4-r8,pc}
                  |L1.928|
0003a0  f0060007          AND      r0,r6,#7              ;607
0003a4  2800              CMP      r0,#0                 ;607
0003a6  d17c              BNE      |L1.1186|
0003a8  10f0              ASRS     r0,r6,#3              ;607
0003aa  380c              SUBS     r0,r0,#0xc            ;607
0003ac  2814              CMP      r0,#0x14              ;607
0003ae  d278              BCS      |L1.1186|
0003b0  e8dff000          TBB      [pc,r0]               ;607
0003b4  0f771077          DCB      0x0f,0x77,0x10,0x77
0003b8  283b293c          DCB      0x28,0x3b,0x29,0x3c
0003bc  3f5a775b          DCB      0x3f,0x5a,0x77,0x5b
0003c0  6e777777          DCB      0x6e,0x77,0x77,0x77
0003c4  7777770a          DCB      0x77,0x77,0x77,0x0a
0003c8  2004              MOVS     r0,#4                 ;612
0003ca  6020              STR      r0,[r4,#0]            ;612
0003cc  2008              MOVS     r0,#8                 ;613
0003ce  61a0              STR      r0,[r4,#0x18]         ;613
0003d0  e073              B        |L1.1210|
0003d2  bf00              NOP                            ;620
0003d4  2004              MOVS     r0,#4                 ;621
0003d6  6020              STR      r0,[r4,#0]            ;621
0003d8  2008              MOVS     r0,#8                 ;622
0003da  61a0              STR      r0,[r4,#0x18]         ;622
0003dc  e06d              B        |L1.1210|
0003de  0000              DCW      0x0000
                  |L1.992|
                          DCD      0x400a1000
                  |L1.996|
                          DCD      0x400e0000
                  |L1.1000|
                          DCD      0x000f4240
                  |L1.1004|
                          DCD      0x40086c84
                  |L1.1008|
                          DCD      0x4008610c
                  |L1.1012|
                          DCD      0x40086000
                  |L1.1016|
                          DCD      0x00061a80
                  |L1.1020|
                          DCD      i2cdat
                  |L1.1024|
                          DCD      I2C_MasterComplete
000404  bf00              NOP                            ;630
000406  e9d51004          LDRD     r1,r0,[r5,#0x10]      ;635
00040a  4288              CMP      r0,r1                 ;635
00040c  d208              BCS      |L1.1056|
00040e  68e8              LDR      r0,[r5,#0xc]          ;636
000410  b130              CBZ      r0,|L1.1056|
000412  68a0              LDR      r0,[r4,#8]            ;637
000414  696a              LDR      r2,[r5,#0x14]         ;637
000416  68e9              LDR      r1,[r5,#0xc]          ;637
000418  5488              STRB     r0,[r1,r2]            ;637
00041a  6968              LDR      r0,[r5,#0x14]         ;638
00041c  1c40              ADDS     r0,r0,#1              ;638
00041e  6168              STR      r0,[r5,#0x14]         ;638
                  |L1.1056|
000420  2004              MOVS     r0,#4                 ;640
000422  6020              STR      r0,[r4,#0]            ;640
000424  2008              MOVS     r0,#8                 ;641
000426  61a0              STR      r0,[r4,#0x18]         ;641
000428  e047              B        |L1.1210|
00042a  bf00              NOP                            ;649
00042c  2008              MOVS     r0,#8                 ;650
00042e  61a0              STR      r0,[r4,#0x18]         ;650
000430  e043              B        |L1.1210|
000432  2100              MOVS     r1,#0                 ;664
000434  4620              MOV      r0,r4                 ;664
000436  f7fffffe          BL       I2C_IntCmd
00043a  2008              MOVS     r0,#8                 ;665
00043c  61a0              STR      r0,[r4,#0x18]         ;665
00043e  0347              LSLS     r7,r0,#13             ;667
000440  e00f              B        |L1.1122|
                  |L1.1090|
000442  6820              LDR      r0,[r4,#0]            ;669
000444  f0000008          AND      r0,r0,#8              ;669
000448  b120              CBZ      r0,|L1.1108|
00044a  2101              MOVS     r1,#1                 ;671
00044c  4620              MOV      r0,r4                 ;671
00044e  f7fffffe          BL       I2C_IntCmd
000452  e007              B        |L1.1124|
                  |L1.1108|
000454  1e7f              SUBS     r7,r7,#1              ;674
000456  b927              CBNZ     r7,|L1.1122|
000458  69a8              LDR      r0,[r5,#0x18]         ;677
00045a  f4406080          ORR      r0,r0,#0x400          ;677
00045e  61a8              STR      r0,[r5,#0x18]         ;677
000460  e020              B        |L1.1188|
                  |L1.1122|
000462  e7ee              B        |L1.1090|
                  |L1.1124|
000464  bf00              NOP                            ;672
000466  e028              B        |L1.1210|
000468  bf00              NOP                            ;688
00046a  e9d51001          LDRD     r1,r0,[r5,#4]         ;693
00046e  4288              CMP      r0,r1                 ;693
000470  d208              BCS      |L1.1156|
000472  6828              LDR      r0,[r5,#0]            ;694
000474  b130              CBZ      r0,|L1.1156|
000476  68a9              LDR      r1,[r5,#8]            ;695
000478  6828              LDR      r0,[r5,#0]            ;695
00047a  5c40              LDRB     r0,[r0,r1]            ;695
00047c  60a0              STR      r0,[r4,#8]            ;695
00047e  68a8              LDR      r0,[r5,#8]            ;696
000480  1c40              ADDS     r0,r0,#1              ;696
000482  60a8              STR      r0,[r5,#8]            ;696
                  |L1.1156|
000484  2004              MOVS     r0,#4                 ;698
000486  6020              STR      r0,[r4,#0]            ;698
000488  2008              MOVS     r0,#8                 ;699
00048a  61a0              STR      r0,[r4,#0x18]         ;699
00048c  e015              B        |L1.1210|
00048e  e008              B        |L1.1186|
000490  2004              MOVS     r0,#4                 ;710
000492  6020              STR      r0,[r4,#0]            ;710
000494  2008              MOVS     r0,#8                 ;711
000496  61a0              STR      r0,[r4,#0x18]         ;711
000498  69a8              LDR      r0,[r5,#0x18]         ;712
00049a  f4406080          ORR      r0,r0,#0x400          ;712
00049e  61a8              STR      r0,[r5,#0x18]         ;712
0004a0  e000              B        |L1.1188|
                  |L1.1186|
0004a2  bf00              NOP                            ;717
                  |L1.1188|
0004a4  2100              MOVS     r1,#0                 ;719
0004a6  4620              MOV      r0,r4                 ;719
0004a8  f7fffffe          BL       I2C_IntCmd
0004ac  202c              MOVS     r0,#0x2c              ;720
0004ae  61a0              STR      r0,[r4,#0x18]         ;720
0004b0  2001              MOVS     r0,#1                 ;721
0004b2  49f8              LDR      r1,|L1.2196|
0004b4  f8410028          STR      r0,[r1,r8,LSL #2]     ;721
0004b8  bf00              NOP                            ;722
                  |L1.1210|
0004ba  bf00              NOP                            ;614
0004bc  bf00              NOP      
0004be  e76d              B        |L1.924|
;;;725    
                          ENDP

                  I2C_MasterTransferData PROC
;;;749     **********************************************************************/
;;;750    Status I2C_MasterTransferData(LPC_I2Cn_Type *I2Cx, I2C_M_SETUP_Type *TransferCfg, \
0004c0  e92d43f8          PUSH     {r3-r9,lr}
;;;751    								I2C_TRANSFER_OPT_Type Opt)
;;;752    {
0004c4  4606              MOV      r6,r0
0004c6  460c              MOV      r4,r1
0004c8  4617              MOV      r7,r2
;;;753    	uint8_t *txdat;
;;;754    	uint8_t *rxdat;
;;;755    	uint32_t CodeStatus;
;;;756    	uint8_t tmp;
;;;757    
;;;758    	// reset all default state
;;;759    	txdat = (uint8_t *) TransferCfg->tx_data;
0004ca  f8d48004          LDR      r8,[r4,#4]
;;;760    	rxdat = (uint8_t *) TransferCfg->rx_data;
0004ce  f8d49010          LDR      r9,[r4,#0x10]
;;;761    	// Reset I2C setup value to default state
;;;762    	TransferCfg->tx_count = 0;
0004d2  2000              MOVS     r0,#0
0004d4  60e0              STR      r0,[r4,#0xc]
;;;763    	TransferCfg->rx_count = 0;
0004d6  61a0              STR      r0,[r4,#0x18]
;;;764    	TransferCfg->status = 0;
0004d8  6260              STR      r0,[r4,#0x24]
;;;765    
;;;766    	if (Opt == I2C_TRANSFER_POLLING){
0004da  2f00              CMP      r7,#0
0004dc  d17e              BNE      |L1.1500|
;;;767    
;;;768    		/* First Start condition -------------------------------------------------------------- */
;;;769    		TransferCfg->retransmissions_count = 0;
0004de  6220              STR      r0,[r4,#0x20]
;;;770    retry:
0004e0  bf00              NOP      
                  |L1.1250|
;;;771    		// reset all default state
;;;772    		txdat = (uint8_t *) TransferCfg->tx_data;
0004e2  f8d48004          LDR      r8,[r4,#4]
;;;773    		rxdat = (uint8_t *) TransferCfg->rx_data;
0004e6  f8d49010          LDR      r9,[r4,#0x10]
;;;774    		// Reset I2C setup value to default state
;;;775    		TransferCfg->tx_count = 0;
0004ea  2000              MOVS     r0,#0
0004ec  60e0              STR      r0,[r4,#0xc]
;;;776    		TransferCfg->rx_count = 0;
0004ee  61a0              STR      r0,[r4,#0x18]
;;;777    		CodeStatus = 0;
0004f0  2500              MOVS     r5,#0
;;;778    
;;;779    		// Start command
;;;780    		CodeStatus = I2C_Start(I2Cx);
0004f2  4630              MOV      r0,r6
0004f4  f7fffffe          BL       I2C_Start
0004f8  4605              MOV      r5,r0
;;;781    		if ((CodeStatus != I2C_I2STAT_M_TX_START) \
0004fa  2d08              CMP      r5,#8
0004fc  d00b              BEQ      |L1.1302|
;;;782    				&& (CodeStatus != I2C_I2STAT_M_TX_RESTART)){
0004fe  2d10              CMP      r5,#0x10
000500  d009              BEQ      |L1.1302|
;;;783    			TransferCfg->retransmissions_count++;
000502  6a20              LDR      r0,[r4,#0x20]
000504  1c40              ADDS     r0,r0,#1
000506  6220              STR      r0,[r4,#0x20]
;;;784    			if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
000508  e9d41007          LDRD     r1,r0,[r4,#0x1c]
00050c  4288              CMP      r0,r1
00050e  d901              BLS      |L1.1300|
;;;785    				// save status
;;;786    				TransferCfg->status = CodeStatus;
000510  6265              STR      r5,[r4,#0x24]
;;;787    				goto error;
000512  e0ab              B        |L1.1644|
                  |L1.1300|
;;;788    			} else {
;;;789    				goto retry;
000514  e7e5              B        |L1.1250|
                  |L1.1302|
;;;790    			}
;;;791    		}
;;;792    
;;;793    		/* In case of sending data first --------------------------------------------------- */
;;;794    		if ((TransferCfg->tx_length != 0) && (TransferCfg->tx_data != NULL)){
000516  68a0              LDR      r0,[r4,#8]
000518  b3a0              CBZ      r0,|L1.1412|
00051a  6860              LDR      r0,[r4,#4]
00051c  b390              CBZ      r0,|L1.1412|
;;;795    
;;;796    			/* Send slave address + WR direction bit = 0 ----------------------------------- */
;;;797    			CodeStatus = I2C_SendByte(I2Cx, (TransferCfg->sl_addr7bit << 1));
00051e  7820              LDRB     r0,[r4,#0]
000520  0640              LSLS     r0,r0,#25
000522  0e01              LSRS     r1,r0,#24
000524  4630              MOV      r0,r6
000526  f7fffffe          BL       I2C_SendByte
00052a  4605              MOV      r5,r0
;;;798    			if (CodeStatus != I2C_I2STAT_M_TX_SLAW_ACK){
00052c  2d18              CMP      r5,#0x18
00052e  d00b              BEQ      |L1.1352|
;;;799    				TransferCfg->retransmissions_count++;
000530  6a20              LDR      r0,[r4,#0x20]
000532  1c40              ADDS     r0,r0,#1
000534  6220              STR      r0,[r4,#0x20]
;;;800    				if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
000536  e9d41007          LDRD     r1,r0,[r4,#0x1c]
00053a  4288              CMP      r0,r1
00053c  d903              BLS      |L1.1350|
;;;801    					// save status
;;;802    					TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
00053e  f4457000          ORR      r0,r5,#0x200
000542  6260              STR      r0,[r4,#0x24]
;;;803    					goto error;
000544  e092              B        |L1.1644|
                  |L1.1350|
;;;804    				} else {
;;;805    					goto retry;
000546  e7cc              B        |L1.1250|
                  |L1.1352|
;;;806    				}
;;;807    			}
;;;808    
;;;809    			/* Send a number of data bytes ---------------------------------------- */
;;;810    			while (TransferCfg->tx_count < TransferCfg->tx_length)
000548  e018              B        |L1.1404|
                  |L1.1354|
;;;811    			{
;;;812    				CodeStatus = I2C_SendByte(I2Cx, *txdat);
00054a  f8981000          LDRB     r1,[r8,#0]
00054e  4630              MOV      r0,r6
000550  f7fffffe          BL       I2C_SendByte
000554  4605              MOV      r5,r0
;;;813    				if (CodeStatus != I2C_I2STAT_M_TX_DAT_ACK){
000556  2d28              CMP      r5,#0x28
000558  d00b              BEQ      |L1.1394|
;;;814    					TransferCfg->retransmissions_count++;
00055a  6a20              LDR      r0,[r4,#0x20]
00055c  1c40              ADDS     r0,r0,#1
00055e  6220              STR      r0,[r4,#0x20]
;;;815    					if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
000560  e9d41007          LDRD     r1,r0,[r4,#0x1c]
000564  4288              CMP      r0,r1
000566  d903              BLS      |L1.1392|
;;;816    						// save status
;;;817    						TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
000568  f4457000          ORR      r0,r5,#0x200
00056c  6260              STR      r0,[r4,#0x24]
;;;818    						goto error;
00056e  e07d              B        |L1.1644|
                  |L1.1392|
;;;819    					} else {
;;;820    						goto retry;
000570  e7b7              B        |L1.1250|
                  |L1.1394|
;;;821    					}
;;;822    				}
;;;823    
;;;824    				txdat++;
000572  f1080801          ADD      r8,r8,#1
;;;825    				TransferCfg->tx_count++;
000576  68e0              LDR      r0,[r4,#0xc]
000578  1c40              ADDS     r0,r0,#1
00057a  60e0              STR      r0,[r4,#0xc]
                  |L1.1404|
00057c  e9d41002          LDRD     r1,r0,[r4,#8]         ;810
000580  4288              CMP      r0,r1                 ;810
000582  d3e2              BCC      |L1.1354|
                  |L1.1412|
;;;826    			}
;;;827    		}
;;;828    
;;;829    		/* Second Start condition (Repeat Start) ------------------------------------------- */
;;;830    		if ((TransferCfg->tx_length != 0) && (TransferCfg->tx_data != NULL) \
000584  68a0              LDR      r0,[r4,#8]
000586  b1b8              CBZ      r0,|L1.1464|
000588  6860              LDR      r0,[r4,#4]
00058a  b1a8              CBZ      r0,|L1.1464|
;;;831    				&& (TransferCfg->rx_length != 0) && (TransferCfg->rx_data != NULL)){
00058c  6960              LDR      r0,[r4,#0x14]
00058e  b198              CBZ      r0,|L1.1464|
000590  6920              LDR      r0,[r4,#0x10]
000592  b188              CBZ      r0,|L1.1464|
;;;832    
;;;833    			CodeStatus = I2C_Start(I2Cx);
000594  4630              MOV      r0,r6
000596  f7fffffe          BL       I2C_Start
00059a  4605              MOV      r5,r0
;;;834    			if ((CodeStatus != I2C_I2STAT_M_RX_START) \
00059c  2d08              CMP      r5,#8
00059e  d00b              BEQ      |L1.1464|
;;;835    					&& (CodeStatus != I2C_I2STAT_M_RX_RESTART)){
0005a0  2d10              CMP      r5,#0x10
0005a2  d009              BEQ      |L1.1464|
;;;836    				TransferCfg->retransmissions_count++;
0005a4  6a20              LDR      r0,[r4,#0x20]
0005a6  1c40              ADDS     r0,r0,#1
0005a8  6220              STR      r0,[r4,#0x20]
;;;837    				if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
0005aa  e9d41007          LDRD     r1,r0,[r4,#0x1c]
0005ae  4288              CMP      r0,r1
0005b0  d901              BLS      |L1.1462|
;;;838    					// Update status
;;;839    					TransferCfg->status = CodeStatus;
0005b2  6265              STR      r5,[r4,#0x24]
;;;840    					goto error;
0005b4  e05a              B        |L1.1644|
                  |L1.1462|
;;;841    				} else {
;;;842    					goto retry;
0005b6  e794              B        |L1.1250|
                  |L1.1464|
;;;843    				}
;;;844    			}
;;;845    		}
;;;846    
;;;847    		/* Then, start reading after sending data -------------------------------------- */
;;;848    		if ((TransferCfg->rx_length != 0) && (TransferCfg->rx_data != NULL)){
0005b8  6960              LDR      r0,[r4,#0x14]
0005ba  2800              CMP      r0,#0
0005bc  d050              BEQ      |L1.1632|
0005be  6920              LDR      r0,[r4,#0x10]
0005c0  2800              CMP      r0,#0
0005c2  d04d              BEQ      |L1.1632|
;;;849    			/* Send slave address + RD direction bit = 1 ----------------------------------- */
;;;850    
;;;851    			CodeStatus = I2C_SendByte(I2Cx, ((TransferCfg->sl_addr7bit << 1) | 0x01));
0005c4  7820              LDRB     r0,[r4,#0]
0005c6  2201              MOVS     r2,#1
0005c8  eb020040          ADD      r0,r2,r0,LSL #1
0005cc  b2c1              UXTB     r1,r0
0005ce  4630              MOV      r0,r6
0005d0  f7fffffe          BL       I2C_SendByte
0005d4  4605              MOV      r5,r0
;;;852    			if (CodeStatus != I2C_I2STAT_M_RX_SLAR_ACK){
0005d6  2d40              CMP      r5,#0x40
0005d8  d00d              BEQ      |L1.1526|
;;;853    				TransferCfg->retransmissions_count++;
0005da  e000              B        |L1.1502|
                  |L1.1500|
0005dc  e04b              B        |L1.1654|
                  |L1.1502|
0005de  6a20              LDR      r0,[r4,#0x20]
0005e0  1c40              ADDS     r0,r0,#1
0005e2  6220              STR      r0,[r4,#0x20]
;;;854    				if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
0005e4  e9d41007          LDRD     r1,r0,[r4,#0x1c]
0005e8  4288              CMP      r0,r1
0005ea  d903              BLS      |L1.1524|
;;;855    					// update status
;;;856    					TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_NOACKF;
0005ec  f4457000          ORR      r0,r5,#0x200
0005f0  6260              STR      r0,[r4,#0x24]
;;;857    					goto error;
0005f2  e03b              B        |L1.1644|
                  |L1.1524|
;;;858    				} else {
;;;859    					goto retry;
0005f4  e775              B        |L1.1250|
                  |L1.1526|
;;;860    				}
;;;861    			}
;;;862    
;;;863    			/* Receive a number of data bytes ------------------------------------------------- */
;;;864    			while (TransferCfg->rx_count < TransferCfg->rx_length){
0005f6  e02f              B        |L1.1624|
                  |L1.1528|
;;;865    
;;;866    				/*
;;;867    				 * Note that: if data length is only one, the master should not
;;;868    				 * issue an ACK signal on bus after reading to avoid of next data frame
;;;869    				 * on slave side
;;;870    				 */
;;;871    				if (TransferCfg->rx_count < (TransferCfg->rx_length - 1)){
0005f8  e9d40105          LDRD     r0,r1,[r4,#0x14]
0005fc  1e40              SUBS     r0,r0,#1
0005fe  4281              CMP      r1,r0
000600  d211              BCS      |L1.1574|
;;;872    					// Issue an ACK signal for next data frame
;;;873    					CodeStatus = I2C_GetByte(I2Cx, &tmp, TRUE);
000602  2201              MOVS     r2,#1
000604  4669              MOV      r1,sp
000606  4630              MOV      r0,r6
000608  f7fffffe          BL       I2C_GetByte
00060c  4605              MOV      r5,r0
;;;874    					if (CodeStatus != I2C_I2STAT_M_RX_DAT_ACK){
00060e  2d50              CMP      r5,#0x50
000610  d01b              BEQ      |L1.1610|
;;;875    						TransferCfg->retransmissions_count++;
000612  6a20              LDR      r0,[r4,#0x20]
000614  1c40              ADDS     r0,r0,#1
000616  6220              STR      r0,[r4,#0x20]
;;;876    						if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
000618  e9d41007          LDRD     r1,r0,[r4,#0x1c]
00061c  4288              CMP      r0,r1
00061e  d901              BLS      |L1.1572|
;;;877    							// update status
;;;878    							TransferCfg->status = CodeStatus;
000620  6265              STR      r5,[r4,#0x24]
;;;879    							goto error;
000622  e023              B        |L1.1644|
                  |L1.1572|
;;;880    						} else {
;;;881    							goto retry;
000624  e75d              B        |L1.1250|
                  |L1.1574|
;;;882    						}
;;;883    					}
;;;884    				} else {
;;;885    					// Do not issue an ACK signal
;;;886    					CodeStatus = I2C_GetByte(I2Cx, &tmp, FALSE);
000626  2200              MOVS     r2,#0
000628  4669              MOV      r1,sp
00062a  4630              MOV      r0,r6
00062c  f7fffffe          BL       I2C_GetByte
000630  4605              MOV      r5,r0
;;;887    					if (CodeStatus != I2C_I2STAT_M_RX_DAT_NACK){
000632  2d58              CMP      r5,#0x58
000634  d009              BEQ      |L1.1610|
;;;888    						TransferCfg->retransmissions_count++;
000636  6a20              LDR      r0,[r4,#0x20]
000638  1c40              ADDS     r0,r0,#1
00063a  6220              STR      r0,[r4,#0x20]
;;;889    						if (TransferCfg->retransmissions_count > TransferCfg->retransmissions_max){
00063c  e9d41007          LDRD     r1,r0,[r4,#0x1c]
000640  4288              CMP      r0,r1
000642  d901              BLS      |L1.1608|
;;;890    							// update status
;;;891    							TransferCfg->status = CodeStatus;
000644  6265              STR      r5,[r4,#0x24]
;;;892    							goto error;
000646  e011              B        |L1.1644|
                  |L1.1608|
;;;893    						} else {
;;;894    							goto retry;
000648  e74b              B        |L1.1250|
                  |L1.1610|
;;;895    						}
;;;896    					}
;;;897    				}
;;;898    				*rxdat++ = tmp;
00064a  f89d0000          LDRB     r0,[sp,#0]
00064e  f8090b01          STRB     r0,[r9],#1
;;;899    				TransferCfg->rx_count++;
000652  69a0              LDR      r0,[r4,#0x18]
000654  1c40              ADDS     r0,r0,#1
000656  61a0              STR      r0,[r4,#0x18]
                  |L1.1624|
000658  e9d41005          LDRD     r1,r0,[r4,#0x14]      ;864
00065c  4288              CMP      r0,r1                 ;864
00065e  d3cb              BCC      |L1.1528|
                  |L1.1632|
;;;900    			}
;;;901    		}
;;;902    
;;;903    		/* Send STOP condition ------------------------------------------------- */
;;;904    		I2C_Stop(I2Cx);
000660  4630              MOV      r0,r6
000662  f7fffffe          BL       I2C_Stop
;;;905    		return SUCCESS;
000666  2001              MOVS     r0,#1
                  |L1.1640|
;;;906    
;;;907    error:
;;;908    		// Send stop condition
;;;909    		I2C_Stop(I2Cx);
;;;910    		return ERROR;
;;;911    	}
;;;912    
;;;913    	else if (Opt == I2C_TRANSFER_INTERRUPT){
;;;914    
;;;915    		// Setup tx_rx data, callback and interrupt handler
;;;916    		tmp = I2C_getNum(I2Cx);
;;;917    		i2cdat[tmp].txrx_setup = (uint32_t) TransferCfg;
;;;918    		// Set direction phase, write first
;;;919    		i2cdat[tmp].dir = 0;
;;;920    
;;;921    		/* First Start condition -------------------------------------------------------------- */
;;;922    		I2Cx->CONCLR = I2C_I2CONCLR_SIC;
;;;923    		I2Cx->CONSET = I2C_I2CONSET_STA;
;;;924    		I2C_IntCmd(I2Cx, TRUE);
;;;925    
;;;926    		while(I2C_MasterComplete[tmp] != TRUE);
;;;927    		I2C_MasterComplete[tmp] = FALSE;
;;;928    
;;;929    		return (SUCCESS);
;;;930    	}
;;;931    
;;;932    	return ERROR;
;;;933    }
000668  e8bd83f8          POP      {r3-r9,pc}
                  |L1.1644|
00066c  4630              MOV      r0,r6                 ;909
00066e  f7fffffe          BL       I2C_Stop
000672  2000              MOVS     r0,#0                 ;910
000674  e7f8              B        |L1.1640|
                  |L1.1654|
000676  2f01              CMP      r7,#1                 ;913
000678  d128              BNE      |L1.1740|
00067a  4630              MOV      r0,r6                 ;916
00067c  f7fffffe          BL       I2C_getNum
000680  b2c0              UXTB     r0,r0                 ;916
000682  9000              STR      r0,[sp,#0]            ;916
000684  4884              LDR      r0,|L1.2200|
000686  f89d1000          LDRB     r1,[sp,#0]            ;917
00068a  f8404031          STR      r4,[r0,r1,LSL #3]     ;917
00068e  2000              MOVS     r0,#0                 ;919
000690  4981              LDR      r1,|L1.2200|
000692  f89d2000          LDRB     r2,[sp,#0]            ;919
000696  eb0101c2          ADD      r1,r1,r2,LSL #3       ;919
00069a  6048              STR      r0,[r1,#4]            ;919
00069c  2008              MOVS     r0,#8                 ;922
00069e  61b0              STR      r0,[r6,#0x18]         ;922
0006a0  2020              MOVS     r0,#0x20              ;923
0006a2  6030              STR      r0,[r6,#0]            ;923
0006a4  2101              MOVS     r1,#1                 ;924
0006a6  4630              MOV      r0,r6                 ;924
0006a8  f7fffffe          BL       I2C_IntCmd
0006ac  bf00              NOP                            ;926
                  |L1.1710|
0006ae  487b              LDR      r0,|L1.2204|
0006b0  f89d1000          LDRB     r1,[sp,#0]            ;926
0006b4  f8500021          LDR      r0,[r0,r1,LSL #2]     ;926
0006b8  2801              CMP      r0,#1                 ;926
0006ba  d1f8              BNE      |L1.1710|
0006bc  2000              MOVS     r0,#0                 ;927
0006be  4977              LDR      r1,|L1.2204|
0006c0  f89d2000          LDRB     r2,[sp,#0]            ;927
0006c4  f8410022          STR      r0,[r1,r2,LSL #2]     ;927
0006c8  2001              MOVS     r0,#1                 ;929
0006ca  e7cd              B        |L1.1640|
                  |L1.1740|
0006cc  2000              MOVS     r0,#0                 ;932
0006ce  e7cb              B        |L1.1640|
;;;934    
                          ENDP

                  I2C_SlaveTransferData PROC
;;;967     **********************************************************************/
;;;968    Status I2C_SlaveTransferData(LPC_I2Cn_Type *I2Cx, I2C_S_SETUP_Type *TransferCfg, \
0006d0  e92d4ff8          PUSH     {r3-r11,lr}
;;;969    								I2C_TRANSFER_OPT_Type Opt)
;;;970    {
0006d4  4604              MOV      r4,r0
0006d6  460d              MOV      r5,r1
0006d8  4616              MOV      r6,r2
;;;971    	uint8_t *txdat;
;;;972    	uint8_t *rxdat;
;;;973    	uint32_t CodeStatus;
;;;974    	uint32_t timeout;
;;;975    	int32_t time_en;
;;;976    	int32_t tmp;
;;;977    
;;;978    	// reset all default state
;;;979    	txdat = (uint8_t *) TransferCfg->tx_data;
0006da  f8d59000          LDR      r9,[r5,#0]
;;;980    	rxdat = (uint8_t *) TransferCfg->rx_data;
0006de  f8d5a00c          LDR      r10,[r5,#0xc]
;;;981    	// Reset I2C setup value to default state
;;;982    	TransferCfg->tx_count = 0;
0006e2  2000              MOVS     r0,#0
0006e4  60a8              STR      r0,[r5,#8]
;;;983    	TransferCfg->rx_count = 0;
0006e6  6168              STR      r0,[r5,#0x14]
;;;984    	TransferCfg->status = 0;
0006e8  61a8              STR      r0,[r5,#0x18]
;;;985    
;;;986    
;;;987    	// Polling option
;;;988    	if (Opt == I2C_TRANSFER_POLLING){
0006ea  2e00              CMP      r6,#0
0006ec  d175              BNE      |L1.2010|
;;;989    
;;;990    		/* Set AA bit to ACK command on I2C bus */
;;;991    		I2Cx->CONSET = I2C_I2CONSET_AA;
0006ee  2004              MOVS     r0,#4
0006f0  6020              STR      r0,[r4,#0]
;;;992    		/* Clear SI bit to be ready ... */
;;;993    		I2Cx->CONCLR = (I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC);
0006f2  2028              MOVS     r0,#0x28
0006f4  61a0              STR      r0,[r4,#0x18]
;;;994    
;;;995    		time_en = 0;
0006f6  2000              MOVS     r0,#0
0006f8  9000              STR      r0,[sp,#0]
;;;996    		timeout = 0;
0006fa  4683              MOV      r11,r0
;;;997    
;;;998    		while (1)
0006fc  e06e              B        |L1.2012|
                  |L1.1790|
;;;999    		{
;;;1000   			/* Check SI flag ready */
;;;1001   			if (I2Cx->CONSET & I2C_I2CONSET_SI)
0006fe  6820              LDR      r0,[r4,#0]
000700  f0000008          AND      r0,r0,#8
000704  2800              CMP      r0,#0
000706  d05f              BEQ      |L1.1992|
;;;1002   			{
;;;1003   				time_en = 0;
000708  2000              MOVS     r0,#0
00070a  9000              STR      r0,[sp,#0]
;;;1004   
;;;1005   				switch (CodeStatus = (I2Cx->STAT & I2C_STAT_CODE_BITMASK))
00070c  6860              LDR      r0,[r4,#4]
00070e  f00007f8          AND      r7,r0,#0xf8
000712  f0070007          AND      r0,r7,#7
000716  2800              CMP      r0,#0
000718  d152              BNE      |L1.1984|
00071a  10f8              ASRS     r0,r7,#3
00071c  380c              SUBS     r0,r0,#0xc
00071e  2814              CMP      r0,#0x14
000720  d24e              BCS      |L1.1984|
000722  e8dff000          TBB      [pc,r0]
000726  0f4d              DCB      0x0f,0x4d
000728  104d1527          DCB      0x10,0x4d,0x15,0x27
00072c  16282b32          DCB      0x16,0x28,0x2b,0x32
000730  4d33444d          DCB      0x4d,0x33,0x44,0x4d
000734  4d4d4d4d          DCB      0x4d,0x4d,0x4d,0x4d
000738  4d0a              DCB      0x4d,0x0a
;;;1006   				{
;;;1007   
;;;1008   				/* No status information */
;;;1009   				case I2C_I2STAT_NO_INF:
;;;1010   					I2Cx->CONSET = I2C_I2CONSET_AA;
00073a  2004              MOVS     r0,#4
00073c  6020              STR      r0,[r4,#0]
;;;1011   					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
00073e  2008              MOVS     r0,#8
000740  61a0              STR      r0,[r4,#0x18]
;;;1012   					break;
000742  e040              B        |L1.1990|
;;;1013   
;;;1014   				/* Reading phase -------------------------------------------------------- */
;;;1015   				/* Own SLA+R has been received, ACK has been returned */
;;;1016   				case I2C_I2STAT_S_RX_SLAW_ACK:
;;;1017   				/* General call address has been received, ACK has been returned */
;;;1018   				case I2C_I2STAT_S_RX_GENCALL_ACK:
000744  bf00              NOP      
;;;1019   					I2Cx->CONSET = I2C_I2CONSET_AA;
000746  2004              MOVS     r0,#4
000748  6020              STR      r0,[r4,#0]
;;;1020   					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
00074a  2008              MOVS     r0,#8
00074c  61a0              STR      r0,[r4,#0x18]
;;;1021   					break;
00074e  e03a              B        |L1.1990|
;;;1022   
;;;1023   				/* Previously addressed with own SLA;
;;;1024   				 * DATA byte has been received;
;;;1025   				 * ACK has been returned */
;;;1026   				case I2C_I2STAT_S_RX_PRE_SLA_DAT_ACK:
;;;1027   				/* DATA has been received, ACK hasn been return */
;;;1028   				case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_ACK:
000750  bf00              NOP      
;;;1029   					/*
;;;1030   					 * All data bytes that over-flow the specified receive
;;;1031   					 * data length, just ignore them.
;;;1032   					 */
;;;1033   					if ((TransferCfg->rx_count < TransferCfg->rx_length) \
000752  e9d51004          LDRD     r1,r0,[r5,#0x10]
000756  4288              CMP      r0,r1
000758  d207              BCS      |L1.1898|
;;;1034   							&& (TransferCfg->rx_data != NULL)){
00075a  68e8              LDR      r0,[r5,#0xc]
00075c  b128              CBZ      r0,|L1.1898|
;;;1035   						*rxdat++ = (uint8_t)I2Cx->DAT;
00075e  68a0              LDR      r0,[r4,#8]
000760  f80a0b01          STRB     r0,[r10],#1
;;;1036   						TransferCfg->rx_count++;
000764  6968              LDR      r0,[r5,#0x14]
000766  1c40              ADDS     r0,r0,#1
000768  6168              STR      r0,[r5,#0x14]
                  |L1.1898|
;;;1037   					}
;;;1038   					I2Cx->CONSET = I2C_I2CONSET_AA;
00076a  2004              MOVS     r0,#4
00076c  6020              STR      r0,[r4,#0]
;;;1039   					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
00076e  2008              MOVS     r0,#8
000770  61a0              STR      r0,[r4,#0x18]
;;;1040   					break;
000772  e028              B        |L1.1990|
;;;1041   
;;;1042   				/* Previously addressed with own SLA;
;;;1043   				 * DATA byte has been received;
;;;1044   				 * NOT ACK has been returned */
;;;1045   				case I2C_I2STAT_S_RX_PRE_SLA_DAT_NACK:
;;;1046   				/* DATA has been received, NOT ACK has been returned */
;;;1047   				case I2C_I2STAT_S_RX_PRE_GENCALL_DAT_NACK:
000774  bf00              NOP      
;;;1048   					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
000776  2008              MOVS     r0,#8
000778  61a0              STR      r0,[r4,#0x18]
;;;1049   					break;
00077a  e024              B        |L1.1990|
;;;1050   
;;;1051   				/*
;;;1052   				 * Note that: Return code only let us know a stop condition mixed
;;;1053   				 * with a repeat start condition in the same code value.
;;;1054   				 * So we should provide a time-out. In case this is really a stop
;;;1055   				 * condition, this will return back after time out condition. Otherwise,
;;;1056   				 * next session that is slave receive data will be completed.
;;;1057   				 */
;;;1058   
;;;1059   				/* A Stop or a repeat start condition */
;;;1060   				case I2C_I2STAT_S_RX_STA_STO_SLVREC_SLVTRX:
;;;1061   					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
00077c  2008              MOVS     r0,#8
00077e  61a0              STR      r0,[r4,#0x18]
;;;1062   					// enable time out
;;;1063   					time_en = 1;
000780  2001              MOVS     r0,#1
000782  9000              STR      r0,[sp,#0]
;;;1064   					timeout = 0;
000784  f04f0b00          MOV      r11,#0
;;;1065   					break;
000788  e01d              B        |L1.1990|
;;;1066   
;;;1067   				/* Writing phase -------------------------------------------------------- */
;;;1068   				/* Own SLA+R has been received, ACK has been returned */
;;;1069   				case I2C_I2STAT_S_TX_SLAR_ACK:
;;;1070   				/* Data has been transmitted, ACK has been received */
;;;1071   				case I2C_I2STAT_S_TX_DAT_ACK:
00078a  bf00              NOP      
;;;1072   					/*
;;;1073   					 * All data bytes that over-flow the specified receive
;;;1074   					 * data length, just ignore them.
;;;1075   					 */
;;;1076   					if ((TransferCfg->tx_count < TransferCfg->tx_length) \
00078c  e9d51001          LDRD     r1,r0,[r5,#4]
000790  4288              CMP      r0,r1
000792  d207              BCS      |L1.1956|
;;;1077   							&& (TransferCfg->tx_data != NULL)){
000794  6828              LDR      r0,[r5,#0]
000796  b128              CBZ      r0,|L1.1956|
;;;1078   						I2Cx->DAT = *txdat++;
000798  f8190b01          LDRB     r0,[r9],#1
00079c  60a0              STR      r0,[r4,#8]
;;;1079   						TransferCfg->tx_count++;
00079e  68a8              LDR      r0,[r5,#8]
0007a0  1c40              ADDS     r0,r0,#1
0007a2  60a8              STR      r0,[r5,#8]
                  |L1.1956|
;;;1080   					}
;;;1081   					I2Cx->CONSET = I2C_I2CONSET_AA;
0007a4  2004              MOVS     r0,#4
0007a6  6020              STR      r0,[r4,#0]
;;;1082   					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
0007a8  2008              MOVS     r0,#8
0007aa  61a0              STR      r0,[r4,#0x18]
;;;1083   					break;
0007ac  e00b              B        |L1.1990|
;;;1084   
;;;1085   				/* Data has been transmitted, NACK has been received,
;;;1086   				 * that means there's no more data to send, exit now */
;;;1087   				/*
;;;1088   				 * Note: Don't wait for stop event since in slave transmit mode,
;;;1089   				 * since there no proof lets us know when a stop signal has been received
;;;1090   				 * on slave side.
;;;1091   				 */
;;;1092   				case I2C_I2STAT_S_TX_DAT_NACK:
;;;1093   					I2Cx->CONSET = I2C_I2CONSET_AA;
0007ae  2004              MOVS     r0,#4
0007b0  6020              STR      r0,[r4,#0]
;;;1094   					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
0007b2  2008              MOVS     r0,#8
0007b4  61a0              STR      r0,[r4,#0x18]
;;;1095   					// enable time out
;;;1096   					time_en = 1;
0007b6  2001              MOVS     r0,#1
0007b8  9000              STR      r0,[sp,#0]
;;;1097   					timeout = 0;
0007ba  f04f0b00          MOV      r11,#0
;;;1098   					break;
0007be  e002              B        |L1.1990|
                  |L1.1984|
;;;1099   
;;;1100   				// Other status must be captured
;;;1101   				default:
;;;1102   					I2Cx->CONCLR = I2C_I2CONCLR_SIC;
0007c0  2008              MOVS     r0,#8
0007c2  61a0              STR      r0,[r4,#0x18]
;;;1103   					goto s_error;
0007c4  e013              B        |L1.2030|
                  |L1.1990|
0007c6  e009              B        |L1.2012|
                  |L1.1992|
;;;1104   				}
;;;1105   			} else if (time_en){
0007c8  9800              LDR      r0,[sp,#0]
0007ca  b138              CBZ      r0,|L1.2012|
;;;1106   				if (timeout++ > I2C_SLAVE_TIME_OUT){
0007cc  4658              MOV      r0,r11
0007ce  f10b0b01          ADD      r11,r11,#1
0007d2  f5b03f80          CMP      r0,#0x10000
0007d6  d901              BLS      |L1.2012|
;;;1107   					// it's really a stop condition, goto end stage
;;;1108   					goto s_end_stage;
0007d8  e001              B        |L1.2014|
                  |L1.2010|
0007da  e00d              B        |L1.2040|
                  |L1.2012|
0007dc  e78f              B        |L1.1790|
                  |L1.2014|
;;;1109   				}
;;;1110   			}
;;;1111   		}
;;;1112   
;;;1113   s_end_stage:
;;;1114   		/* Clear AA bit to disable ACK on I2C bus */
;;;1115   		I2Cx->CONCLR = I2C_I2CONCLR_AAC;
0007de  2004              MOVS     r0,#4
0007e0  61a0              STR      r0,[r4,#0x18]
;;;1116   		// Check if there's no error during operation
;;;1117   		// Update status
;;;1118   		TransferCfg->status = CodeStatus | I2C_SETUP_STATUS_DONE;
0007e2  f4476080          ORR      r0,r7,#0x400
0007e6  61a8              STR      r0,[r5,#0x18]
;;;1119   		return SUCCESS;
0007e8  2001              MOVS     r0,#1
                  |L1.2026|
;;;1120   
;;;1121   s_error:
;;;1122   		/* Clear AA bit to disable ACK on I2C bus */
;;;1123   		I2Cx->CONCLR = I2C_I2CONCLR_AAC;
;;;1124   		// Update status
;;;1125   		TransferCfg->status = CodeStatus;
;;;1126   		return ERROR;
;;;1127   	}
;;;1128   
;;;1129   	else if (Opt == I2C_TRANSFER_INTERRUPT){
;;;1130   		// Setup tx_rx data, callback and interrupt handler
;;;1131   		tmp = I2C_getNum(I2Cx);
;;;1132   		i2cdat[tmp].txrx_setup = (uint32_t) TransferCfg;
;;;1133   		// Set direction phase, read first
;;;1134   		i2cdat[tmp].dir = 1;
;;;1135   
;;;1136   		// Enable AA
;;;1137   		I2Cx->CONSET = I2C_I2CONSET_AA;
;;;1138   		I2Cx->CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
;;;1139   		I2C_IntCmd(I2Cx, TRUE);
;;;1140   
;;;1141   		return (SUCCESS);
;;;1142   	}
;;;1143   
;;;1144   	return ERROR;
;;;1145   }
0007ea  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.2030|
0007ee  2004              MOVS     r0,#4                 ;1123
0007f0  61a0              STR      r0,[r4,#0x18]         ;1123
0007f2  61af              STR      r7,[r5,#0x18]         ;1125
0007f4  2000              MOVS     r0,#0                 ;1126
0007f6  e7f8              B        |L1.2026|
                  |L1.2040|
0007f8  2e01              CMP      r6,#1                 ;1129
0007fa  d115              BNE      |L1.2088|
0007fc  4620              MOV      r0,r4                 ;1131
0007fe  f7fffffe          BL       I2C_getNum
000802  4680              MOV      r8,r0                 ;1131
000804  4824              LDR      r0,|L1.2200|
000806  f8405038          STR      r5,[r0,r8,LSL #3]     ;1132
00080a  2001              MOVS     r0,#1                 ;1134
00080c  4922              LDR      r1,|L1.2200|
00080e  eb0101c8          ADD      r1,r1,r8,LSL #3       ;1134
000812  6048              STR      r0,[r1,#4]            ;1134
000814  2004              MOVS     r0,#4                 ;1137
000816  6020              STR      r0,[r4,#0]            ;1137
000818  2028              MOVS     r0,#0x28              ;1138
00081a  61a0              STR      r0,[r4,#0x18]         ;1138
00081c  2101              MOVS     r1,#1                 ;1139
00081e  4620              MOV      r0,r4                 ;1139
000820  f7fffffe          BL       I2C_IntCmd
000824  2001              MOVS     r0,#1                 ;1141
000826  e7e0              B        |L1.2026|
                  |L1.2088|
000828  2000              MOVS     r0,#0                 ;1144
00082a  e7de              B        |L1.2026|
;;;1146   
                          ENDP

                  I2C_SetOwnSlaveAddr PROC
;;;1157    **********************************************************************/
;;;1158   void I2C_SetOwnSlaveAddr(LPC_I2Cn_Type *I2Cx, I2C_OWNSLAVEADDR_CFG_Type *OwnSlaveAddrConfigStruct)
00082c  b510              PUSH     {r4,lr}
;;;1159   {
;;;1160   	uint32_t tmp;
;;;1161   	CHECK_PARAM(PARAM_I2Cx(I2Cx));
;;;1162   	CHECK_PARAM(PARAM_I2C_SLAVEADDR_CH(OwnSlaveAddrConfigStruct->SlaveAddrChannel));
;;;1163   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(OwnSlaveAddrConfigStruct->GeneralCallState));
;;;1164   
;;;1165   	tmp = (((uint32_t)(OwnSlaveAddrConfigStruct->SlaveAddr_7bit << 1)) \
00082e  788b              LDRB     r3,[r1,#2]
000830  2b01              CMP      r3,#1
000832  d100              BNE      |L1.2102|
;;;1166   			| ((OwnSlaveAddrConfigStruct->GeneralCallState == ENABLE) ? 0x01 : 0x00))& I2C_I2ADR_BITMASK;
000834  e000              B        |L1.2104|
                  |L1.2102|
000836  2300              MOVS     r3,#0
                  |L1.2104|
000838  784c              LDRB     r4,[r1,#1]
00083a  ea430344          ORR      r3,r3,r4,LSL #1
00083e  b2da              UXTB     r2,r3
;;;1167   	switch (OwnSlaveAddrConfigStruct->SlaveAddrChannel)
000840  780b              LDRB     r3,[r1,#0]
000842  b133              CBZ      r3,|L1.2130|
000844  2b01              CMP      r3,#1
000846  d00a              BEQ      |L1.2142|
000848  2b02              CMP      r3,#2
00084a  d00e              BEQ      |L1.2154|
00084c  2b03              CMP      r3,#3
00084e  d118              BNE      |L1.2178|
000850  e011              B        |L1.2166|
                  |L1.2130|
;;;1168   	{
;;;1169   	case 0:
;;;1170   		I2Cx->ADR0 = tmp;
000852  60c2              STR      r2,[r0,#0xc]
;;;1171   		I2Cx->MASK[0] = I2C_I2MASK_MASK((uint32_t) \
000854  78cb              LDRB     r3,[r1,#3]
000856  f00303fe          AND      r3,r3,#0xfe
00085a  6303              STR      r3,[r0,#0x30]
;;;1172   				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
;;;1173   		break;
00085c  e011              B        |L1.2178|
                  |L1.2142|
;;;1174   	case 1:
;;;1175   		I2Cx->ADR1 = tmp;
00085e  6202              STR      r2,[r0,#0x20]
;;;1176   		I2Cx->MASK[1] = I2C_I2MASK_MASK((uint32_t) \
000860  78cb              LDRB     r3,[r1,#3]
000862  f00304fe          AND      r4,r3,#0xfe
000866  6344              STR      r4,[r0,#0x34]
;;;1177   				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
;;;1178   		break;
000868  e00b              B        |L1.2178|
                  |L1.2154|
;;;1179   	case 2:
;;;1180   		I2Cx->ADR2 = tmp;
00086a  6242              STR      r2,[r0,#0x24]
;;;1181   		I2Cx->MASK[2] = I2C_I2MASK_MASK((uint32_t) \
00086c  78cb              LDRB     r3,[r1,#3]
00086e  f00304fe          AND      r4,r3,#0xfe
000872  6384              STR      r4,[r0,#0x38]
;;;1182   				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
;;;1183   		break;
000874  e005              B        |L1.2178|
                  |L1.2166|
;;;1184   	case 3:
;;;1185   		I2Cx->ADR3 = tmp;
000876  6282              STR      r2,[r0,#0x28]
;;;1186   		I2Cx->MASK[3] = I2C_I2MASK_MASK((uint32_t) \
000878  78cb              LDRB     r3,[r1,#3]
00087a  f00304fe          AND      r4,r3,#0xfe
00087e  63c4              STR      r4,[r0,#0x3c]
;;;1187   				(OwnSlaveAddrConfigStruct->SlaveAddrMaskValue));
;;;1188   		break;
000880  bf00              NOP      
                  |L1.2178|
000882  bf00              NOP                            ;1173
;;;1189   	}
;;;1190   }
000884  bd10              POP      {r4,pc}
;;;1191   
                          ENDP

                  I2C_MonitorModeConfig PROC
;;;1209    **********************************************************************/
;;;1210   void I2C_MonitorModeConfig(LPC_I2Cn_Type *I2Cx, uint32_t MonitorCfgType, FunctionalState NewState)
000886  b510              PUSH     {r4,lr}
;;;1211   {
;;;1212   	CHECK_PARAM(PARAM_I2Cx(I2Cx));
;;;1213   	CHECK_PARAM(PARAM_I2C_MONITOR_CFG(MonitorCfgType));
;;;1214   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;1215   
;;;1216   	if (NewState == ENABLE)
000888  2a01              CMP      r2,#1
00088a  d109              BNE      |L1.2208|
;;;1217   	{
;;;1218   		I2Cx->MMCTRL |= MonitorCfgType;
00088c  69c3              LDR      r3,[r0,#0x1c]
00088e  430b              ORRS     r3,r3,r1
000890  61c3              STR      r3,[r0,#0x1c]
000892  e00a              B        |L1.2218|
                  |L1.2196|
                          DCD      I2C_SlaveComplete
                  |L1.2200|
                          DCD      i2cdat
                  |L1.2204|
                          DCD      I2C_MasterComplete
                  |L1.2208|
;;;1219   	}
;;;1220   	else
;;;1221   	{
;;;1222   		I2Cx->MMCTRL &= (~MonitorCfgType) & I2C_I2MMCTRL_BITMASK;
0008a0  69c3              LDR      r3,[r0,#0x1c]
0008a2  2407              MOVS     r4,#7
0008a4  438c              BICS     r4,r4,r1
0008a6  4023              ANDS     r3,r3,r4
0008a8  61c3              STR      r3,[r0,#0x1c]
                  |L1.2218|
;;;1223   	}
;;;1224   }
0008aa  bd10              POP      {r4,pc}
;;;1225   
                          ENDP

                  I2C_MonitorModeCmd PROC
;;;1236    **********************************************************************/
;;;1237   void I2C_MonitorModeCmd(LPC_I2Cn_Type *I2Cx, FunctionalState NewState)
0008ac  2901              CMP      r1,#1
;;;1238   {
;;;1239   	CHECK_PARAM(PARAM_I2Cx(I2Cx));
;;;1240   	CHECK_PARAM(PARAM_FUNCTIONALSTATE(NewState));
;;;1241   
;;;1242   	if (NewState == ENABLE)
0008ae  d108              BNE      |L1.2242|
;;;1243   	{
;;;1244   		I2Cx->MMCTRL |= I2C_I2MMCTRL_MM_ENA;
0008b0  69c2              LDR      r2,[r0,#0x1c]
0008b2  f0420201          ORR      r2,r2,#1
0008b6  61c2              STR      r2,[r0,#0x1c]
;;;1245   		I2Cx->CONSET = I2C_I2CONSET_AA;
0008b8  2204              MOVS     r2,#4
0008ba  6002              STR      r2,[r0,#0]
;;;1246   		I2Cx->CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC;
0008bc  2228              MOVS     r2,#0x28
0008be  6182              STR      r2,[r0,#0x18]
0008c0  e005              B        |L1.2254|
                  |L1.2242|
;;;1247   	}
;;;1248   	else
;;;1249   	{
;;;1250   		I2Cx->MMCTRL &= (~I2C_I2MMCTRL_MM_ENA) & I2C_I2MMCTRL_BITMASK;
0008c2  69c2              LDR      r2,[r0,#0x1c]
0008c4  f0020206          AND      r2,r2,#6
0008c8  61c2              STR      r2,[r0,#0x1c]
;;;1251   		I2Cx->CONCLR = I2C_I2CONCLR_SIC | I2C_I2CONCLR_STAC | I2C_I2CONCLR_AAC;
0008ca  222c              MOVS     r2,#0x2c
0008cc  6182              STR      r2,[r0,#0x18]
                  |L1.2254|
;;;1252   	}
;;;1253   	I2C_MonitorBufferIndex = 0;
0008ce  2200              MOVS     r2,#0
0008d0  4b26              LDR      r3,|L1.2412|
0008d2  601a              STR      r2,[r3,#0]  ; I2C_MonitorBufferIndex
;;;1254   }
0008d4  4770              BX       lr
;;;1255   
                          ENDP

                  I2C_MonitorGetDatabuffer PROC
;;;1270    **********************************************************************/
;;;1271   uint8_t I2C_MonitorGetDatabuffer(LPC_I2Cn_Type *I2Cx)
0008d6  4601              MOV      r1,r0
;;;1272   {
;;;1273   	CHECK_PARAM(PARAM_I2Cx(I2Cx));
;;;1274   	return ((uint8_t)(I2Cx->DATA_BUFFER));
0008d8  6ac8              LDR      r0,[r1,#0x2c]
0008da  b2c0              UXTB     r0,r0
;;;1275   }
0008dc  4770              BX       lr
;;;1276   
                          ENDP

                  I2C_MonitorHandler PROC
;;;1291    **********************************************************************/
;;;1292   BOOL_8 I2C_MonitorHandler(LPC_I2Cn_Type *I2Cx, uint8_t *buffer, uint32_t size)
0008de  b530              PUSH     {r4,r5,lr}
;;;1293   {
0008e0  4603              MOV      r3,r0
;;;1294   	BOOL_8 ret=FALSE;
0008e2  2000              MOVS     r0,#0
;;;1295   
;;;1296   	I2Cx->CONCLR = I2C_I2CONCLR_SIC;
0008e4  2408              MOVS     r4,#8
0008e6  619c              STR      r4,[r3,#0x18]
;;;1297   
;;;1298   	buffer[I2C_MonitorBufferIndex] = (uint8_t)(I2Cx->DATA_BUFFER);
0008e8  6adc              LDR      r4,[r3,#0x2c]
0008ea  4d20              LDR      r5,|L1.2412|
0008ec  682d              LDR      r5,[r5,#0]  ; I2C_MonitorBufferIndex
0008ee  554c              STRB     r4,[r1,r5]
;;;1299   	I2C_MonitorBufferIndex++;
0008f0  4c1e              LDR      r4,|L1.2412|
0008f2  6824              LDR      r4,[r4,#0]  ; I2C_MonitorBufferIndex
0008f4  1c64              ADDS     r4,r4,#1
0008f6  4d1d              LDR      r5,|L1.2412|
0008f8  602c              STR      r4,[r5,#0]  ; I2C_MonitorBufferIndex
;;;1300   	if(I2C_MonitorBufferIndex >= size)
0008fa  462c              MOV      r4,r5
0008fc  6824              LDR      r4,[r4,#0]  ; I2C_MonitorBufferIndex
0008fe  4294              CMP      r4,r2
000900  d300              BCC      |L1.2308|
;;;1301   	{
;;;1302   		ret = TRUE;
000902  2001              MOVS     r0,#1
                  |L1.2308|
;;;1303   	}
;;;1304   	return ret;
;;;1305   }
000904  bd30              POP      {r4,r5,pc}
;;;1306   
                          ENDP

                  I2C_MasterTransferComplete PROC
;;;1316    **********************************************************************/
;;;1317   uint32_t I2C_MasterTransferComplete(LPC_I2Cn_Type *I2Cx)
000906  b570              PUSH     {r4-r6,lr}
;;;1318   {
000908  4605              MOV      r5,r0
;;;1319   	uint32_t retval, tmp;
;;;1320   	tmp = I2C_getNum(I2Cx);
00090a  4628              MOV      r0,r5
00090c  f7fffffe          BL       I2C_getNum
000910  4604              MOV      r4,r0
;;;1321   	retval = I2C_MasterComplete[tmp];
000912  4817              LDR      r0,|L1.2416|
000914  f8506024          LDR      r6,[r0,r4,LSL #2]
;;;1322   	I2C_MasterComplete[tmp] = FALSE;
000918  2000              MOVS     r0,#0
00091a  4915              LDR      r1,|L1.2416|
00091c  f8410024          STR      r0,[r1,r4,LSL #2]
;;;1323   	return retval;
000920  4630              MOV      r0,r6
;;;1324   }
000922  bd70              POP      {r4-r6,pc}
;;;1325   
                          ENDP

                  I2C_SlaveTransferComplete PROC
;;;1333    **********************************************************************/
;;;1334   uint32_t I2C_SlaveTransferComplete(LPC_I2Cn_Type *I2Cx)
000924  b570              PUSH     {r4-r6,lr}
;;;1335   {
000926  4605              MOV      r5,r0
;;;1336   	uint32_t retval, tmp;
;;;1337   	tmp = I2C_getNum(I2Cx);
000928  4628              MOV      r0,r5
00092a  f7fffffe          BL       I2C_getNum
00092e  4604              MOV      r4,r0
;;;1338   	retval = I2C_SlaveComplete[tmp];
000930  4810              LDR      r0,|L1.2420|
000932  f8506024          LDR      r6,[r0,r4,LSL #2]
;;;1339   	I2C_SlaveComplete[tmp] = FALSE;
000936  2000              MOVS     r0,#0
000938  490e              LDR      r1,|L1.2420|
00093a  f8410024          STR      r0,[r1,r4,LSL #2]
;;;1340   	return retval;
00093e  4630              MOV      r0,r6
;;;1341   }
000940  bd70              POP      {r4-r6,pc}
;;;1342   
                          ENDP

                  NVIC_EnableIRQ PROC
;;;1085    */
;;;1086   static __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
000942  f000021f          AND      r2,r0,#0x1f
;;;1087   {
;;;1088   /*  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  enable interrupt */
;;;1089     NVIC->ISER[(uint32_t)((int32_t)IRQn) >> 5] = (uint32_t)(1 << ((uint32_t)((int32_t)IRQn) & (uint32_t)0x1F)); /* enable interrupt */
000946  2101              MOVS     r1,#1
000948  4091              LSLS     r1,r1,r2
00094a  0942              LSRS     r2,r0,#5
00094c  0092              LSLS     r2,r2,#2
00094e  f10222e0          ADD      r2,r2,#0xe000e000
000952  f8c21100          STR      r1,[r2,#0x100]
;;;1090   }
000956  4770              BX       lr
;;;1091   
                          ENDP

                  NVIC_DisableIRQ PROC
;;;1099    */
;;;1100   static __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
000958  f000021f          AND      r2,r0,#0x1f
;;;1101   {
;;;1102     NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
00095c  2101              MOVS     r1,#1
00095e  4091              LSLS     r1,r1,r2
000960  4a05              LDR      r2,|L1.2424|
000962  0943              LSRS     r3,r0,#5
000964  f8421023          STR      r1,[r2,r3,LSL #2]
;;;1103   }
000968  4770              BX       lr
;;;1104   
                          ENDP

00096a  0000              DCW      0x0000
                  |L1.2412|
                          DCD      I2C_MonitorBufferIndex
                  |L1.2416|
                          DCD      I2C_MasterComplete
                  |L1.2420|
                          DCD      I2C_SlaveComplete
                  |L1.2424|
                          DCD      0xe000e180

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  i2cdat
                          %        24
                  I2C_MasterComplete
                          %        12
                  I2C_SlaveComplete
                          %        12

                          AREA ||.data||, DATA, ALIGN=2

                  I2C_MonitorBufferIndex
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\libpixy\\lpc43xx_i2c.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_lpc43xx_i2c_c_I2C_Init____REV16|
#line 130 "..\\libpixy\\core_cmInstr.h"
|__asm___13_lpc43xx_i2c_c_I2C_Init____REV16| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_lpc43xx_i2c_c_I2C_Init____REVSH|
#line 144
|__asm___13_lpc43xx_i2c_c_I2C_Init____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

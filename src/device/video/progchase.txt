; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --debug -c --asm --interleave -o.\spifi\progchase.o --asm_dir=.\ --list_dir=.\ --depend=.\spifi\progchase.d --cpu=Cortex-M4 --apcs=interwork -O0 -I. -I..\libpixy -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\spifi\progchase.crf progchase.cpp]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _Z10scaleMotori PROC ; scaleMotor(int)
;;;75     
;;;76     int32_t scaleMotor(int32_t val)
000000  4601              MOV      r1,r0
;;;77     {
;;;78     	int32_t pos = 0;
000002  2000              MOVS     r0,#0
;;;79     
;;;80     	if (val>0)
000004  2900              CMP      r1,#0
000006  dd02              BLE      |L1.14|
;;;81     		pos = val + MOTOR_DEADBAND;
000008  f101001e          ADD      r0,r1,#0x1e
00000c  e003              B        |L1.22|
                  |L1.14|
;;;82     	else if (val<0)
00000e  2900              CMP      r1,#0
000010  da01              BGE      |L1.22|
;;;83     		pos = val - MOTOR_DEADBAND;
000012  f1a1001e          SUB      r0,r1,#0x1e
                  |L1.22|
;;;84     
;;;85     	pos += RCS_CENTER_POS;
000016  f50070fa          ADD      r0,r0,#0x1f4
;;;86     			
;;;87     	if (pos>RCS_MAX_POS) 
00001a  f5b07f7a          CMP      r0,#0x3e8
00001e  dd02              BLE      |L1.38|
;;;88     		pos = RCS_MAX_POS; 
000020  f44f707a          MOV      r0,#0x3e8
000024  e002              B        |L1.44|
                  |L1.38|
;;;89     	else if (pos<RCS_MIN_POS) 
000026  2800              CMP      r0,#0
000028  da00              BGE      |L1.44|
;;;90     		pos = RCS_MIN_POS;
00002a  2000              MOVS     r0,#0
                  |L1.44|
;;;91     
;;;92     	return pos;
;;;93     }
00002c  4770              BX       lr
;;;94     
                          ENDP

                  _Z7axisMapPiS_ PROC ; axisMap(int*, int*)
;;;95     // Map axes!  go from translational/rotational to left/right 
;;;96     void axisMap(int32_t in[], int32_t out[])
00002e  b510              PUSH     {r4,lr}
;;;97     {
;;;98      	out[0] = (in[0] - in[1])/2;
000030  e9d03400          LDRD     r3,r4,[r0,#0]
000034  1b1a              SUBS     r2,r3,r4
000036  eb0273d2          ADD      r3,r2,r2,LSR #31
00003a  105b              ASRS     r3,r3,#1
00003c  600b              STR      r3,[r1,#0]
;;;99     	out[1] = (in[0] + in[1])/2;
00003e  e9d03400          LDRD     r3,r4,[r0,#0]
000042  191a              ADDS     r2,r3,r4
000044  eb0273d2          ADD      r3,r2,r2,LSR #31
000048  105b              ASRS     r3,r3,#1
00004a  604b              STR      r3,[r1,#4]
;;;100    }
00004c  bd10              POP      {r4,pc}
;;;101    
                          ENDP

                  _ZN9MotorLoop6updateEi PROC ; MotorLoop::update(int)
;;;50     // control loop update!
;;;51     int32_t MotorLoop::update(int32_t error)
00004e  b510              PUSH     {r4,lr}
;;;52     {
000050  4602              MOV      r2,r0
;;;53     	int32_t vel;
;;;54     
;;;55     	if (m_prevError!=0x80000000)
000052  6813              LDR      r3,[r2,#0]
000054  f1b34f00          CMP      r3,#0x80000000
000058  d013              BEQ      |L1.130|
;;;56     	{	
;;;57     		vel = (error*m_pgain + (error - m_prevError)*m_dgain)/1000;	// calc proportional-derivative 
00005a  6813              LDR      r3,[r2,#0]
00005c  1acb              SUBS     r3,r1,r3
00005e  6894              LDR      r4,[r2,#8]
000060  4363              MULS     r3,r4,r3
000062  6854              LDR      r4,[r2,#4]
000064  fb013304          MLA      r3,r1,r4,r3
000068  f44f747a          MOV      r4,#0x3e8
00006c  fb93f0f4          SDIV     r0,r3,r4
;;;58     		// saturation
;;;59     		if (vel>MOTOR_MAX) 
000070  f5b07ffa          CMP      r0,#0x1f4
000074  dd01              BLE      |L1.122|
;;;60     			vel = MOTOR_MAX; 
000076  1060              ASRS     r0,r4,#1
000078  e003              B        |L1.130|
                  |L1.122|
;;;61     		else if (vel<MOTOR_MIN) 
00007a  f5107ffa          CMN      r0,#0x1f4
00007e  da00              BGE      |L1.130|
;;;62     			vel = MOTOR_MIN;
000080  4885              LDR      r0,|L1.664|
                  |L1.130|
;;;63     	}
;;;64     	m_prevError = error;
000082  6011              STR      r1,[r2,#0]
;;;65     
;;;66     	return vel;
;;;67     }
000084  bd10              POP      {r4,pc}
;;;68     
                          ENDP

                  _Z7combinejj PROC ; combine(unsigned, unsigned)
;;;102    // calculate left and right wheel commands
;;;103    void combine(uint32_t x, uint32_t y)
000086  b5f0              PUSH     {r4-r7,lr}
;;;104    {
000088  b087              SUB      sp,sp,#0x1c
00008a  4604              MOV      r4,r0
00008c  460d              MOV      r5,r1
;;;105    	int32_t xError, yError, axesIn[2], axesOut[2];
;;;106    
;;;107    	xError = X_CENTER-x;
00008e  f1c406a0          RSB      r6,r4,#0xa0
;;;108    	yError = Y_TRACK-y;
000092  f1c50782          RSB      r7,r5,#0x82
;;;109    	
;;;110    	//cprintf("x: %d y: %d xError: %d yError: %d\n", x, y, xError, yError);
;;;111    
;;;112    	axesIn[0] = g_transLoop.update(yError);
000096  4639              MOV      r1,r7
000098  4880              LDR      r0,|L1.668|
00009a  f7fffffe          BL       _ZN9MotorLoop6updateEi ; MotorLoop::update(int)
00009e  9003              STR      r0,[sp,#0xc]
;;;113    	axesIn[1] = g_rotLoop.update(xError);
0000a0  4631              MOV      r1,r6
0000a2  487f              LDR      r0,|L1.672|
0000a4  f7fffffe          BL       _ZN9MotorLoop6updateEi ; MotorLoop::update(int)
0000a8  9004              STR      r0,[sp,#0x10]
;;;114    
;;;115    	axisMap(axesIn, axesOut);
0000aa  a901              ADD      r1,sp,#4
0000ac  a803              ADD      r0,sp,#0xc
0000ae  f7fffffe          BL       _Z7axisMapPiS_ ; axisMap(int*, int*)
;;;116    
;;;117    	rcs_setPos(LEFT_AXIS, scaleMotor(axesOut[0]));
0000b2  9801              LDR      r0,[sp,#4]
0000b4  f7fffffe          BL       _Z10scaleMotori ; scaleMotor(int)
0000b8  b280              UXTH     r0,r0
0000ba  9005              STR      r0,[sp,#0x14]
0000bc  2000              MOVS     r0,#0
0000be  9006              STR      r0,[sp,#0x18]
0000c0  a905              ADD      r1,sp,#0x14
0000c2  a806              ADD      r0,sp,#0x18
0000c4  f7fffffe          BL       _Z10rcs_setPosRKhRKt ; rcs_setPos(const unsigned char&, const unsigned short&)
;;;118    	rcs_setPos(RIGHT_AXIS, scaleMotor(axesOut[1]));
0000c8  9802              LDR      r0,[sp,#8]
0000ca  f7fffffe          BL       _Z10scaleMotori ; scaleMotor(int)
0000ce  b280              UXTH     r0,r0
0000d0  9005              STR      r0,[sp,#0x14]
0000d2  2001              MOVS     r0,#1
0000d4  9006              STR      r0,[sp,#0x18]
0000d6  a905              ADD      r1,sp,#0x14
0000d8  a806              ADD      r0,sp,#0x18
0000da  f7fffffe          BL       _Z10rcs_setPosRKhRKt ; rcs_setPos(const unsigned char&, const unsigned short&)
;;;119    }	
0000de  b007              ADD      sp,sp,#0x1c
0000e0  bdf0              POP      {r4-r7,pc}
;;;120    
                          ENDP

                  _ZN9MotorLoop8setGainsEii PROC ; MotorLoop::setGains(int, int)
;;;69     
;;;70     void MotorLoop::setGains(int32_t pgain, int32_t dgain)
0000e2  6041              STR      r1,[r0,#4]
;;;71     {
;;;72     	m_pgain = pgain;
;;;73     	m_dgain = dgain;	
0000e4  6082              STR      r2,[r0,#8]
;;;74     }
0000e6  4770              BX       lr
;;;75     
                          ENDP

                  _Z15chaseLoadParamsv PROC ; chaseLoadParams()
;;;140    
;;;141    void chaseLoadParams()
0000e8  b51f              PUSH     {r0-r4,lr}
;;;142    {
;;;143    	prm_add("Translation P gain", 0, 
0000ea  2000              MOVS     r0,#0
0000ec  f44f71fa          MOV      r1,#0x1f4
0000f0  2304              MOVS     r3,#4
0000f2  a26c              ADR      r2,|L1.676|
0000f4  e9cd1000          STRD     r1,r0,[sp,#0]
0000f8  4601              MOV      r1,r0
0000fa  a079              ADR      r0,|L1.736|
0000fc  f7fffffe          BL       _Z7prm_addPKcjS0_z ; prm_add(const char*, unsigned, const char*, ...)
;;;144    		"@c Chase_demo tranlational proportional gain (default 500)", INT32(500), END);
;;;145    	prm_add("Translation D gain", 0, 
000100  2000              MOVS     r0,#0
000102  f44f7148          MOV      r1,#0x320
000106  2304              MOVS     r3,#4
000108  a27a              ADR      r2,|L1.756|
00010a  e9cd1000          STRD     r1,r0,[sp,#0]
00010e  4601              MOV      r1,r0
000110  a087              ADR      r0,|L1.816|
000112  f7fffffe          BL       _Z7prm_addPKcjS0_z ; prm_add(const char*, unsigned, const char*, ...)
;;;146    		"@c Chase_demo translational derivative gain (default 800)", INT32(800), END);
;;;147    	prm_add("Rotation P gain", 0, 
000116  2000              MOVS     r0,#0
000118  f44f71fa          MOV      r1,#0x1f4
00011c  2304              MOVS     r3,#4
00011e  a289              ADR      r2,|L1.836|
000120  e9cd1000          STRD     r1,r0,[sp,#0]
000124  4601              MOV      r1,r0
000126  a096              ADR      r0,|L1.896|
000128  f7fffffe          BL       _Z7prm_addPKcjS0_z ; prm_add(const char*, unsigned, const char*, ...)
;;;148    		"@c Chase_demo rotational proportional gain (default 500)", INT32(500), END);
;;;149    	prm_add("Rotation D gain", 0, 
00012c  2000              MOVS     r0,#0
00012e  f44f7148          MOV      r1,#0x320
000132  2304              MOVS     r3,#4
000134  a296              ADR      r2,|L1.912|
000136  e9cd1000          STRD     r1,r0,[sp,#0]
00013a  4601              MOV      r1,r0
00013c  a0a2              ADR      r0,|L1.968|
00013e  f7fffffe          BL       _Z7prm_addPKcjS0_z ; prm_add(const char*, unsigned, const char*, ...)
;;;150    		"@c Chase_demo rotational derivative gain (default 800)", INT32(800), END);
;;;151    
;;;152    	int32_t pgain, dgain; 
;;;153    
;;;154    	prm_get("Translation P gain", &pgain, END);
000142  2200              MOVS     r2,#0
000144  a903              ADD      r1,sp,#0xc
000146  a066              ADR      r0,|L1.736|
000148  f7fffffe          BL       _Z7prm_getPKcz ; prm_get(const char*, ...)
;;;155    	prm_get("Translation D gain", &dgain, END);
00014c  2200              MOVS     r2,#0
00014e  a902              ADD      r1,sp,#8
000150  a077              ADR      r0,|L1.816|
000152  f7fffffe          BL       _Z7prm_getPKcz ; prm_get(const char*, ...)
;;;156    	g_transLoop.setGains(pgain, dgain);
000156  4851              LDR      r0,|L1.668|
000158  e9dd2102          LDRD     r2,r1,[sp,#8]
00015c  f7fffffe          BL       _ZN9MotorLoop8setGainsEii ; MotorLoop::setGains(int, int)
;;;157    	prm_get("Rotation P gain", &pgain, END);
000160  2200              MOVS     r2,#0
000162  a903              ADD      r1,sp,#0xc
000164  a086              ADR      r0,|L1.896|
000166  f7fffffe          BL       _Z7prm_getPKcz ; prm_get(const char*, ...)
;;;158    	prm_get("Rotation D gain", &dgain, END);
00016a  2200              MOVS     r2,#0
00016c  a902              ADD      r1,sp,#8
00016e  a096              ADR      r0,|L1.968|
000170  f7fffffe          BL       _Z7prm_getPKcz ; prm_get(const char*, ...)
;;;159    	g_rotLoop.setGains(pgain, dgain);
000174  484a              LDR      r0,|L1.672|
000176  e9dd2102          LDRD     r2,r1,[sp,#8]
00017a  f7fffffe          BL       _ZN9MotorLoop8setGainsEii ; MotorLoop::setGains(int, int)
;;;160    }
00017e  bd1f              POP      {r0-r4,pc}
;;;161    
                          ENDP

                  _Z10chaseSetupv PROC ; chaseSetup()
;;;120    
;;;121    int chaseSetup()
000180  b51c              PUSH     {r2-r4,lr}
;;;122    {
;;;123    	// setup camera mode
;;;124    	cam_setMode(CAM_MODE1);
000182  2001              MOVS     r0,#1
000184  9001              STR      r0,[sp,#4]
000186  a801              ADD      r0,sp,#4
000188  f7fffffe          BL       _Z11cam_setModeRKh ; cam_setMode(const unsigned char&)
;;;125    
;;;126     	chaseLoadParams();
00018c  f7fffffe          BL       _Z15chaseLoadParamsv ; chaseLoadParams()
;;;127    	rcs_setPos(LEFT_AXIS, RCS_CENTER_POS);
000190  2000              MOVS     r0,#0
000192  9001              STR      r0,[sp,#4]
000194  f44f70fa          MOV      r0,#0x1f4
000198  9000              STR      r0,[sp,#0]
00019a  4669              MOV      r1,sp
00019c  a801              ADD      r0,sp,#4
00019e  f7fffffe          BL       _Z10rcs_setPosRKhRKt ; rcs_setPos(const unsigned char&, const unsigned short&)
;;;128    	rcs_setPos(RIGHT_AXIS, RCS_CENTER_POS);
0001a2  2001              MOVS     r0,#1
0001a4  9001              STR      r0,[sp,#4]
0001a6  f44f70fa          MOV      r0,#0x1f4
0001aa  9000              STR      r0,[sp,#0]
0001ac  4669              MOV      r1,sp
0001ae  a801              ADD      r0,sp,#4
0001b0  f7fffffe          BL       _Z10rcs_setPosRKhRKt ; rcs_setPos(const unsigned char&, const unsigned short&)
;;;129    	
;;;130    	// load lut if we've grabbed any frames lately
;;;131    	if (g_rawFrame.m_pixels)
0001b4  4888              LDR      r0,|L1.984|
0001b6  6800              LDR      r0,[r0,#0]  ; g_rawFrame
0001b8  b108              CBZ      r0,|L1.446|
;;;132    		cc_loadLut();
0001ba  f7fffffe          BL       _Z10cc_loadLutv ; cc_loadLut()
                  |L1.446|
;;;133    
;;;134    	// setup qqueue and M0
;;;135    	g_qqueue->flush();
0001be  4887              LDR      r0,|L1.988|
0001c0  6800              LDR      r0,[r0,#0]  ; g_qqueue
0001c2  f7fffffe          BL       _ZN6Qqueue5flushEv ; Qqueue::flush()
;;;136    	exec_runM0(0);
0001c6  2000              MOVS     r0,#0
0001c8  f7fffffe          BL       _Z10exec_runM0h ; exec_runM0(unsigned char)
;;;137    
;;;138    	return 0;
0001cc  2000              MOVS     r0,#0
;;;139    }
0001ce  bd1c              POP      {r2-r4,pc}
;;;140    
                          ENDP

                  _Z9chaseLoopv PROC ; chaseLoop()
;;;162    
;;;163    int chaseLoop()
0001d0  b570              PUSH     {r4-r6,lr}
;;;164    {
0001d2  b086              SUB      sp,sp,#0x18
;;;165    	uint16_t x, y;
;;;166    	BlobA *blobs, *blob;
;;;167    	BlobB *ccBlobs;
;;;168    	uint32_t numBlobs, numCCBlobs;
;;;169    
;;;170    
;;;171    	// create blobs
;;;172    	g_blobs->blobify();
0001d4  4882              LDR      r0,|L1.992|
0001d6  6800              LDR      r0,[r0,#0]  ; g_blobs
0001d8  f7fffffe          BL       _ZN5Blobs7blobifyEv ; Blobs::blobify()
;;;173    
;;;174    	blob = (BlobA *)g_blobs->getMaxBlob();
0001dc  2100              MOVS     r1,#0
0001de  4880              LDR      r0,|L1.992|
0001e0  6800              LDR      r0,[r0,#0]  ; g_blobs
0001e2  f7fffffe          BL       _ZN5Blobs10getMaxBlobEt ; Blobs::getMaxBlob(unsigned short)
0001e6  4604              MOV      r4,r0
;;;175    	if (blob)
0001e8  b1a4              CBZ      r4,|L1.532|
;;;176    	{
;;;177    		x = blob->m_left + (blob->m_right - blob->m_left)/2;
0001ea  88a1              LDRH     r1,[r4,#4]
0001ec  8862              LDRH     r2,[r4,#2]
0001ee  1a88              SUBS     r0,r1,r2
0001f0  eb0071d0          ADD      r1,r0,r0,LSR #31
0001f4  eb020161          ADD      r1,r2,r1,ASR #1
0001f8  b28d              UXTH     r5,r1
;;;178    		y = blob->m_top + (blob->m_bottom - blob->m_top)/2;
0001fa  8921              LDRH     r1,[r4,#8]
0001fc  88e2              LDRH     r2,[r4,#6]
0001fe  1a88              SUBS     r0,r1,r2
000200  eb0071d0          ADD      r1,r0,r0,LSR #31
000204  eb020161          ADD      r1,r2,r1,ASR #1
000208  b28e              UXTH     r6,r1
;;;179    
;;;180    		combine(x, y);
00020a  4631              MOV      r1,r6
00020c  4628              MOV      r0,r5
00020e  f7fffffe          BL       _Z7combinejj ; combine(unsigned, unsigned)
000212  e012              B        |L1.570|
                  |L1.532|
;;;181    	}
;;;182    	else
;;;183    	{
;;;184    		rcs_setPos(LEFT_AXIS, RCS_CENTER_POS);
000214  2000              MOVS     r0,#0
000216  9001              STR      r0,[sp,#4]
000218  f44f70fa          MOV      r0,#0x1f4
00021c  9000              STR      r0,[sp,#0]
00021e  4669              MOV      r1,sp
000220  a801              ADD      r0,sp,#4
000222  f7fffffe          BL       _Z10rcs_setPosRKhRKt ; rcs_setPos(const unsigned char&, const unsigned short&)
;;;185    		rcs_setPos(RIGHT_AXIS, RCS_CENTER_POS);
000226  2001              MOVS     r0,#1
000228  9001              STR      r0,[sp,#4]
00022a  f44f70fa          MOV      r0,#0x1f4
00022e  9000              STR      r0,[sp,#0]
000230  4669              MOV      r1,sp
000232  a801              ADD      r0,sp,#4
000234  f7fffffe          BL       _Z10rcs_setPosRKhRKt ; rcs_setPos(const unsigned char&, const unsigned short&)
;;;186    	}
000238  bf00              NOP      
                  |L1.570|
;;;187    
;;;188    
;;;189    	// send blobs
;;;190    	g_blobs->getBlobs(&blobs, &numBlobs, &ccBlobs, &numCCBlobs);
00023a  a802              ADD      r0,sp,#8
00023c  ab04              ADD      r3,sp,#0x10
00023e  aa03              ADD      r2,sp,#0xc
000240  a905              ADD      r1,sp,#0x14
000242  9000              STR      r0,[sp,#0]
000244  4866              LDR      r0,|L1.992|
000246  6800              LDR      r0,[r0,#0]  ; g_blobs
000248  f7fffffe          BL       _ZN5Blobs8getBlobsEPP5BlobAPjPP5BlobBS3_ ; Blobs::getBlobs(BlobA**, unsigned*, BlobB**, unsigned*)
;;;191    	cc_sendBlobs(g_chirpUsb, blobs, numBlobs, ccBlobs, numCCBlobs);
00024c  2001              MOVS     r0,#1
00024e  9902              LDR      r1,[sp,#8]
000250  e9cd1000          STRD     r1,r0,[sp,#0]
000254  4863              LDR      r0,|L1.996|
000256  e9dd2303          LDRD     r2,r3,[sp,#0xc]
00025a  9905              LDR      r1,[sp,#0x14]
00025c  6800              LDR      r0,[r0,#0]  ; g_chirpUsb
00025e  f7fffffe          BL       _Z12cc_sendBlobsP5ChirpPK5BlobAjPK5BlobBjh ; cc_sendBlobs(Chirp*, const BlobA*, unsigned, const BlobB*, unsigned, unsigned char)
;;;192    
;;;193    	cc_setLED();
000262  f7fffffe          BL       _Z9cc_setLEDv ; cc_setLED()
;;;194    	
;;;195    	return 0;
000266  2000              MOVS     r0,#0
;;;196    }
000268  b006              ADD      sp,sp,#0x18
00026a  bd70              POP      {r4-r6,pc}
                          ENDP

                  _ZN9MotorLoopC2Ejj                  ; Alternate entry point ; MotorLoop::MotorLoop__sub_object(unsigned, unsigned)
                  _ZN9MotorLoopC1Ejj PROC ; MotorLoop::MotorLoop(unsigned, unsigned)
;;;42     
;;;43     MotorLoop::MotorLoop(uint32_t pgain, uint32_t dgain)
;;;44     {
;;;45     	m_pgain = pgain;
;;;46     	m_dgain = dgain;
;;;47     	m_prevError = 0x80000000; // to indicate that it's never been set
;;;48     }
;;;49     
00026c  6041              STR      r1,[r0,#4]
00026e  6082              STR      r2,[r0,#8]
000270  f04f4300          MOV      r3,#0x80000000
000274  6003              STR      r3,[r0,#0]
000276  4770              BX       lr
                          ENDP

                  __sti___13_progchase_cpp_bdb05ac4 PROC
000278  b500              PUSH     {lr}                  ;0
00027a  f44f7248          MOV      r2,#0x320             ;0
00027e  f44f71fa          MOV      r1,#0x1f4             ;0
000282  4806              LDR      r0,|L1.668|
000284  f7fffffe          BL       _ZN9MotorLoopC1Ejj ; MotorLoop::MotorLoop(unsigned, unsigned)
000288  f44f7261          MOV      r2,#0x384             ;0
00028c  f44f712f          MOV      r1,#0x2bc             ;0
000290  4803              LDR      r0,|L1.672|
000292  f7fffffe          BL       _ZN9MotorLoopC1Ejj ; MotorLoop::MotorLoop(unsigned, unsigned)
000296  bd00              POP      {pc}                  ;0
                          ENDP

                  |L1.664|
                          DCD      0xfffffe0c
                  |L1.668|
                          DCD      g_transLoop
                  |L1.672|
                          DCD      g_rotLoop
                  |L1.676|
0002a4  40632043          DCB      "@c Chase_demo tranlational proportional gain (default 5"
0002a8  68617365
0002ac  5f64656d
0002b0  6f207472
0002b4  616e6c61
0002b8  74696f6e
0002bc  616c2070
0002c0  726f706f
0002c4  7274696f
0002c8  6e616c20
0002cc  6761696e
0002d0  20286465
0002d4  6661756c
0002d8  742035  
0002db  30302900          DCB      "00)",0
0002df  00                DCB      0
                  |L1.736|
0002e0  5472616e          DCB      "Translation P gain",0
0002e4  736c6174
0002e8  696f6e20
0002ec  50206761
0002f0  696e00  
0002f3  00                DCB      0
                  |L1.756|
0002f4  40632043          DCB      "@c Chase_demo translational derivative gain (default 80"
0002f8  68617365
0002fc  5f64656d
000300  6f207472
000304  616e736c
000308  6174696f
00030c  6e616c20
000310  64657269
000314  76617469
000318  76652067
00031c  61696e20
000320  28646566
000324  61756c74
000328  203830  
00032b  302900            DCB      "0)",0
00032e  00                DCB      0
00032f  00                DCB      0
                  |L1.816|
000330  5472616e          DCB      "Translation D gain",0
000334  736c6174
000338  696f6e20
00033c  44206761
000340  696e00  
000343  00                DCB      0
                  |L1.836|
000344  40632043          DCB      "@c Chase_demo rotational proportional gain (default 500"
000348  68617365
00034c  5f64656d
000350  6f20726f
000354  74617469
000358  6f6e616c
00035c  2070726f
000360  706f7274
000364  696f6e61
000368  6c206761
00036c  696e2028
000370  64656661
000374  756c7420
000378  353030  
00037b  2900              DCB      ")",0
00037d  00                DCB      0
00037e  00                DCB      0
00037f  00                DCB      0
                  |L1.896|
000380  526f7461          DCB      "Rotation P gain",0
000384  74696f6e
000388  20502067
00038c  61696e00
                  |L1.912|
000390  40632043          DCB      "@c Chase_demo rotational derivative gain (default 800)",0
000394  68617365
000398  5f64656d
00039c  6f20726f
0003a0  74617469
0003a4  6f6e616c
0003a8  20646572
0003ac  69766174
0003b0  69766520
0003b4  6761696e
0003b8  20286465
0003bc  6661756c
0003c0  74203830
0003c4  302900  
0003c7  00                DCB      0
                  |L1.968|
0003c8  526f7461          DCB      "Rotation D gain",0
0003cc  74696f6e
0003d0  20442067
0003d4  61696e00
                  |L1.984|
                          DCD      g_rawFrame
                  |L1.988|
                          DCD      g_qqueue
                  |L1.992|
                          DCD      g_blobs
                  |L1.996|
                          DCD      g_chirpUsb

                          AREA ||.ARM.exidx||, LINKORDER=||.text||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||.text||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_transLoop
                          %        12
                  g_rotLoop
                          %        12

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  63686173          DCB      "chase",0
000004  6500    
000006  00                DCB      0
000007  00                DCB      0
000008  63686173          DCB      "chase an object (demo)",0
00000c  6520616e
000010  206f626a
000014  65637420
000018  2864656d
00001c  6f2900  

                          AREA ||.data||, DATA, ALIGN=2

                  g_progChase
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x8
                          DCD      _Z10chaseSetupv ; chaseSetup()
                          DCD      _Z9chaseLoopv ; chaseLoop()

                          AREA ||.init_array||, DATA, READONLY, INIT_ARRAY, ALIGN=2

                          DCD      0x00000000
                          RELOC 38, __sti___13_progchase_cpp_bdb05ac4

;*** Start embedded assembler ***

#line 1 "progchase.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_progchase_cpp_bdb05ac4___Z7__REV16j|
#line 130 "..\\libpixy\\core_cmInstr.h"
|__asm___13_progchase_cpp_bdb05ac4___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_progchase_cpp_bdb05ac4___Z7__REVSHi|
#line 144
|__asm___13_progchase_cpp_bdb05ac4___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\pixy_init.o --asm_dir=.\ --list_dir=.\ --depend=.\pixy_init.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I. -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\pixy_init.crf pixy_init.cpp]
                          THUMB

                          AREA ||i._Z10CameraInitv||, CODE, READONLY, ALIGN=2

                  _Z10CameraInitv PROC ; CameraInit()
;;;84     
;;;85     void CameraInit(void)
000000  b508              PUSH     {r3,lr}
;;;86     {
;;;87     	volatile uint32_t d;
;;;88     
;;;89     	LPC_GPIO_PORT->MASK[0] = 0;
000002  2000              MOVS     r0,#0
000004  4916              LDR      r1,|L1.96|
000006  6008              STR      r0,[r1,#0]
;;;90     	LPC_GPIO_PORT->MASK[1] = 0;
000008  2100              MOVS     r1,#0
00000a  4815              LDR      r0,|L1.96|
00000c  6041              STR      r1,[r0,#4]
;;;91     	LPC_GPIO_PORT->DIR[0] = 0x0007;
00000e  2007              MOVS     r0,#7
000010  4913              LDR      r1,|L1.96|
000012  3980              SUBS     r1,r1,#0x80
000014  6008              STR      r0,[r1,#0]
;;;92     	LPC_GPIO_PORT->DIR[1] = 0x0000;
000016  2100              MOVS     r1,#0
000018  4811              LDR      r0,|L1.96|
00001a  3880              SUBS     r0,r0,#0x80
00001c  6041              STR      r1,[r0,#4]
;;;93     
;;;94     	// deal with pwdn
;;;95     	LPC_GPIO_PORT->PIN[0] = 0;
00001e  2000              MOVS     r0,#0
000020  490f              LDR      r1,|L1.96|
000022  3980              SUBS     r1,r1,#0x80
000024  f8c10100          STR      r0,[r1,#0x100]
;;;96     	LPC_GPIO_PORT->PIN[0] |= 0x0004;
000028  4608              MOV      r0,r1
00002a  f8d00100          LDR      r0,[r0,#0x100]
00002e  f0400004          ORR      r0,r0,#4
000032  f8c10100          STR      r0,[r1,#0x100]
;;;97     	for (d=0; d<10000000; d++);
000036  2000              MOVS     r0,#0
000038  9000              STR      r0,[sp,#0]
00003a  e002              B        |L1.66|
                  |L1.60|
00003c  9800              LDR      r0,[sp,#0]
00003e  1c40              ADDS     r0,r0,#1
000040  9000              STR      r0,[sp,#0]
                  |L1.66|
000042  4908              LDR      r1,|L1.100|
000044  9800              LDR      r0,[sp,#0]
000046  4288              CMP      r0,r1
000048  d3f8              BCC      |L1.60|
;;;98     	LPC_GPIO_PORT->PIN[0] &= ~(0x0004);
00004a  4805              LDR      r0,|L1.96|
00004c  3080              ADDS     r0,r0,#0x80
00004e  6800              LDR      r0,[r0,#0]
000050  f0200004          BIC      r0,r0,#4
000054  4902              LDR      r1,|L1.96|
000056  3980              SUBS     r1,r1,#0x80
000058  f8c10100          STR      r0,[r1,#0x100]
;;;99     
;;;100    }
00005c  bd08              POP      {r3,pc}
;;;101    
                          ENDP

00005e  0000              DCW      0x0000
                  |L1.96|
                          DCD      0x400f6080
                  |L1.100|
                          DCD      0x00989680

                          AREA ||i._Z10commonInitv||, CODE, READONLY, ALIGN=2

                  _Z10commonInitv PROC ; commonInit()
;;;126    
;;;127    void commonInit(void)
000000  b510              PUSH     {r4,lr}
;;;128    {
;;;129    	platformInit();
000002  f7fffffe          BL       platformInit
;;;130    	timerInit();
000006  f7fffffe          BL       _Z9timerInitv ; timerInit()
;;;131    	GPIOInit();
00000a  f7fffffe          BL       _Z8GPIOInitv ; GPIOInit()
;;;132    	USB_UserInit();
00000e  f7fffffe          BL       USB_UserInit
;;;133    
;;;134      	debug_frmwrk_init_clk(CLKFREQ);
000012  4803              LDR      r0,|L2.32|
000014  f7fffffe          BL       debug_frmwrk_init_clk
;;;135    	lpc_printf("M4 start\n");
000018  a002              ADR      r0,|L2.36|
00001a  f7fffffe          BL       lpc_printf
;;;136    }
00001e  bd10              POP      {r4,pc}
;;;137    
                          ENDP

                  |L2.32|
                          DCD      0x0c28cb00
                  |L2.36|
000024  4d342073          DCB      "M4 start\n",0
000028  74617274
00002c  0a00    
00002e  00                DCB      0
00002f  00                DCB      0

                          AREA ||i._Z14pixySimpleInitv||, CODE, READONLY, ALIGN=2

                  _Z14pixySimpleInitv PROC ; pixySimpleInit()
;;;214    
;;;215    void pixySimpleInit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;216    {
;;;217    	commonInit();
000002  f7fffffe          BL       _Z10commonInitv ; commonInit()
;;;218    
;;;219    	USBLink *usbLink = new USBLink;
000006  2010              MOVS     r0,#0x10
000008  f7fffffe          BL       _Znwj ; operator new(unsigned)
00000c  4604              MOV      r4,r0
00000e  f7fffffe          BL       _ZN7USBLinkC1Ev ; USBLink::USBLink()
000012  4604              MOV      r4,r0
000014  4626              MOV      r6,r4
;;;220    	g_chirpUsb = new Chirp(false, false, usbLink);
000016  203c              MOVS     r0,#0x3c
000018  f7fffffe          BL       _Znwj ; operator new(unsigned)
00001c  4605              MOV      r5,r0
00001e  4633              MOV      r3,r6
000020  2200              MOVS     r2,#0
000022  4611              MOV      r1,r2
000024  f7fffffe          BL       _ZN5ChirpC1EbbP4Link ; Chirp::Chirp(bool, bool, Link*)
000028  4605              MOV      r5,r0
00002a  4801              LDR      r0,|L3.48|
00002c  6005              STR      r5,[r0,#0]  ; g_chirpUsb
;;;221    }
00002e  bd70              POP      {r4-r6,pc}
;;;222    
                          ENDP

                  |L3.48|
                          DCD      g_chirpUsb

                          AREA ||i._Z7ADCInitv||, CODE, READONLY, ALIGN=2

                  _Z7ADCInitv PROC ; ADCInit()
;;;28     
;;;29     void ADCInit()
000000  b510              PUSH     {r4,lr}
;;;30     {
;;;31     	ADC_Init(LPC_ADC0, 200000, 10);
000002  220a              MOVS     r2,#0xa
000004  4904              LDR      r1,|L4.24|
000006  4805              LDR      r0,|L4.28|
000008  f7fffffe          BL       ADC_Init
;;;32     	ADC_IntConfig(LPC_ADC0,ADC_ADINTEN1,DISABLE);
00000c  2200              MOVS     r2,#0
00000e  2101              MOVS     r1,#1
000010  4802              LDR      r0,|L4.28|
000012  f7fffffe          BL       ADC_IntConfig
;;;33     }
000016  bd10              POP      {r4,pc}
;;;34     
                          ENDP

                  |L4.24|
                          DCD      0x00030d40
                  |L4.28|
                          DCD      0x400e3000

                          AREA ||i._Z7SCTInitv||, CODE, READONLY, ALIGN=2

                  _Z7SCTInitv PROC ; SCTInit()
;;;34     
;;;35     void SCTInit()
000000  f04f4080          MOV      r0,#0x40000000
;;;36     {
;;;37     	// RC servo
;;;38     	LPC_SCT->CTRL_L |= 1<<2; // set halt 
000004  8880              LDRH     r0,[r0,#4]
000006  f0400004          ORR      r0,r0,#4
00000a  f04f4180          MOV      r1,#0x40000000
00000e  8088              STRH     r0,[r1,#4]
;;;39     	LPC_SCT->CTRL_L &= ~(255<<5); // reset prescaler
000010  4608              MOV      r0,r1
000012  8880              LDRH     r0,[r0,#4]
000014  f42050ff          BIC      r0,r0,#0x1fe0
000018  8088              STRH     r0,[r1,#4]
;;;40     	LPC_SCT->CTRL_L |= 203<<5; // prescale (create a 1 MHz clock)
00001a  4608              MOV      r0,r1
00001c  8880              LDRH     r0,[r0,#4]
00001e  f44050cb          ORR      r0,r0,#0x1960
000022  8088              STRH     r0,[r1,#4]
;;;41     	LPC_SCT->LIMIT_L = 1<<0; // event 0 resets counter
000024  2001              MOVS     r0,#1
000026  8108              STRH     r0,[r1,#8]
;;;42     
;;;43       	LPC_SCT->OUTPUT = 0x0;
000028  2000              MOVS     r0,#0
00002a  6508              STR      r0,[r1,#0x50]
;;;44     	LPC_SCT->CONFIG &= ~0x01; // set UNITY=0, default clk source, bus clock
00002c  4608              MOV      r0,r1
00002e  6800              LDR      r0,[r0,#0]
000030  f0200001          BIC      r0,r0,#1
000034  6008              STR      r0,[r1,#0]
;;;45     
;;;46     	LPC_SCT->MATCH[0].L = 20000; // 4000;
000036  f6446020          MOV      r0,#0x4e20
00003a  4931              LDR      r1,|L5.256|
00003c  8008              STRH     r0,[r1,#0]
;;;47     	LPC_SCT->MATCHREL[0].L = 20000; // 4000;
00003e  0641              LSLS     r1,r0,#25
000040  f8a10200          STRH     r0,[r1,#0x200]
;;;48     	LPC_SCT->EVENT[0].CTRL = 0 | 1<<12;
000044  1489              ASRS     r1,r1,#18
000046  482f              LDR      r0,|L5.260|
000048  6001              STR      r1,[r0,#0]
;;;49     	LPC_SCT->EVENT[1].CTRL = 1 | 1<<12;
00004a  1c49              ADDS     r1,r1,#1
00004c  482d              LDR      r0,|L5.260|
00004e  3008              ADDS     r0,r0,#8
000050  6001              STR      r1,[r0,#0]
;;;50     	LPC_SCT->EVENT[0].STATE = 1<<0; // event 0 is enabled in state 0
000052  2001              MOVS     r0,#1
000054  492b              LDR      r1,|L5.260|
000056  1f09              SUBS     r1,r1,#4
000058  6008              STR      r0,[r1,#0]
;;;51     	LPC_SCT->EVENT[1].STATE = 1<<0; // event 1 is enabled in state 0
00005a  2101              MOVS     r1,#1
00005c  0780              LSLS     r0,r0,#30
00005e  f8c01308          STR      r1,[r0,#0x308]
;;;52     
;;;53     	LPC_SCT->EVENT[2].CTRL = 2 | 1<<12;
000062  f2410102          MOV      r1,#0x1002
000066  f8c01314          STR      r1,[r0,#0x314]
;;;54     	LPC_SCT->EVENT[2].STATE = 1<<0; // event 2 is enabled in state 0
00006a  2101              MOVS     r1,#1
00006c  f8c01310          STR      r1,[r0,#0x310]
;;;55     
;;;56     	// RGB led
;;;57     	LPC_SCT->CTRL_H |= 1<<2; // set halt 
000070  88c0              LDRH     r0,[r0,#6]
000072  f0400104          ORR      r1,r0,#4
000076  f04f4080          MOV      r0,#0x40000000
00007a  80c1              STRH     r1,[r0,#6]
;;;58     	LPC_SCT->CTRL_H &= ~(255<<5); // reset prescaler
00007c  88c0              LDRH     r0,[r0,#6]
00007e  f42051ff          BIC      r1,r0,#0x1fe0
000082  f04f4080          MOV      r0,#0x40000000
000086  80c1              STRH     r1,[r0,#6]
;;;59     	LPC_SCT->CTRL_H |= 9<<5; // prescale (create a 1 MHz clock)
000088  88c0              LDRH     r0,[r0,#6]
00008a  f4407190          ORR      r1,r0,#0x120
00008e  f04f4080          MOV      r0,#0x40000000
000092  80c1              STRH     r1,[r0,#6]
;;;60     	LPC_SCT->LIMIT_H = 1<<3; // event 3 resets counter
000094  2008              MOVS     r0,#8
000096  06c1              LSLS     r1,r0,#27
000098  8148              STRH     r0,[r1,#0xa]
;;;61     
;;;62     	LPC_SCT->MATCH[0].H = 0xffff;
00009a  f64f71ff          MOV      r1,#0xffff
00009e  06c0              LSLS     r0,r0,#27
0000a0  f8a01102          STRH     r1,[r0,#0x102]
;;;63     	LPC_SCT->MATCHREL[0].H = 0xffff;
0000a4  f8a01202          STRH     r1,[r0,#0x202]
;;;64     	LPC_SCT->EVENT[3].CTRL = 0 | 1<<4 | 1<<12;
0000a8  f2410110          MOV      r1,#0x1010
0000ac  f8c0131c          STR      r1,[r0,#0x31c]
;;;65     	LPC_SCT->EVENT[3].STATE = 1<<0; // event 3 is enabled in state 0
0000b0  2101              MOVS     r1,#1
0000b2  f8c01318          STR      r1,[r0,#0x318]
;;;66     
;;;67     	// red
;;;68     	LPC_SCT->EVENT[4].CTRL = 1 | 1<<4 | 1<<12;
0000b6  f2410111          MOV      r1,#0x1011
0000ba  f8c01324          STR      r1,[r0,#0x324]
;;;69     	LPC_SCT->EVENT[4].STATE = 1<<0; // event 4 is enabled in state 0
0000be  2101              MOVS     r1,#1
0000c0  f8c01320          STR      r1,[r0,#0x320]
;;;70     
;;;71     	// green
;;;72     	LPC_SCT->EVENT[5].CTRL = 2 | 1<<4 | 1<<12;
0000c4  f2410112          MOV      r1,#0x1012
0000c8  f8c0132c          STR      r1,[r0,#0x32c]
;;;73     	LPC_SCT->EVENT[5].STATE = 1<<0; // event 5 is enabled in state 0
0000cc  2101              MOVS     r1,#1
0000ce  f8c01328          STR      r1,[r0,#0x328]
;;;74     
;;;75     	// blue
;;;76     	LPC_SCT->EVENT[6].CTRL = 3 | 1<<4 | 1<<12;
0000d2  f2410113          MOV      r1,#0x1013
0000d6  f8c01334          STR      r1,[r0,#0x334]
;;;77     	LPC_SCT->EVENT[6].STATE = 1<<0; // event 6 is enabled in state 0
0000da  2101              MOVS     r1,#1
0000dc  4809              LDR      r0,|L5.260|
0000de  302c              ADDS     r0,r0,#0x2c
0000e0  6001              STR      r1,[r0,#0]
;;;78     
;;;79     	// start SCT timers
;;;80     	LPC_SCT->CTRL_L &= ~(1<<2);
0000e2  0788              LSLS     r0,r1,#30
0000e4  8880              LDRH     r0,[r0,#4]
0000e6  f0200004          BIC      r0,r0,#4
0000ea  0789              LSLS     r1,r1,#30
0000ec  8088              STRH     r0,[r1,#4]
;;;81     	LPC_SCT->CTRL_H &= ~(1<<2); 
0000ee  4608              MOV      r0,r1
0000f0  88c0              LDRH     r0,[r0,#6]
0000f2  f0200104          BIC      r1,r0,#4
0000f6  f04f4080          MOV      r0,#0x40000000
0000fa  80c1              STRH     r1,[r0,#6]
;;;82     }
0000fc  4770              BX       lr
;;;83     
                          ENDP

0000fe  0000              DCW      0x0000
                  |L5.256|
                          DCD      0x40000100
                  |L5.260|
                          DCD      0x40000304

                          AREA ||i._Z7cprintfPKcz||, CODE, READONLY, ALIGN=2

                  _Z7cprintfPKcz PROC ; cprintf(const char*, ...)
;;;222    
;;;223    void cprintf(const char *format, ...)
000000  b40f              PUSH     {r0-r3}
;;;224    {
000002  b500              PUSH     {lr}
000004  b0a3              SUB      sp,sp,#0x8c
;;;225        char  buf[128];
;;;226        va_list args;
;;;227        va_start(args, format);
000006  a825              ADD      r0,sp,#0x94
000008  9002              STR      r0,[sp,#8]
;;;228        vsprintf((char *)buf, (char const *)format, args);
00000a  a803              ADD      r0,sp,#0xc
00000c  9a02              LDR      r2,[sp,#8]
00000e  9924              LDR      r1,[sp,#0x90]
000010  f7fffffe          BL       __c89vsprintf
;;;229        va_end(args);
000014  2000              MOVS     r0,#0
000016  9002              STR      r0,[sp,#8]
;;;230    
;;;231    	CRP_SEND_XDATA(g_chirpUsb, HSTRING(buf));
000018  ab03              ADD      r3,sp,#0xc
00001a  22e1              MOVS     r2,#0xe1
00001c  2118              MOVS     r1,#0x18
00001e  9000              STR      r0,[sp,#0]
000020  4803              LDR      r0,|L6.48|
000022  6800              LDR      r0,[r0,#0]  ; g_chirpUsb
000024  f7fffffe          BL       _ZN5Chirp8assembleEhz ; Chirp::assemble(unsigned char, ...)
;;;232    }
000028  b023              ADD      sp,sp,#0x8c
00002a  f85dfb14          LDR      pc,[sp],#0x14
;;;233    
                          ENDP

00002e  0000              DCW      0x0000
                  |L6.48|
                          DCD      g_chirpUsb

                          AREA ||i._Z8GPIOInitv||, CODE, READONLY, ALIGN=2

                  _Z8GPIOInitv PROC ; GPIOInit()
;;;101    
;;;102    void GPIOInit(void)
000000  2100              MOVS     r1,#0
;;;103    {
;;;104    	// button, SPI_SSEL
;;;105    	LPC_GPIO_PORT->MASK[5] = 0;
000002  4806              LDR      r0,|L7.28|
000004  6141              STR      r1,[r0,#0x14]
;;;106    	LPC_GPIO_PORT->PIN[5] = 0x20; // negate SPI_SS
000006  2120              MOVS     r1,#0x20
000008  4804              LDR      r0,|L7.28|
00000a  3080              ADDS     r0,r0,#0x80
00000c  6141              STR      r1,[r0,#0x14]
;;;107    
;;;108    	// deal with P4_1, GPIO2[1]
;;;109    	LPC_GPIO_PORT->MASK[2] = 0;
00000e  2100              MOVS     r1,#0
000010  4802              LDR      r0,|L7.28|
000012  6081              STR      r1,[r0,#8]
;;;110    	LPC_GPIO_PORT->DIR[2] = 0;
000014  4801              LDR      r0,|L7.28|
000016  3880              SUBS     r0,r0,#0x80
000018  6081              STR      r1,[r0,#8]
;;;111    }
00001a  4770              BX       lr
;;;112    
                          ENDP

                  |L7.28|
                          DCD      0x400f6080

                          AREA ||i._Z8periodicv||, CODE, READONLY, ALIGN=2

                  _Z8periodicv PROC ; periodic()
;;;168    
;;;169    void periodic()
000000  b510              PUSH     {r4,lr}
;;;170    {
;;;171    	// check to see if guard data still there
;;;172    	if (STACK_GUARD!=STACK_GUARD_WORD)
000002  480d              LDR      r0,|L8.56|
000004  6800              LDR      r0,[r0,#0]  ; __Vectors
000006  f5a05080          SUB      r0,r0,#0x1000
00000a  f8b00a00          LDRH     r0,[r0,#0xa00]
00000e  f64a31cd          MOV      r1,#0xabcd
000012  4288              CMP      r0,r1
000014  d004              BEQ      |L8.32|
;;;173    		showError(1, 0xffff00, "stack corruption\n");
000016  a209              ADR      r2,|L8.60|
000018  490d              LDR      r1,|L8.80|
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       showError
                  |L8.32|
;;;174    
;;;175    	while(g_chirpUsb->service());
000020  bf00              NOP      
                  |L8.34|
000022  2101              MOVS     r1,#1
000024  480b              LDR      r0,|L8.84|
000026  6800              LDR      r0,[r0,#0]  ; g_chirpUsb
000028  f7fffffe          BL       _ZN5Chirp7serviceEb ; Chirp::service(bool)
00002c  2800              CMP      r0,#0
00002e  d1f8              BNE      |L8.34|
;;;176    	handleAWB();
000030  f7fffffe          BL       _Z9handleAWBv ; handleAWB()
;;;177    }
000034  bd10              POP      {r4,pc}
;;;178    
                          ENDP

000036  0000              DCW      0x0000
                  |L8.56|
                          DCD      __Vectors
                  |L8.60|
00003c  73746163          DCB      "stack corruption\n",0
000040  6b20636f
000044  72727570
000048  74696f6e
00004c  0a00    
00004e  00                DCB      0
00004f  00                DCB      0
                  |L8.80|
                          DCD      0x00ffff00
                  |L8.84|
                          DCD      g_chirpUsb

                          AREA ||i._Z8pixyInitjPKhj||, CODE, READONLY, ALIGN=2

                  _Z8pixyInitjPKhj PROC ; pixyInit(unsigned, const unsigned char*, unsigned)
;;;178    
;;;179    void pixyInit(uint32_t slaveRomStart, const unsigned char slaveImage[], uint32_t imageSize)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;180    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
000008  4691              MOV      r9,r2
;;;181    	// write stack guard word
;;;182     	STACK_GUARD = STACK_GUARD_WORD;
00000a  f64a31cd          MOV      r1,#0xabcd
00000e  482d              LDR      r0,|L9.196|
000010  6800              LDR      r0,[r0,#0]  ; __Vectors
000012  f5a05080          SUB      r0,r0,#0x1000
000016  f8a01a00          STRH     r1,[r0,#0xa00]
;;;183    
;;;184    	commonInit();
00001a  f7fffffe          BL       _Z10commonInitv ; commonInit()
;;;185    
;;;186    	IPC_haltSlave();
00001e  f7fffffe          BL       IPC_haltSlave
;;;187    
;;;188    	ADCInit();
000022  f7fffffe          BL       _Z7ADCInitv ; ADCInit()
;;;189       	SCTInit();
000026  f7fffffe          BL       _Z7SCTInitv ; SCTInit()
;;;190    	CameraInit();
00002a  f7fffffe          BL       _Z10CameraInitv ; CameraInit()
;;;191    
;;;192    	// start slave
;;;193    	if (slaveRomStart && slaveImage && imageSize)
00002e  b167              CBZ      r7,|L9.74|
000030  f1b80f00          CMP      r8,#0
000034  d009              BEQ      |L9.74|
000036  f1b90f00          CMP      r9,#0
00003a  d006              BEQ      |L9.74|
;;;194    	{
;;;195    		IPC_downloadSlaveImage(slaveRomStart, slaveImage, imageSize);
00003c  464a              MOV      r2,r9
00003e  4641              MOV      r1,r8
000040  4638              MOV      r0,r7
000042  f7fffffe          BL       IPC_downloadSlaveImage
;;;196    		IPC_startSlave();
000046  f7fffffe          BL       IPC_startSlave
                  |L9.74|
;;;197    	}
;;;198    
;;;199    	// initialize chirp objects
;;;200    	USBLink *usbLink = new USBLink;
00004a  2010              MOVS     r0,#0x10
00004c  f7fffffe          BL       _Znwj ; operator new(unsigned)
000050  4682              MOV      r10,r0
000052  f7fffffe          BL       _ZN7USBLinkC1Ev ; USBLink::USBLink()
000056  4682              MOV      r10,r0
000058  4655              MOV      r5,r10
;;;201    	g_chirpUsb = new Chirp(false, false, usbLink);
00005a  203c              MOVS     r0,#0x3c
00005c  f7fffffe          BL       _Znwj ; operator new(unsigned)
000060  4604              MOV      r4,r0
000062  462b              MOV      r3,r5
000064  2200              MOVS     r2,#0
000066  4611              MOV      r1,r2
000068  f7fffffe          BL       _ZN5ChirpC1EbbP4Link ; Chirp::Chirp(bool, bool, Link*)
00006c  4604              MOV      r4,r0
00006e  4816              LDR      r0,|L9.200|
000070  6004              STR      r4,[r0,#0]  ; g_chirpUsb
;;;202    	SMLink *smLink = new SMLink;
000072  2010              MOVS     r0,#0x10
000074  f7fffffe          BL       _Znwj ; operator new(unsigned)
000078  4683              MOV      r11,r0
00007a  f7fffffe          BL       _ZN6SMLinkC1Ev ; SMLink::SMLink()
00007e  4683              MOV      r11,r0
000080  465e              MOV      r6,r11
;;;203      	g_chirpM0 = new Chirp(false, true, smLink);
000082  203c              MOVS     r0,#0x3c
000084  f7fffffe          BL       _Znwj ; operator new(unsigned)
000088  4604              MOV      r4,r0
00008a  4633              MOV      r3,r6
00008c  2201              MOVS     r2,#1
00008e  2100              MOVS     r1,#0
000090  f7fffffe          BL       _ZN5ChirpC1EbbP4Link ; Chirp::Chirp(bool, bool, Link*)
000094  4604              MOV      r4,r0
000096  480d              LDR      r0,|L9.204|
000098  6004              STR      r4,[r0,#0]  ; g_chirpM0
;;;204    
;;;205    	// initialize devices/modules
;;;206    	led_init();
00009a  f7fffffe          BL       _Z8led_initv ; led_init()
;;;207    	if (prm_init(g_chirpUsb)<0) // error, let user know (don't just continue like nothing's happened)
00009e  480a              LDR      r0,|L9.200|
0000a0  6800              LDR      r0,[r0,#0]  ; g_chirpUsb
0000a2  f7fffffe          BL       _Z8prm_initP5Chirp ; prm_init(Chirp*)
0000a6  2800              CMP      r0,#0
0000a8  da04              BGE      |L9.180|
;;;208    		showError(1, 0x0000ff, "Flash is corrupt, parameters have been lost\n");
0000aa  a209              ADR      r2,|L9.208|
0000ac  21ff              MOVS     r1,#0xff
0000ae  2001              MOVS     r0,#1
0000b0  f7fffffe          BL       showError
                  |L9.180|
;;;209    	pwr_init();
0000b4  f7fffffe          BL       _Z8pwr_initv ; pwr_init()
;;;210    	cam_init();
0000b8  f7fffffe          BL       _Z8cam_initv ; cam_init()
;;;211    	rcs_init();
0000bc  f7fffffe          BL       _Z8rcs_initv ; rcs_init()
;;;212    	//cc_init();
;;;213    }
0000c0  e8bd9ff0          POP      {r4-r12,pc}
;;;214    
                          ENDP

                  |L9.196|
                          DCD      __Vectors
                  |L9.200|
                          DCD      g_chirpUsb
                  |L9.204|
                          DCD      g_chirpM0
                  |L9.208|
0000d0  466c6173          DCB      "Flash is corrupt, parameters have been lost\n",0
0000d4  68206973
0000d8  20636f72
0000dc  72757074
0000e0  2c207061
0000e4  72616d65
0000e8  74657273
0000ec  20686176
0000f0  65206265
0000f4  656e206c
0000f8  6f73740a
0000fc  00      
0000fd  00                DCB      0
0000fe  00                DCB      0
0000ff  00                DCB      0

                          AREA ||i._Z9handleAWBv||, CODE, READONLY, ALIGN=2

                  _Z9handleAWBv PROC ; handleAWB()
;;;139    
;;;140    void handleAWB()
000000  b51c              PUSH     {r2-r4,lr}
;;;141    {
;;;142    	static uint32_t timer;
;;;143    	static uint8_t state = 0;
;;;144    	uint8_t awb=0;
000002  2000              MOVS     r0,#0
000004  9001              STR      r0,[sp,#4]
;;;145    
;;;146    	if (state==2)
000006  481a              LDR      r0,|L10.112|
000008  7800              LDRB     r0,[r0,#0]  ; state
00000a  2802              CMP      r0,#2
00000c  d100              BNE      |L10.16|
                  |L10.14|
;;;147    		return;
;;;148    
;;;149    	prm_get("AWB Enable", &awb, END);
;;;150    	if (awb!=1)
;;;151    		return; // exit if auto white balance is disabled or always on
;;;152    
;;;153    	else if (state==0)
;;;154    	{
;;;155    		setTimer(&timer);
;;;156    		cam_setAWB(1);
;;;157    		state = 1;
;;;158    	}
;;;159    	else if (state==1)
;;;160    	{
;;;161    		if (getTimer(timer)>AWB_TIMEOUT)
;;;162    		{
;;;163    			cam_setAWB(0);
;;;164    		 	state = 2; // end state machine (only run once)
;;;165    		}
;;;166    	}
;;;167    }
00000e  bd1c              POP      {r2-r4,pc}
                  |L10.16|
000010  2200              MOVS     r2,#0                 ;149
000012  a901              ADD      r1,sp,#4              ;149
000014  a017              ADR      r0,|L10.116|
000016  f7fffffe          BL       _Z7prm_getPKcz ; prm_get(const char*, ...)
00001a  f89d0004          LDRB     r0,[sp,#4]            ;150
00001e  2801              CMP      r0,#1                 ;150
000020  d000              BEQ      |L10.36|
000022  e7f4              B        |L10.14|
                  |L10.36|
000024  4812              LDR      r0,|L10.112|
000026  7800              LDRB     r0,[r0,#0]            ;153  ; state
000028  b958              CBNZ     r0,|L10.66|
00002a  4815              LDR      r0,|L10.128|
00002c  f7fffffe          BL       setTimer
000030  2001              MOVS     r0,#1                 ;156
000032  9000              STR      r0,[sp,#0]            ;156
000034  4668              MOV      r0,sp                 ;156
000036  f7fffffe          BL       _Z10cam_setAWBRKh ; cam_setAWB(const unsigned char&)
00003a  2001              MOVS     r0,#1                 ;157
00003c  490c              LDR      r1,|L10.112|
00003e  7008              STRB     r0,[r1,#0]            ;157
000040  e013              B        |L10.106|
                  |L10.66|
000042  480b              LDR      r0,|L10.112|
000044  7800              LDRB     r0,[r0,#0]            ;159  ; state
000046  2801              CMP      r0,#1                 ;159
000048  d10f              BNE      |L10.106|
00004a  480d              LDR      r0,|L10.128|
00004c  6800              LDR      r0,[r0,#0]            ;161  ; timer
00004e  f7fffffe          BL       getTimer
000052  490c              LDR      r1,|L10.132|
000054  4288              CMP      r0,r1                 ;161
000056  d908              BLS      |L10.106|
000058  2000              MOVS     r0,#0                 ;163
00005a  9000              STR      r0,[sp,#0]            ;163
00005c  4668              MOV      r0,sp                 ;163
00005e  f7fffffe          BL       _Z10cam_setAWBRKh ; cam_setAWB(const unsigned char&)
000062  2002              MOVS     r0,#2                 ;164
000064  4902              LDR      r1,|L10.112|
000066  7008              STRB     r0,[r1,#0]            ;164
000068  bf00              NOP                            ;165
                  |L10.106|
00006a  bf00              NOP      
00006c  e7cf              B        |L10.14|
;;;168    
                          ENDP

00006e  0000              DCW      0x0000
                  |L10.112|
                          DCD      state
                  |L10.116|
000074  41574220          DCB      "AWB Enable",0
000078  456e6162
00007c  6c6500  
00007f  00                DCB      0
                  |L10.128|
                          DCD      timer
                  |L10.132|
                          DCD      0x002dc6c0

                          AREA ||i._Z9timerInitv||, CODE, READONLY, ALIGN=2

                  _Z9timerInitv PROC ; timerInit()
;;;112    
;;;113    void timerInit(void)
000000  2000              MOVS     r0,#0
;;;114    {
;;;115    	// set timer so we count clock cycles
;;;116    	LPC_TIMER1->IR = 0;
000002  4906              LDR      r1,|L11.28|
000004  6008              STR      r0,[r1,#0]
;;;117     	LPC_TIMER1->TCR = 1;
000006  2001              MOVS     r0,#1
000008  6048              STR      r0,[r1,#4]
;;;118    	LPC_TIMER1->PR = 0;
00000a  2000              MOVS     r0,#0
00000c  60c8              STR      r0,[r1,#0xc]
;;;119    
;;;120    	// microsecond timer
;;;121    	LPC_TIMER2->IR = 0;
00000e  4904              LDR      r1,|L11.32|
000010  6008              STR      r0,[r1,#0]
;;;122     	LPC_TIMER2->TCR = 1;
000012  2001              MOVS     r0,#1
000014  6048              STR      r0,[r1,#4]
;;;123    	LPC_TIMER2->PR = CLKFREQ_US-1;
000016  20cb              MOVS     r0,#0xcb
000018  60c8              STR      r0,[r1,#0xc]
;;;124    }
00001a  4770              BX       lr
;;;125    
                          ENDP

                  |L11.28|
                          DCD      0x40085000
                  |L11.32|
                          DCD      0x400c3000

                          AREA ||.ARM.exidx||, LINKORDER=||i._Z7ADCInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._Z7ADCInitv||
                          DCD      0x00000001

                          AREA ||area_number.13||, LINKORDER=||i._Z7SCTInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.13||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z7SCTInitv||
                          DCD      0x00000001

                          AREA ||area_number.14||, LINKORDER=||i._Z10CameraInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.14||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z10CameraInitv||
                          DCD      0x00000001

                          AREA ||area_number.15||, LINKORDER=||i._Z8GPIOInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.15||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z8GPIOInitv||
                          DCD      0x00000001

                          AREA ||area_number.16||, LINKORDER=||i._Z9timerInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.16||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z9timerInitv||
                          DCD      0x00000001

                          AREA ||area_number.17||, LINKORDER=||i._Z10commonInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.17||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z10commonInitv||
                          DCD      0x00000001

                          AREA ||area_number.18||, LINKORDER=||i._Z9handleAWBv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z9handleAWBv||
                          DCD      0x00000001

                          AREA ||area_number.19||, LINKORDER=||i._Z8periodicv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z8periodicv||
                          DCD      0x00000001

                          AREA ||area_number.20||, LINKORDER=||i._Z8pixyInitjPKhj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.20||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z8pixyInitjPKhj||
                          DCD      0x00000001

                          AREA ||area_number.21||, LINKORDER=||i._Z14pixySimpleInitv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.21||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z14pixySimpleInitv||
                          DCD      0x00000001

                          AREA ||area_number.22||, LINKORDER=||i._Z7cprintfPKcz||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._Z7cprintfPKcz||
                          DCD      0x00000001

                          AREA ||.data||, DATA, ALIGN=2

                  g_chirpUsb
                          DCD      0x00000000
                  g_chirpM0
                          DCD      0x00000000
                  timer
                          DCD      0x00000000
                  state
00000c  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "pixy_init.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_pixy_init_cpp_9168d7b9___Z7__REV16j|
#line 130 ".\\core_cmInstr.h"
|__asm___13_pixy_init_cpp_9168d7b9___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_pixy_init_cpp_9168d7b9___Z7__REVSHi|
#line 144
|__asm___13_pixy_init_cpp_9168d7b9___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

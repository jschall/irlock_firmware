; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\lpc43xx_adc.o --asm_dir=.\ --list_dir=.\ --depend=.\lpc43xx_adc.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I. -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\lpc43xx_adc.crf lpc43xx_adc.c]
                          THUMB

                          AREA ||i.ADC_BurstCmd||, CODE, READONLY, ALIGN=1

                  ADC_BurstCmd PROC
;;;179    **********************************************************************/
;;;180    void ADC_BurstCmd(LPC_ADCn_Type *ADCx, FunctionalState NewState)
000000  6802              LDR      r2,[r0,#0]
;;;181    {
;;;182    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;183    
;;;184    	ADCx->CR &= ~ADC_CR_BURST;
000002  f4223280          BIC      r2,r2,#0x10000
000006  6002              STR      r2,[r0,#0]
;;;185    	if (NewState){
000008  b119              CBZ      r1,|L1.18|
;;;186    		ADCx->CR |= ADC_CR_BURST;
00000a  6802              LDR      r2,[r0,#0]
00000c  f4423280          ORR      r2,r2,#0x10000
000010  6002              STR      r2,[r0,#0]
                  |L1.18|
;;;187    	}
;;;188    }
000012  4770              BX       lr
;;;189    
                          ENDP


                          AREA ||i.ADC_ChannelCmd||, CODE, READONLY, ALIGN=1

                  ADC_ChannelCmd PROC
;;;260    **********************************************************************/
;;;261    void ADC_ChannelCmd (LPC_ADCn_Type *ADCx, uint8_t Channel, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;262    {
;;;263    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;264    	CHECK_PARAM(PARAM_ADC_CHANNEL_SELECTION(Channel));
;;;265    
;;;266    	if (NewState == ENABLE) {
000002  2a01              CMP      r2,#1
000004  d105              BNE      |L2.18|
;;;267    		ADCx->CR |= ADC_CR_CH_SEL(Channel);
000006  6803              LDR      r3,[r0,#0]
000008  2401              MOVS     r4,#1
00000a  408c              LSLS     r4,r4,r1
00000c  4323              ORRS     r3,r3,r4
00000e  6003              STR      r3,[r0,#0]
000010  e004              B        |L2.28|
                  |L2.18|
;;;268    	} else {
;;;269    		ADCx->CR &= ~ADC_CR_CH_SEL(Channel);
000012  6803              LDR      r3,[r0,#0]
000014  2401              MOVS     r4,#1
000016  408c              LSLS     r4,r4,r1
000018  43a3              BICS     r3,r3,r4
00001a  6003              STR      r3,[r0,#0]
                  |L2.28|
;;;270    	}
;;;271    }
00001c  bd10              POP      {r4,pc}
;;;272    
                          ENDP


                          AREA ||i.ADC_ChannelGetData||, CODE, READONLY, ALIGN=1

                  ADC_ChannelGetData PROC
;;;278    **********************************************************************/
;;;279    uint16_t ADC_ChannelGetData(LPC_ADCn_Type *ADCx, uint8_t channel)
000000  4602              MOV      r2,r0
;;;280    {
;;;281    	uint32_t adc_value;
;;;282    
;;;283    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;284    	CHECK_PARAM(PARAM_ADC_CHANNEL_SELECTION(channel));
;;;285    
;;;286    	adc_value = *(uint32_t *) ((&(ADCx->DR[0])) + channel);
000002  f1020010          ADD      r0,r2,#0x10
000006  f8503021          LDR      r3,[r0,r1,LSL #2]
;;;287    	return ADC_DR_RESULT(adc_value);
00000a  f3c31089          UBFX     r0,r3,#6,#10
;;;288    }
00000e  4770              BX       lr
;;;289    
                          ENDP


                          AREA ||i.ADC_ChannelGetStatus||, CODE, READONLY, ALIGN=1

                  ADC_ChannelGetStatus PROC
;;;300    **********************************************************************/
;;;301    FlagStatus ADC_ChannelGetStatus(LPC_ADCn_Type *ADCx, uint8_t channel, uint32_t StatusType)
000000  b510              PUSH     {r4,lr}
;;;302    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;303    	uint32_t temp;
;;;304    
;;;305    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;306    	CHECK_PARAM(PARAM_ADC_CHANNEL_SELECTION(channel));
;;;307    	CHECK_PARAM(PARAM_ADC_DATA_STATUS(StatusType));
;;;308    
;;;309    	temp =  *(uint32_t *) ((&ADCx->DR[0]) + channel);
000006  f1030010          ADD      r0,r3,#0x10
00000a  f8501024          LDR      r1,[r0,r4,LSL #2]
;;;310    	if (StatusType) {
00000e  b112              CBZ      r2,|L4.22|
;;;311    		temp &= ADC_DR_DONE_FLAG;
000010  f0014100          AND      r1,r1,#0x80000000
000014  e001              B        |L4.26|
                  |L4.22|
;;;312    	}else{
;;;313    		temp &= ADC_DR_OVERRUN_FLAG;
000016  f0014180          AND      r1,r1,#0x40000000
                  |L4.26|
;;;314    	}
;;;315    	if (temp) {
00001a  b109              CBZ      r1,|L4.32|
;;;316    		return SET;
00001c  2001              MOVS     r0,#1
                  |L4.30|
;;;317    	} else {
;;;318    		return RESET;
;;;319    	}
;;;320    
;;;321    }
00001e  bd10              POP      {r4,pc}
                  |L4.32|
000020  2000              MOVS     r0,#0                 ;318
000022  e7fc              B        |L4.30|
;;;322    
                          ENDP


                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=1

                  ADC_DeInit PROC
;;;120    **********************************************************************/
;;;121    void ADC_DeInit(LPC_ADCn_Type *ADCx)
000000  6801              LDR      r1,[r0,#0]
;;;122    {
;;;123    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;124    
;;;125    	// Clear PDN bit
;;;126    	ADCx->CR &= ~ADC_CR_PDN;
000002  f4211100          BIC      r1,r1,#0x200000
000006  6001              STR      r1,[r0,#0]
;;;127    	// Turn on power and clock
;;;128    	//CGU_ConfigPPWR (CGU_PCONP_PCAD, DISABLE);
;;;129    }
000008  4770              BX       lr
;;;130    
                          ENDP


                          AREA ||i.ADC_EdgeStartConfig||, CODE, READONLY, ALIGN=1

                  ADC_EdgeStartConfig PROC
;;;215    **********************************************************************/
;;;216    void ADC_EdgeStartConfig(LPC_ADCn_Type *ADCx, uint8_t EdgeOption)
000000  6802              LDR      r2,[r0,#0]
;;;217    {
;;;218    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;219    	CHECK_PARAM(PARAM_ADC_START_ON_EDGE_OPT(EdgeOption));
;;;220    
;;;221    	ADCx->CR &= ~ADC_CR_EDGE;
000002  f0226200          BIC      r2,r2,#0x8000000
000006  6002              STR      r2,[r0,#0]
;;;222    	if (EdgeOption){
000008  b119              CBZ      r1,|L6.18|
;;;223    		ADCx->CR |= ADC_CR_EDGE;
00000a  6802              LDR      r2,[r0,#0]
00000c  f0426200          ORR      r2,r2,#0x8000000
000010  6002              STR      r2,[r0,#0]
                  |L6.18|
;;;224    	}
;;;225    }
000012  4770              BX       lr
;;;226    
                          ENDP


                          AREA ||i.ADC_GlobalGetData||, CODE, READONLY, ALIGN=1

                  ADC_GlobalGetData PROC
;;;327    **********************************************************************/
;;;328    uint32_t ADC_GlobalGetData(LPC_ADCn_Type *ADCx)
000000  4601              MOV      r1,r0
;;;329    {
;;;330    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;331    
;;;332    	return ((uint32_t)(ADCx->GDR));
000002  6848              LDR      r0,[r1,#4]
;;;333    }
000004  4770              BX       lr
;;;334    
                          ENDP


                          AREA ||i.ADC_GlobalGetStatus||, CODE, READONLY, ALIGN=1

                  ADC_GlobalGetStatus PROC
;;;342    **********************************************************************/
;;;343    FlagStatus	ADC_GlobalGetStatus(LPC_ADCn_Type *ADCx, uint32_t StatusType)
000000  4602              MOV      r2,r0
;;;344    {
000002  460b              MOV      r3,r1
;;;345    	uint32_t temp;
;;;346    
;;;347    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;348    	CHECK_PARAM(PARAM_ADC_DATA_STATUS(StatusType));
;;;349    
;;;350    	temp =  ADCx->GDR;
000004  6851              LDR      r1,[r2,#4]
;;;351    	if (StatusType){
000006  b113              CBZ      r3,|L8.14|
;;;352    		temp &= ADC_DR_DONE_FLAG;
000008  f0014100          AND      r1,r1,#0x80000000
00000c  e001              B        |L8.18|
                  |L8.14|
;;;353    	}else{
;;;354    		temp &= ADC_DR_OVERRUN_FLAG;
00000e  f0014180          AND      r1,r1,#0x40000000
                  |L8.18|
;;;355    	}
;;;356    	if (temp){
000012  b109              CBZ      r1,|L8.24|
;;;357    		return SET;
000014  2001              MOVS     r0,#1
                  |L8.22|
;;;358    	}else{
;;;359    		return RESET;
;;;360    	}
;;;361    }
000016  4770              BX       lr
                  |L8.24|
000018  2000              MOVS     r0,#0                 ;359
00001a  e7fc              B        |L8.22|
;;;362    
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;82      **********************************************************************/
;;;83     void ADC_Init(LPC_ADCn_Type *ADCx, uint32_t rate, uint8_t bits_accuracy)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;84     {
000004  4605              MOV      r5,r0
000006  4689              MOV      r9,r1
000008  4616              MOV      r6,r2
;;;85     	uint32_t temp, tmpreg, ADCbitrate;
;;;86     
;;;87     	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;88     	CHECK_PARAM(PARAM_ADC_RATE(rate));
;;;89     
;;;90     	// Turn on power and clock
;;;91     	//CGU_ConfigPPWR (CGU_PCONP_PCAD, ENABLE);
;;;92     
;;;93     	ADCx->CR = 0;
00000a  2000              MOVS     r0,#0
00000c  6028              STR      r0,[r5,#0]
;;;94     
;;;95     	//Enable PDN bit
;;;96     	tmpreg = ADC_CR_PDN;
00000e  f44f1800          MOV      r8,#0x200000
;;;97     	// Set clock frequency
;;;98     	if(ADCx == LPC_ADC0)
000012  4811              LDR      r0,|L9.88|
000014  4285              CMP      r5,r0
000016  d104              BNE      |L9.34|
;;;99     		temp = CGU_GetPCLKFrequency(CGU_PERIPHERAL_ADC0);
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       CGU_GetPCLKFrequency
00001e  4604              MOV      r4,r0
000020  e006              B        |L9.48|
                  |L9.34|
;;;100    	else if(ADCx == LPC_ADC1)
000022  480e              LDR      r0,|L9.92|
000024  4285              CMP      r5,r0
000026  d103              BNE      |L9.48|
;;;101    		temp = CGU_GetPCLKFrequency(CGU_PERIPHERAL_ADC1);
000028  2001              MOVS     r0,#1
00002a  f7fffffe          BL       CGU_GetPCLKFrequency
00002e  4604              MOV      r4,r0
                  |L9.48|
;;;102    	/* The APB clock (PCLK_ADC0) is divided by (CLKDIV+1) to produce the clock for
;;;103    	 * A/D converter, which should be less than or equal to 13MHz.
;;;104    	 * A fully conversion requires (bits_accuracy+1) of these clocks.
;;;105    	 * ADC clock = PCLK_ADC0 / (CLKDIV + 1);
;;;106    	 * ADC rate = ADC clock / (bits_accuracy+1);
;;;107    	 */
;;;108    	 ADCbitrate = (rate * (bits_accuracy+1));
000030  1c70              ADDS     r0,r6,#1
000032  fb09f700          MUL      r7,r9,r0
;;;109    	temp = ((temp*2 + ADCbitrate) / (ADCbitrate*2)) - 1;//get the round value by fomular: (2*A + B)/(2*B)
000036  eb070044          ADD      r0,r7,r4,LSL #1
00003a  0079              LSLS     r1,r7,#1
00003c  fbb0f0f1          UDIV     r0,r0,r1
000040  1e44              SUBS     r4,r0,#1
;;;110    	tmpreg |=  ADC_CR_CLKDIV(temp) | ADC_CR_BITACC(10 - bits_accuracy);
000042  0220              LSLS     r0,r4,#8
000044  f1c6010a          RSB      r1,r6,#0xa
000048  ea404041          ORR      r0,r0,r1,LSL #17
00004c  ea400808          ORR      r8,r0,r8
;;;111    
;;;112    	ADCx->CR = tmpreg;
000050  f8c58000          STR      r8,[r5,#0]
;;;113    }
000054  e8bd87f0          POP      {r4-r10,pc}
;;;114    
                          ENDP

                  |L9.88|
                          DCD      0x400e3000
                  |L9.92|
                          DCD      0x400e4000

                          AREA ||i.ADC_IntConfig||, CODE, READONLY, ALIGN=1

                  ADC_IntConfig PROC
;;;240    **********************************************************************/
;;;241    void ADC_IntConfig (LPC_ADCn_Type *ADCx, ADC_TYPE_INT_OPT IntType, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;242    {
;;;243    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;244    	CHECK_PARAM(PARAM_ADC_TYPE_INT_OPT(IntType));
;;;245    
;;;246    	ADCx->INTEN &= ~ADC_INTEN_CH(IntType);
000002  68c3              LDR      r3,[r0,#0xc]
000004  2401              MOVS     r4,#1
000006  408c              LSLS     r4,r4,r1
000008  43a3              BICS     r3,r3,r4
00000a  60c3              STR      r3,[r0,#0xc]
;;;247    	if (NewState){
00000c  b122              CBZ      r2,|L10.24|
;;;248    		ADCx->INTEN |= ADC_INTEN_CH(IntType);
00000e  68c4              LDR      r4,[r0,#0xc]
000010  2301              MOVS     r3,#1
000012  408b              LSLS     r3,r3,r1
000014  431c              ORRS     r4,r4,r3
000016  60c4              STR      r4,[r0,#0xc]
                  |L10.24|
;;;249    	}
;;;250    }
000018  bd10              POP      {r4,pc}
;;;251    
                          ENDP


                          AREA ||i.ADC_PowerdownCmd||, CODE, READONLY, ALIGN=1

                  ADC_PowerdownCmd PROC
;;;197    **********************************************************************/
;;;198    void ADC_PowerdownCmd(LPC_ADCn_Type *ADCx, FunctionalState NewState)
000000  6802              LDR      r2,[r0,#0]
;;;199    {
;;;200    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;201    
;;;202    	ADCx->CR &= ~ADC_CR_PDN;
000002  f4221200          BIC      r2,r2,#0x200000
000006  6002              STR      r2,[r0,#0]
;;;203    	if (NewState){
000008  b119              CBZ      r1,|L11.18|
;;;204    		ADCx->CR |= ADC_CR_PDN;
00000a  6802              LDR      r2,[r0,#0]
00000c  f4421200          ORR      r2,r2,#0x200000
000010  6002              STR      r2,[r0,#0]
                  |L11.18|
;;;205    	}
;;;206    }
000012  4770              BX       lr
;;;207    
                          ENDP


                          AREA ||i.ADC_StartCmd||, CODE, READONLY, ALIGN=1

                  ADC_StartCmd PROC
;;;161    *********************************************************************/
;;;162    void ADC_StartCmd(LPC_ADCn_Type *ADCx, uint8_t start_mode)
000000  6802              LDR      r2,[r0,#0]
;;;163    {
;;;164    	CHECK_PARAM(PARAM_ADCx(ADCx));
;;;165    	CHECK_PARAM(PARAM_ADC_START_OPT(start_mode));
;;;166    
;;;167    	ADCx->CR &= ~ADC_CR_START_MASK;
000002  f02262e0          BIC      r2,r2,#0x7000000
000006  6002              STR      r2,[r0,#0]
;;;168    	ADCx->CR |=ADC_CR_START_MODE_SEL((uint32_t)start_mode);
000008  6802              LDR      r2,[r0,#0]
00000a  ea426201          ORR      r2,r2,r1,LSL #24
00000e  6002              STR      r2,[r0,#0]
;;;169    }
000010  4770              BX       lr
;;;170    
                          ENDP


;*** Start embedded assembler ***

#line 1 "lpc43xx_adc.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_lpc43xx_adc_c_ADC_Init____REV16|
#line 130 ".\\core_cmInstr.h"
|__asm___13_lpc43xx_adc_c_ADC_Init____REV16| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___13_lpc43xx_adc_c_ADC_Init____REVSH|
#line 144
|__asm___13_lpc43xx_adc_c_ADC_Init____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\usbuser.o --asm_dir=.\ --list_dir=.\ --depend=.\usbuser.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I. -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\usbuser.crf usbuser.c]
                          THUMB

                          AREA ||i.USB_Configure_Event||, CODE, READONLY, ALIGN=1

                  USB_Configure_Event PROC
;;;135    #if USB_CONFIGURE_EVENT
;;;136    void USB_Configure_Event (void) {
000000  4770              BX       lr
;;;137    
;;;138      if (USB_Configuration) {                  /* Check if USB is configured */
;;;139        /* add your code here */
;;;140      }
;;;141    }
;;;142    #endif
                          ENDP


                          AREA ||i.USB_EndPoint1||, CODE, READONLY, ALIGN=1

                  USB_EndPoint1 PROC
;;;185    
;;;186    void USB_EndPoint1 (uint32_t event) {
000000  2803              CMP      r0,#3
;;;187      switch (event) {
000002  d100              BNE      |L2.6|
;;;188        case USB_EVT_IN:
;;;189          break;
000004  bf00              NOP      
                  |L2.6|
000006  bf00              NOP      
;;;190      }
;;;191    }
000008  4770              BX       lr
;;;192    
                          ENDP


                          AREA ||i.USB_EndPoint2||, CODE, READONLY, ALIGN=1

                  USB_EndPoint2 PROC
;;;215    
;;;216    void USB_EndPoint2 (uint32_t event) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;217    
;;;218      switch (event) {
000004  2c02              CMP      r4,#2
000006  d004              BEQ      |L3.18|
000008  2c03              CMP      r4,#3
00000a  d005              BEQ      |L3.24|
00000c  2c04              CMP      r4,#4
00000e  d106              BNE      |L3.30|
;;;219         case USB_EVT_OUT_NAK:
;;;220          //bulkOutNak();
;;;221          break;
000010  e005              B        |L3.30|
                  |L3.18|
;;;222        case USB_EVT_OUT:
;;;223    	  recvChunk();
000012  f7fffffe          BL       recvChunk
;;;224          break;
000016  e002              B        |L3.30|
                  |L3.24|
;;;225        case USB_EVT_IN:  // this gets called upon completion
;;;226    	  sendChunk();
000018  f7fffffe          BL       sendChunk
;;;227          break;
00001c  bf00              NOP      
                  |L3.30|
00001e  bf00              NOP                            ;221
;;;228      }
;;;229    }
000020  bd10              POP      {r4,pc}
;;;230    
                          ENDP


                          AREA ||i.USB_EndPoint3||, CODE, READONLY, ALIGN=1

                  USB_EndPoint3 PROC
;;;237    
;;;238    void USB_EndPoint3 (uint32_t event) {
000000  4770              BX       lr
;;;239    }
;;;240    
                          ENDP


                          AREA ||i.USB_EndPoint4||, CODE, READONLY, ALIGN=1

                  USB_EndPoint4 PROC
;;;247    
;;;248    void USB_EndPoint4 (uint32_t event) {
000000  4770              BX       lr
;;;249    }
;;;250    
                          ENDP


                          AREA ||i.USB_EndPoint5||, CODE, READONLY, ALIGN=1

                  USB_EndPoint5 PROC
;;;257    
;;;258    void USB_EndPoint5 (uint32_t event) {
000000  bf00              NOP      
;;;259      event = event;
;;;260    }
000002  4770              BX       lr
;;;261    
                          ENDP


                          AREA ||i.USB_Recv||, CODE, READONLY, ALIGN=2

                  USB_Recv PROC
;;;382    
;;;383    void USB_Recv(uint8_t *data, uint32_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;384    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;385    	if ((uint32_t)data&0x03)
000006  f0040003          AND      r0,r4,#3
00000a  b100              CBZ      r0,|L7.14|
                  |L7.12|
;;;386    		return;
;;;387    
;;;388    	g_recvData = data;
;;;389    	g_recvLen = len;
;;;390    	g_recvOffset = 0;
;;;391    	g_recvComplete = 0;
;;;392    
;;;393    	recvChunk();
;;;394    }  
00000c  bd70              POP      {r4-r6,pc}
                  |L7.14|
00000e  4806              LDR      r0,|L7.40|
000010  6004              STR      r4,[r0,#0]            ;388  ; g_recvData
000012  4806              LDR      r0,|L7.44|
000014  6005              STR      r5,[r0,#0]            ;389  ; g_recvLen
000016  2000              MOVS     r0,#0                 ;390
000018  4905              LDR      r1,|L7.48|
00001a  6008              STR      r0,[r1,#0]            ;390  ; g_recvOffset
00001c  4905              LDR      r1,|L7.52|
00001e  7008              STRB     r0,[r1,#0]            ;391
000020  f7fffffe          BL       recvChunk
000024  bf00              NOP      
000026  e7f1              B        |L7.12|
;;;395    
                          ENDP

                  |L7.40|
                          DCD      g_recvData
                  |L7.44|
                          DCD      g_recvLen
                  |L7.48|
                          DCD      g_recvOffset
                  |L7.52|
                          DCD      g_recvComplete

                          AREA ||i.USB_RecvReset||, CODE, READONLY, ALIGN=1

                  USB_RecvReset PROC
;;;395    
;;;396    void USB_RecvReset(void)
000000  b510              PUSH     {r4,lr}
;;;397    {
;;;398    	USB_ResetEP(USB_BULK_OUT_EP);
000002  2002              MOVS     r0,#2
000004  f7fffffe          BL       USB_ResetEP
;;;399    }
000008  bd10              POP      {r4,pc}
;;;400    
                          ENDP


                          AREA ||i.USB_Reset_Event||, CODE, READONLY, ALIGN=1

                  USB_Reset_Event PROC
;;;67     #if USB_RESET_EVENT
;;;68     void USB_Reset_Event (void) {
000000  b510              PUSH     {r4,lr}
;;;69       USB_ResetCore();
000002  f7fffffe          BL       USB_ResetCore
;;;70     }
000006  bd10              POP      {r4,pc}
;;;71     #endif
                          ENDP


                          AREA ||i.USB_Resume_Event||, CODE, READONLY, ALIGN=1

                  USB_Resume_Event PROC
;;;90     #if USB_RESUME_EVENT
;;;91     void USB_Resume_Event (void) {
000000  4770              BX       lr
;;;92     }
;;;93     #endif
                          ENDP


                          AREA ||i.USB_Send||, CODE, READONLY, ALIGN=2

                  USB_Send PROC
;;;368    
;;;369    void USB_Send(const uint8_t *data, uint32_t len)
000000  b570              PUSH     {r4-r6,lr}
;;;370    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;371    	if ((uint32_t)data&0x3)
000006  f0040003          AND      r0,r4,#3
00000a  b100              CBZ      r0,|L11.14|
                  |L11.12|
;;;372    		return;
;;;373    
;;;374    	g_sendData = data;
;;;375    	g_sendLen = len;
;;;376    	g_sendOffset = 0;
;;;377    	g_sendComplete = 0;
;;;378    
;;;379    	sendChunk();
;;;380    }
00000c  bd70              POP      {r4-r6,pc}
                  |L11.14|
00000e  4806              LDR      r0,|L11.40|
000010  6004              STR      r4,[r0,#0]            ;374  ; g_sendData
000012  4806              LDR      r0,|L11.44|
000014  6005              STR      r5,[r0,#0]            ;375  ; g_sendLen
000016  2000              MOVS     r0,#0                 ;376
000018  4905              LDR      r1,|L11.48|
00001a  6008              STR      r0,[r1,#0]            ;376  ; g_sendOffset
00001c  4905              LDR      r1,|L11.52|
00001e  7008              STRB     r0,[r1,#0]            ;377
000020  f7fffffe          BL       sendChunk
000024  bf00              NOP      
000026  e7f1              B        |L11.12|
;;;381    
                          ENDP

                  |L11.40|
                          DCD      g_sendData
                  |L11.44|
                          DCD      g_sendLen
                  |L11.48|
                          DCD      g_sendOffset
                  |L11.52|
                          DCD      g_sendComplete

                          AREA ||i.USB_SendReset||, CODE, READONLY, ALIGN=1

                  USB_SendReset PROC
;;;400    
;;;401    void USB_SendReset(void)
000000  b510              PUSH     {r4,lr}
;;;402    {
;;;403    	USB_ResetEP(USB_BULK_IN_EP);
000002  2082              MOVS     r0,#0x82
000004  f7fffffe          BL       USB_ResetEP
;;;404    }
000008  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i.USB_Suspend_Event||, CODE, READONLY, ALIGN=1

                  USB_Suspend_Event PROC
;;;79     #if USB_SUSPEND_EVENT
;;;80     void USB_Suspend_Event (void) {
000000  4770              BX       lr
;;;81     }
;;;82     #endif
                          ENDP


                          AREA ||i.USB_UserInit||, CODE, READONLY, ALIGN=2

                  USB_UserInit PROC
;;;261    
;;;262    void USB_UserInit(void)
000000  b500              PUSH     {lr}
;;;263    {
000002  b08f              SUB      sp,sp,#0x3c
;;;264    	LPC_USBDRV_INIT_T usb_cb;
;;;265    
;;;266    	/* initilize call back structures */
;;;267    	memset((void*)&usb_cb, 0, sizeof(LPC_USBDRV_INIT_T));
000004  213c              MOVS     r1,#0x3c
000006  4668              MOV      r0,sp
000008  f7fffffe          BL       __aeabi_memclr4
;;;268    	usb_cb.USB_Reset_Event = USB_Reset_Event;
00000c  4808              LDR      r0,|L14.48|
00000e  9002              STR      r0,[sp,#8]
;;;269    	usb_cb.USB_P_EP[0] = USB_EndPoint0;
000010  4808              LDR      r0,|L14.52|
000012  900b              STR      r0,[sp,#0x2c]
;;;270    	usb_cb.USB_P_EP[1] = USB_EndPoint1;
000014  4908              LDR      r1,|L14.56|
000016  910c              STR      r1,[sp,#0x30]
;;;271    	usb_cb.USB_P_EP[2] = USB_EndPoint2;
000018  4908              LDR      r1,|L14.60|
00001a  910d              STR      r1,[sp,#0x34]
;;;272    	usb_cb.ep0_maxp = USB_MAX_PACKET0;
00001c  2040              MOVS     r0,#0x40
00001e  9000              STR      r0,[sp,#0]
;;;273    
;;;274      USB_Init(&usb_cb);                               // USB Initialization
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       USB_Init
;;;275      // delay?
;;;276      //for(i=0; i<10000000; i++);
;;;277      USB_Connect(TRUE);                        // USB Connect
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       USB_Connect
;;;278      //for(i=0; i<100000000; i++);
;;;279      //while (!USB_Configuration);
;;;280    }
00002c  b00f              ADD      sp,sp,#0x3c
00002e  bd00              POP      {pc}
;;;281    
                          ENDP

                  |L14.48|
                          DCD      USB_Reset_Event
                  |L14.52|
                          DCD      USB_EndPoint0
                  |L14.56|
                          DCD      USB_EndPoint1
                  |L14.60|
                          DCD      USB_EndPoint2

                          AREA ||i.USB_handleState||, CODE, READONLY, ALIGN=2

                  USB_handleState PROC
;;;282    // monitor usb connector plug/unplugs
;;;283    uint32_t USB_handleState(void)
000000  b510              PUSH     {r4,lr}
;;;284    {
;;;285    	uint32_t susp;
;;;286    
;;;287    	if (USB_Configuration)
000002  480b              LDR      r0,|L15.48|
000004  7800              LDRB     r0,[r0,#0]  ; USB_Configuration
000006  b180              CBZ      r0,|L15.42|
;;;288    	{
;;;289    		susp = LPC_USB->PORTSC1_D&(1<<7); 
000008  480a              LDR      r0,|L15.52|
00000a  6800              LDR      r0,[r0,#0]
00000c  f0000480          AND      r4,r0,#0x80
;;;290    		if (susp)
000010  b15c              CBZ      r4,|L15.42|
;;;291    		{
;;;292    			USB_ResetEP(USB_BULK_OUT_EP);
000012  2002              MOVS     r0,#2
000014  f7fffffe          BL       USB_ResetEP
;;;293    			USB_ResetEP(USB_BULK_IN_EP);
000018  2082              MOVS     r0,#0x82
00001a  f7fffffe          BL       USB_ResetEP
;;;294    			USB_Configuration = 0;
00001e  2000              MOVS     r0,#0
000020  4903              LDR      r1,|L15.48|
000022  7008              STRB     r0,[r1,#0]
;;;295    			printf("reset configuration\n");
000024  a004              ADR      r0,|L15.56|
000026  f7fffffe          BL       lpc_printf
                  |L15.42|
;;;296    		}
;;;297    	}
;;;298    
;;;299    	return USB_Configuration;
00002a  4801              LDR      r0,|L15.48|
00002c  7800              LDRB     r0,[r0,#0]  ; USB_Configuration
;;;300    }
00002e  bd10              POP      {r4,pc}
;;;301    
                          ENDP

                  |L15.48|
                          DCD      USB_Configuration
                  |L15.52|
                          DCD      0x40006184
                  |L15.56|
000038  72657365          DCB      "reset configuration\n",0
00003c  7420636f
000040  6e666967
000044  75726174
000048  696f6e0a
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.bulkOutNak||, CODE, READONLY, ALIGN=1

                  bulkOutNak PROC
;;;301    
;;;302    void bulkOutNak(void){
000000  4770              BX       lr
;;;303        //USB_ReadReqEP(USB_BULK_OUT_EP, (uint8_t *)buf, len);
;;;304    }
;;;305    
                          ENDP


                          AREA ||i.recvChunk||, CODE, READONLY, ALIGN=2

                  recvChunk PROC
;;;344    
;;;345    void recvChunk(void)
000000  b510              PUSH     {r4,lr}
;;;346    {
;;;347    	uint32_t chunk;
;;;348    
;;;349    	// reset timer
;;;350    	g_recvTimerStart = LPC_TIMER1->TC;
000002  4817              LDR      r0,|L17.96|
000004  6880              LDR      r0,[r0,#8]
000006  4917              LDR      r1,|L17.100|
000008  6008              STR      r0,[r1,#0]  ; g_recvTimerStart
;;;351    
;;;352    	if (g_recvOffset>=g_recvLen)
00000a  4817              LDR      r0,|L17.104|
00000c  6800              LDR      r0,[r0,#0]  ; g_recvOffset
00000e  4917              LDR      r1,|L17.108|
000010  6809              LDR      r1,[r1,#0]  ; g_recvLen
000012  4288              CMP      r0,r1
000014  d303              BCC      |L17.30|
;;;353    	{
;;;354    		g_recvComplete = 1;
000016  2001              MOVS     r0,#1
000018  4915              LDR      r1,|L17.112|
00001a  7008              STRB     r0,[r1,#0]
                  |L17.28|
;;;355    		return;
;;;356    	}
;;;357    
;;;358    	if (g_recvLen-g_recvOffset>=USB_MAX_CHUNK)
;;;359    		chunk = USB_MAX_CHUNK;
;;;360    	else
;;;361    		chunk = g_recvLen-g_recvOffset;
;;;362    	
;;;363    	
;;;364    	USB_ReadReqEP(USB_BULK_OUT_EP, (uint8_t *)g_recvData + g_recvOffset, chunk);
;;;365    
;;;366    	g_recvOffset += chunk;
;;;367    }
00001c  bd10              POP      {r4,pc}
                  |L17.30|
00001e  4813              LDR      r0,|L17.108|
000020  6800              LDR      r0,[r0,#0]            ;358  ; g_recvLen
000022  4911              LDR      r1,|L17.104|
000024  6809              LDR      r1,[r1,#0]            ;358  ; g_recvOffset
000026  1a40              SUBS     r0,r0,r1              ;358
000028  f5b04f80          CMP      r0,#0x4000            ;358
00002c  d302              BCC      |L17.52|
00002e  f44f4480          MOV      r4,#0x4000            ;359
000032  e004              B        |L17.62|
                  |L17.52|
000034  480d              LDR      r0,|L17.108|
000036  6800              LDR      r0,[r0,#0]            ;361  ; g_recvLen
000038  490b              LDR      r1,|L17.104|
00003a  6809              LDR      r1,[r1,#0]            ;361  ; g_recvOffset
00003c  1a44              SUBS     r4,r0,r1              ;361
                  |L17.62|
00003e  480d              LDR      r0,|L17.116|
000040  6800              LDR      r0,[r0,#0]            ;364  ; g_recvData
000042  4a09              LDR      r2,|L17.104|
000044  6812              LDR      r2,[r2,#0]            ;364  ; g_recvOffset
000046  1881              ADDS     r1,r0,r2              ;364
000048  4622              MOV      r2,r4                 ;364
00004a  2002              MOVS     r0,#2                 ;364
00004c  f7fffffe          BL       USB_ReadReqEP
000050  4805              LDR      r0,|L17.104|
000052  6800              LDR      r0,[r0,#0]            ;366  ; g_recvOffset
000054  4420              ADD      r0,r0,r4              ;366
000056  4904              LDR      r1,|L17.104|
000058  6008              STR      r0,[r1,#0]            ;366  ; g_recvOffset
00005a  bf00              NOP      
00005c  e7de              B        |L17.28|
;;;368    
                          ENDP

00005e  0000              DCW      0x0000
                  |L17.96|
                          DCD      0x40085000
                  |L17.100|
                          DCD      g_recvTimerStart
                  |L17.104|
                          DCD      g_recvOffset
                  |L17.108|
                          DCD      g_recvLen
                  |L17.112|
                          DCD      g_recvComplete
                  |L17.116|
                          DCD      g_recvData

                          AREA ||i.sendChunk||, CODE, READONLY, ALIGN=2

                  sendChunk PROC
;;;321    
;;;322    void sendChunk(void)
000000  b510              PUSH     {r4,lr}
;;;323    {
;;;324    	uint32_t chunk;
;;;325    
;;;326    	// reset timer
;;;327    	g_sendTimerStart = LPC_TIMER1->TC;
000002  4817              LDR      r0,|L18.96|
000004  6880              LDR      r0,[r0,#8]
000006  4917              LDR      r1,|L18.100|
000008  6008              STR      r0,[r1,#0]  ; g_sendTimerStart
;;;328    
;;;329    	if (g_sendOffset>=g_sendLen)
00000a  4817              LDR      r0,|L18.104|
00000c  6800              LDR      r0,[r0,#0]  ; g_sendOffset
00000e  4917              LDR      r1,|L18.108|
000010  6809              LDR      r1,[r1,#0]  ; g_sendLen
000012  4288              CMP      r0,r1
000014  d303              BCC      |L18.30|
;;;330    	{
;;;331    		g_sendComplete = 1;
000016  2001              MOVS     r0,#1
000018  4915              LDR      r1,|L18.112|
00001a  7008              STRB     r0,[r1,#0]
                  |L18.28|
;;;332    		return;
;;;333    	}
;;;334    
;;;335    	if (g_sendLen-g_sendOffset>=USB_MAX_CHUNK)
;;;336    		chunk = USB_MAX_CHUNK;
;;;337    	else
;;;338    		chunk = g_sendLen-g_sendOffset;
;;;339    	
;;;340    	USB_WriteEP(USB_BULK_IN_EP, (uint8_t *)g_sendData + g_sendOffset, chunk);
;;;341    
;;;342    	g_sendOffset += chunk;
;;;343    }
00001c  bd10              POP      {r4,pc}
                  |L18.30|
00001e  4813              LDR      r0,|L18.108|
000020  6800              LDR      r0,[r0,#0]            ;335  ; g_sendLen
000022  4911              LDR      r1,|L18.104|
000024  6809              LDR      r1,[r1,#0]            ;335  ; g_sendOffset
000026  1a40              SUBS     r0,r0,r1              ;335
000028  f5b04f80          CMP      r0,#0x4000            ;335
00002c  d302              BCC      |L18.52|
00002e  f44f4480          MOV      r4,#0x4000            ;336
000032  e004              B        |L18.62|
                  |L18.52|
000034  480d              LDR      r0,|L18.108|
000036  6800              LDR      r0,[r0,#0]            ;338  ; g_sendLen
000038  490b              LDR      r1,|L18.104|
00003a  6809              LDR      r1,[r1,#0]            ;338  ; g_sendOffset
00003c  1a44              SUBS     r4,r0,r1              ;338
                  |L18.62|
00003e  480d              LDR      r0,|L18.116|
000040  6800              LDR      r0,[r0,#0]            ;340  ; g_sendData
000042  4a09              LDR      r2,|L18.104|
000044  6812              LDR      r2,[r2,#0]            ;340  ; g_sendOffset
000046  1881              ADDS     r1,r0,r2              ;340
000048  4622              MOV      r2,r4                 ;340
00004a  2082              MOVS     r0,#0x82              ;340
00004c  f7fffffe          BL       USB_WriteEP
000050  4805              LDR      r0,|L18.104|
000052  6800              LDR      r0,[r0,#0]            ;342  ; g_sendOffset
000054  4420              ADD      r0,r0,r4              ;342
000056  4904              LDR      r1,|L18.104|
000058  6008              STR      r0,[r1,#0]            ;342  ; g_sendOffset
00005a  bf00              NOP      
00005c  e7de              B        |L18.28|
;;;344    
                          ENDP

00005e  0000              DCW      0x0000
                  |L18.96|
                          DCD      0x40085000
                  |L18.100|
                          DCD      g_sendTimerStart
                  |L18.104|
                          DCD      g_sendOffset
                  |L18.108|
                          DCD      g_sendLen
                  |L18.112|
                          DCD      g_sendComplete
                  |L18.116|
                          DCD      g_sendData

                          AREA ||i.testWrite||, CODE, READONLY, ALIGN=2

                  testWrite PROC
;;;199    
;;;200    void testWrite()
000000  b570              PUSH     {r4-r6,lr}
;;;201    {
;;;202    	static int flag = 0;
;;;203       	unsigned int *memory = (unsigned int *)0x10000000;
000002  f04f5580          MOV      r5,#0x10000000
;;;204    	int i;
;;;205    
;;;206    	if (!flag)
000006  480b              LDR      r0,|L19.52|
000008  6800              LDR      r0,[r0,#0]  ; flag
00000a  b960              CBNZ     r0,|L19.38|
;;;207    	{
;;;208    		for (i=0; i<0x2000; i++)
00000c  2400              MOVS     r4,#0
00000e  e004              B        |L19.26|
                  |L19.16|
;;;209    			memory[i] = (unsigned int)&memory[i];
000010  eb050084          ADD      r0,r5,r4,LSL #2
000014  f8450024          STR      r0,[r5,r4,LSL #2]
000018  1c64              ADDS     r4,r4,#1              ;208
                  |L19.26|
00001a  f5b45f00          CMP      r4,#0x2000            ;208
00001e  dbf7              BLT      |L19.16|
;;;210    		flag = 1;		
000020  2001              MOVS     r0,#1
000022  4904              LDR      r1,|L19.52|
000024  6008              STR      r0,[r1,#0]  ; flag
                  |L19.38|
;;;211    	}
;;;212    
;;;213    	USB_WriteEP(USB_BULK_IN_EP, (uint8_t *)memory, 0x4000);
000026  f44f4280          MOV      r2,#0x4000
00002a  4629              MOV      r1,r5
00002c  2082              MOVS     r0,#0x82
00002e  f7fffffe          BL       USB_WriteEP
;;;214    }
000032  bd70              POP      {r4-r6,pc}
;;;215    
                          ENDP

                  |L19.52|
                          DCD      flag

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  USB_P_EP
                          DCD      USB_EndPoint0
                          DCD      USB_EndPoint1
                          DCD      USB_EndPoint2
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=2

                  g_recvData
                          DCD      0x00000000
                  g_recvLen
                          DCD      0x00000000
                  g_recvOffset
                          DCD      0x00000000
                  g_recvComplete
00000c  00000000          DCB      0x00,0x00,0x00,0x00
                  g_recvTimerStart
                          DCD      0x00000000
                  g_sendData
                          DCD      0x00000000
                  g_sendLen
                          DCD      0x00000000
                  g_sendOffset
                          DCD      0x00000000
                  g_sendComplete
000020  00000000          DCB      0x00,0x00,0x00,0x00
                  g_sendTimerStart
                          DCD      0x00000000
                  flag
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "usbuser.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_usbuser_c_3d12303f____REV16|
#line 130 ".\\core_cmInstr.h"
|__asm___9_usbuser_c_3d12303f____REV16| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___9_usbuser_c_3d12303f____REVSH|
#line 144
|__asm___9_usbuser_c_3d12303f____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

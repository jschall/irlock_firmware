; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\chirp.o --asm_dir=.\ --list_dir=.\ --depend=.\chirp.d --cpu=Cortex-M0 --apcs=interwork -O0 -I. -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -D__MICROLIB -DCORE_M0 -DIPC_SLAVE -DPIXY --omf_browse=.\chirp.crf chirp.c]
                          THUMB

                          AREA ||i.assembleHelper||, CODE, READONLY, ALIGN=2

                  assembleHelper PROC
;;;133    
;;;134    int assembleHelper(va_list *args)
000000  b5f0              PUSH     {r4-r7,lr}
;;;135    {
000002  b085              SUB      sp,sp,#0x14
000004  4605              MOV      r5,r0
;;;136        int res;
;;;137        uint8_t type, origType;
;;;138        uint32_t i, si;
;;;139        int8_t *ptr;
;;;140    
;;;141        for (i=CRP_HEADER_LEN+g_len; TRUE;)
000006  488a              LDR      r0,|L1.560|
000008  6800              LDR      r0,[r0,#0]  ; g_len
00000a  4604              MOV      r4,r0
00000c  340c              ADDS     r4,r4,#0xc
00000e  e106              B        |L1.542|
                  |L1.16|
;;;142        {
;;;143    #if defined(__WIN32__) || defined(__arm)
;;;144            type = va_arg(*args, int);
000010  6829              LDR      r1,[r5,#0]
000012  1d08              ADDS     r0,r1,#4
000014  6028              STR      r0,[r5,#0]
000016  780e              LDRB     r6,[r1,#0]
;;;145    #else
;;;146            type = va_arg(*args, uint8_t);
;;;147    #endif
;;;148    
;;;149            if (type==END)
000018  2e00              CMP      r6,#0
00001a  d100              BNE      |L1.30|
;;;150                break;
00001c  e100              B        |L1.544|
                  |L1.30|
;;;151    
;;;152            si = i; // save index so we can skip over data if needed
00001e  9403              STR      r4,[sp,#0xc]
;;;153            g_buf[i++] = type;
000020  4620              MOV      r0,r4
000022  1c64              ADDS     r4,r4,#1
000024  4983              LDR      r1,|L1.564|
000026  6809              LDR      r1,[r1,#0]  ; g_buf
000028  540e              STRB     r6,[r1,r0]
;;;154    
;;;155            // treat hints like other types for now
;;;156            // but if gotoe isn't interested  in hints (m_hinformer=false),
;;;157            // we'll restore index to si and effectively skip data.
;;;158            origType = type;
00002a  4637              MOV      r7,r6
;;;159            type &= ~CRP_HINT;
00002c  2140              MOVS     r1,#0x40
00002e  4630              MOV      r0,r6
000030  4388              BICS     r0,r0,r1
000032  4606              MOV      r6,r0
;;;160    
;;;161            if (type==CRP_INT8)
000034  2e01              CMP      r6,#1
000036  d109              BNE      |L1.76|
;;;162            {
;;;163    #if defined(__WIN32__) || defined(__arm)
;;;164                int8_t val = va_arg(*args, int);
000038  682a              LDR      r2,[r5,#0]
00003a  1d11              ADDS     r1,r2,#4
00003c  6029              STR      r1,[r5,#0]
00003e  7811              LDRB     r1,[r2,#0]
000040  b248              SXTB     r0,r1
;;;165    #else
;;;166                int8_t val = va_arg(*args, int8_t);
;;;167    #endif
;;;168                *(int8_t *)(g_buf+i) = val;
000042  497c              LDR      r1,|L1.564|
000044  6809              LDR      r1,[r1,#0]  ; g_buf
000046  5508              STRB     r0,[r1,r4]
;;;169                i += 1;
000048  1c64              ADDS     r4,r4,#1
;;;170            }
00004a  e0d1              B        |L1.496|
                  |L1.76|
;;;171            else if (type==CRP_INT16)
00004c  2e02              CMP      r6,#2
00004e  d117              BNE      |L1.128|
;;;172            {
;;;173    #if defined(__WIN32__) || defined(__arm)
;;;174                int16_t val = va_arg(*args, int);
000050  682a              LDR      r2,[r5,#0]
000052  1d11              ADDS     r1,r2,#4
000054  6029              STR      r1,[r5,#0]
000056  8811              LDRH     r1,[r2,#0]
000058  b208              SXTH     r0,r1
;;;175    #else
;;;176                int16_t val = va_arg(*args, int16_t);
;;;177    #endif
;;;178                ALIGN(i, 2);
00005a  07e1              LSLS     r1,r4,#31
00005c  0fc9              LSRS     r1,r1,#31
00005e  2900              CMP      r1,#0
000060  d003              BEQ      |L1.106|
000062  0861              LSRS     r1,r4,#1
000064  0049              LSLS     r1,r1,#1
000066  1c89              ADDS     r1,r1,#2
000068  e000              B        |L1.108|
                  |L1.106|
00006a  4621              MOV      r1,r4
                  |L1.108|
00006c  460c              MOV      r4,r1
;;;179                // rewrite type so chirpGetType will work (even though we might add padding between type and data)
;;;180                g_buf[i-1] = origType;
00006e  1e61              SUBS     r1,r4,#1
000070  4a70              LDR      r2,|L1.564|
000072  6812              LDR      r2,[r2,#0]  ; g_buf
000074  5457              STRB     r7,[r2,r1]
;;;181                *(int16_t *)(g_buf+i) = val;
000076  496f              LDR      r1,|L1.564|
000078  6809              LDR      r1,[r1,#0]  ; g_buf
00007a  5308              STRH     r0,[r1,r4]
;;;182                i += 2;
00007c  1ca4              ADDS     r4,r4,#2
;;;183            }
00007e  e0b7              B        |L1.496|
                  |L1.128|
;;;184            else if (type==CRP_INT32 || origType==CRP_TYPE_HINT) // CRP_TYPE_HINT is a special case...
000080  2e04              CMP      r6,#4
000082  d001              BEQ      |L1.136|
000084  2f64              CMP      r7,#0x64
000086  d116              BNE      |L1.182|
                  |L1.136|
;;;185            {
;;;186                int32_t val = va_arg(*args, int32_t);
000088  682a              LDR      r2,[r5,#0]
00008a  1d11              ADDS     r1,r2,#4
00008c  6029              STR      r1,[r5,#0]
00008e  6810              LDR      r0,[r2,#0]
;;;187                ALIGN(i, 4);
000090  07a1              LSLS     r1,r4,#30
000092  0f89              LSRS     r1,r1,#30
000094  2900              CMP      r1,#0
000096  d003              BEQ      |L1.160|
000098  08a1              LSRS     r1,r4,#2
00009a  0089              LSLS     r1,r1,#2
00009c  1d09              ADDS     r1,r1,#4
00009e  e000              B        |L1.162|
                  |L1.160|
0000a0  4621              MOV      r1,r4
                  |L1.162|
0000a2  460c              MOV      r4,r1
;;;188                g_buf[i-1] = origType;
0000a4  1e61              SUBS     r1,r4,#1
0000a6  4a63              LDR      r2,|L1.564|
0000a8  6812              LDR      r2,[r2,#0]  ; g_buf
0000aa  5457              STRB     r7,[r2,r1]
;;;189                *(int32_t *)(g_buf+i) = val;
0000ac  4961              LDR      r1,|L1.564|
0000ae  6809              LDR      r1,[r1,#0]  ; g_buf
0000b0  5108              STR      r0,[r1,r4]
;;;190                i += 4;
0000b2  1d24              ADDS     r4,r4,#4
;;;191            }
0000b4  e09c              B        |L1.496|
                  |L1.182|
;;;192            else if (type==CRP_FLT32)
0000b6  2e14              CMP      r6,#0x14
0000b8  d120              BNE      |L1.252|
;;;193            {
;;;194    #if defined(__WIN32__) || defined(__arm)
;;;195                float val = va_arg(*args, double);
0000ba  6828              LDR      r0,[r5,#0]
0000bc  1dc0              ADDS     r0,r0,#7
0000be  08c0              LSRS     r0,r0,#3
0000c0  00c0              LSLS     r0,r0,#3
0000c2  4601              MOV      r1,r0
0000c4  3008              ADDS     r0,r0,#8
0000c6  6028              STR      r0,[r5,#0]
0000c8  680a              LDR      r2,[r1,#0]
0000ca  6849              LDR      r1,[r1,#4]
0000cc  4610              MOV      r0,r2
0000ce  f7fffffe          BL       __aeabi_d2f
0000d2  9001              STR      r0,[sp,#4]
;;;196    #else
;;;197                float val = va_arg(*args, float);
;;;198    #endif
;;;199                ALIGN(i, 4);
0000d4  07a0              LSLS     r0,r4,#30
0000d6  0f80              LSRS     r0,r0,#30
0000d8  2800              CMP      r0,#0
0000da  d003              BEQ      |L1.228|
0000dc  08a0              LSRS     r0,r4,#2
0000de  0080              LSLS     r0,r0,#2
0000e0  1d00              ADDS     r0,r0,#4
0000e2  e000              B        |L1.230|
                  |L1.228|
0000e4  4620              MOV      r0,r4
                  |L1.230|
0000e6  4604              MOV      r4,r0
;;;200                g_buf[i-1] = origType;
0000e8  1e60              SUBS     r0,r4,#1
0000ea  4952              LDR      r1,|L1.564|
0000ec  6809              LDR      r1,[r1,#0]  ; g_buf
0000ee  540f              STRB     r7,[r1,r0]
;;;201                *(float *)(g_buf+i) = val;
0000f0  4950              LDR      r1,|L1.564|
0000f2  9801              LDR      r0,[sp,#4]
0000f4  6809              LDR      r1,[r1,#0]  ; g_buf
0000f6  5108              STR      r0,[r1,r4]
;;;202                i += 4;
0000f8  1d24              ADDS     r4,r4,#4
;;;203            }
0000fa  e079              B        |L1.496|
                  |L1.252|
;;;204            else if (type==CRP_STRING)
0000fc  2ea1              CMP      r6,#0xa1
0000fe  d124              BNE      |L1.330|
;;;205            {
;;;206                int8_t *s = va_arg(*args, int8_t *);
000100  6829              LDR      r1,[r5,#0]
000102  1d08              ADDS     r0,r1,#4
000104  6028              STR      r0,[r5,#0]
000106  6808              LDR      r0,[r1,#0]
000108  9001              STR      r0,[sp,#4]
;;;207                uint32_t len = strlen((char *)s)+1; // include null
00010a  9801              LDR      r0,[sp,#4]
00010c  f7fffffe          BL       strlen
000110  1c40              ADDS     r0,r0,#1
000112  9000              STR      r0,[sp,#0]
;;;208    
;;;209                if (len+i > g_bufSize-CRP_BUFPAD && (res=reallocate(len+i))<0)
000114  9800              LDR      r0,[sp,#0]
000116  1901              ADDS     r1,r0,r4
000118  4847              LDR      r0,|L1.568|
00011a  6800              LDR      r0,[r0,#0]  ; g_bufSize
00011c  3808              SUBS     r0,r0,#8
00011e  4281              CMP      r1,r0
000120  d909              BLS      |L1.310|
000122  9900              LDR      r1,[sp,#0]
000124  1908              ADDS     r0,r1,r4
000126  f7fffffe          BL       reallocate
00012a  9004              STR      r0,[sp,#0x10]
00012c  2800              CMP      r0,#0
00012e  da02              BGE      |L1.310|
;;;210                    return res;
000130  9804              LDR      r0,[sp,#0x10]
                  |L1.306|
;;;211    
;;;212                memcpy(g_buf+i, s, len);
;;;213                i += len;
;;;214            }
;;;215            else if (type&CRP_ARRAY)
;;;216            {
;;;217                uint8_t size = type&0x0f;
;;;218                uint32_t len = va_arg(*args, int32_t);
;;;219    
;;;220                ALIGN(i, 4);
;;;221                g_buf[i-1] = origType;
;;;222                *(uint32_t *)(g_buf+i) = len;
;;;223                i += 4;
;;;224                ALIGN(i, size);
;;;225                len *= size; // scale by size of array elements
;;;226    
;;;227                if (len+i>g_bufSize-CRP_BUFPAD && (res=reallocate(len+i))<0)
;;;228                    return res;
;;;229    
;;;230                ptr = va_arg(*args, int8_t *);
;;;231                memcpy(g_buf+i, ptr, len);
;;;232                i += len;
;;;233            }
;;;234            else
;;;235                return CRP_RES_ERROR_PARSE;
;;;236    
;;;237            // skip hint data if we're not a source
;;;238            if (!g_hinformer && origType&CRP_HINT)
;;;239                i = si;
;;;240    
;;;241            if (i>g_bufSize-CRP_BUFPAD && (res=reallocate(g_bufSize))<0)
;;;242                return res;
;;;243        }
;;;244    
;;;245        // set length
;;;246        g_len = i-CRP_HEADER_LEN;
;;;247    
;;;248        return CRP_RES_OK;
;;;249    }
000132  b005              ADD      sp,sp,#0x14
000134  bdf0              POP      {r4-r7,pc}
                  |L1.310|
000136  493f              LDR      r1,|L1.564|
000138  6809              LDR      r1,[r1,#0]            ;212  ; g_buf
00013a  1908              ADDS     r0,r1,r4              ;212
00013c  9a00              LDR      r2,[sp,#0]            ;212
00013e  9901              LDR      r1,[sp,#4]            ;212
000140  f7fffffe          BL       __aeabi_memcpy
000144  9800              LDR      r0,[sp,#0]            ;213
000146  1824              ADDS     r4,r4,r0              ;213
000148  e052              B        |L1.496|
                  |L1.330|
00014a  2080              MOVS     r0,#0x80              ;215
00014c  4030              ANDS     r0,r0,r6              ;215
00014e  2800              CMP      r0,#0                 ;215
000150  d04b              BEQ      |L1.490|
000152  0730              LSLS     r0,r6,#28             ;217
000154  0f00              LSRS     r0,r0,#28             ;217
000156  9001              STR      r0,[sp,#4]            ;217
000158  6829              LDR      r1,[r5,#0]            ;218
00015a  1d08              ADDS     r0,r1,#4              ;218
00015c  6028              STR      r0,[r5,#0]            ;218
00015e  6808              LDR      r0,[r1,#0]            ;218
000160  9000              STR      r0,[sp,#0]            ;218
000162  07a0              LSLS     r0,r4,#30             ;220
000164  0f80              LSRS     r0,r0,#30             ;220
000166  2800              CMP      r0,#0                 ;220
000168  d003              BEQ      |L1.370|
00016a  08a0              LSRS     r0,r4,#2              ;220
00016c  0080              LSLS     r0,r0,#2              ;220
00016e  1d00              ADDS     r0,r0,#4              ;220
000170  e000              B        |L1.372|
                  |L1.370|
000172  4620              MOV      r0,r4                 ;220
                  |L1.372|
000174  4604              MOV      r4,r0                 ;220
000176  1e60              SUBS     r0,r4,#1              ;221
000178  492e              LDR      r1,|L1.564|
00017a  6809              LDR      r1,[r1,#0]            ;221  ; g_buf
00017c  540f              STRB     r7,[r1,r0]            ;221
00017e  492d              LDR      r1,|L1.564|
000180  9800              LDR      r0,[sp,#0]            ;222
000182  6809              LDR      r1,[r1,#0]            ;222  ; g_buf
000184  5108              STR      r0,[r1,r4]            ;222
000186  1d24              ADDS     r4,r4,#4              ;223
000188  9801              LDR      r0,[sp,#4]            ;224
00018a  1e40              SUBS     r0,r0,#1              ;224
00018c  4020              ANDS     r0,r0,r4              ;224
00018e  2800              CMP      r0,#0                 ;224
000190  d006              BEQ      |L1.416|
000192  9801              LDR      r0,[sp,#4]            ;224
000194  1e40              SUBS     r0,r0,#1              ;224
000196  4621              MOV      r1,r4                 ;224
000198  4381              BICS     r1,r1,r0              ;224
00019a  9801              LDR      r0,[sp,#4]            ;224
00019c  1808              ADDS     r0,r1,r0              ;224
00019e  e000              B        |L1.418|
                  |L1.416|
0001a0  4620              MOV      r0,r4                 ;224
                  |L1.418|
0001a2  4604              MOV      r4,r0                 ;224
0001a4  9901              LDR      r1,[sp,#4]            ;225
0001a6  9800              LDR      r0,[sp,#0]            ;225
0001a8  4348              MULS     r0,r1,r0              ;225
0001aa  9000              STR      r0,[sp,#0]            ;225
0001ac  9800              LDR      r0,[sp,#0]            ;227
0001ae  1901              ADDS     r1,r0,r4              ;227
0001b0  4821              LDR      r0,|L1.568|
0001b2  6800              LDR      r0,[r0,#0]            ;227  ; g_bufSize
0001b4  3808              SUBS     r0,r0,#8              ;227
0001b6  4281              CMP      r1,r0                 ;227
0001b8  d908              BLS      |L1.460|
0001ba  9900              LDR      r1,[sp,#0]            ;227
0001bc  1908              ADDS     r0,r1,r4              ;227
0001be  f7fffffe          BL       reallocate
0001c2  9004              STR      r0,[sp,#0x10]         ;227
0001c4  2800              CMP      r0,#0                 ;227
0001c6  da01              BGE      |L1.460|
0001c8  9804              LDR      r0,[sp,#0x10]         ;228
0001ca  e7b2              B        |L1.306|
                  |L1.460|
0001cc  6829              LDR      r1,[r5,#0]            ;230
0001ce  1d08              ADDS     r0,r1,#4              ;230
0001d0  6028              STR      r0,[r5,#0]            ;230
0001d2  6808              LDR      r0,[r1,#0]            ;230
0001d4  9002              STR      r0,[sp,#8]            ;230
0001d6  4917              LDR      r1,|L1.564|
0001d8  6809              LDR      r1,[r1,#0]            ;231  ; g_buf
0001da  1908              ADDS     r0,r1,r4              ;231
0001dc  9a00              LDR      r2,[sp,#0]            ;231
0001de  9902              LDR      r1,[sp,#8]            ;231
0001e0  f7fffffe          BL       __aeabi_memcpy
0001e4  9800              LDR      r0,[sp,#0]            ;232
0001e6  1824              ADDS     r4,r4,r0              ;232
0001e8  e002              B        |L1.496|
                  |L1.490|
0001ea  2002              MOVS     r0,#2                 ;235
0001ec  43c0              MVNS     r0,r0                 ;235
0001ee  e7a0              B        |L1.306|
                  |L1.496|
0001f0  4812              LDR      r0,|L1.572|
0001f2  6800              LDR      r0,[r0,#0]            ;238  ; g_hinformer
0001f4  2800              CMP      r0,#0                 ;238
0001f6  d104              BNE      |L1.514|
0001f8  2040              MOVS     r0,#0x40              ;238
0001fa  4038              ANDS     r0,r0,r7              ;238
0001fc  2800              CMP      r0,#0                 ;238
0001fe  d000              BEQ      |L1.514|
000200  9c03              LDR      r4,[sp,#0xc]          ;239
                  |L1.514|
000202  480d              LDR      r0,|L1.568|
000204  6800              LDR      r0,[r0,#0]            ;241  ; g_bufSize
000206  3808              SUBS     r0,r0,#8              ;241
000208  42a0              CMP      r0,r4                 ;241
00020a  d208              BCS      |L1.542|
00020c  480a              LDR      r0,|L1.568|
00020e  6800              LDR      r0,[r0,#0]            ;241  ; g_bufSize
000210  f7fffffe          BL       reallocate
000214  9004              STR      r0,[sp,#0x10]         ;241
000216  2800              CMP      r0,#0                 ;241
000218  da01              BGE      |L1.542|
00021a  9804              LDR      r0,[sp,#0x10]         ;242
00021c  e789              B        |L1.306|
                  |L1.542|
00021e  e6f7              B        |L1.16|
                  |L1.544|
000220  bf00              NOP                            ;150
000222  4620              MOV      r0,r4                 ;246
000224  380c              SUBS     r0,r0,#0xc            ;246
000226  4902              LDR      r1,|L1.560|
000228  6008              STR      r0,[r1,#0]            ;246  ; g_len
00022a  2000              MOVS     r0,#0                 ;248
00022c  e781              B        |L1.306|
;;;250    
                          ENDP

00022e  0000              DCW      0x0000
                  |L1.560|
                          DCD      g_len
                  |L1.564|
                          DCD      g_buf
                  |L1.568|
                          DCD      g_bufSize
                  |L1.572|
                          DCD      g_hinformer

                          AREA ||i.calcCrc||, CODE, READONLY, ALIGN=1

                  calcCrc PROC
;;;741    
;;;742    uint16_t calcCrc(uint8_t *buf, uint32_t len)
000000  b510              PUSH     {r4,lr}
;;;743    {
000002  4603              MOV      r3,r0
;;;744        uint32_t i;
;;;745        uint16_t crc;
;;;746    
;;;747        // this isn't a real crc, but it's cheap and prob good enough
;;;748        for (i=0, crc=0; i<len; i++)
000004  2200              MOVS     r2,#0
000006  2000              MOVS     r0,#0
000008  e003              B        |L2.18|
                  |L2.10|
;;;749            crc += buf[i];
00000a  5c9c              LDRB     r4,[r3,r2]
00000c  1824              ADDS     r4,r4,r0
00000e  b2a0              UXTH     r0,r4
000010  1c52              ADDS     r2,r2,#1              ;748
                  |L2.18|
000012  428a              CMP      r2,r1                 ;748
000014  d3f9              BCC      |L2.10|
;;;750        crc += len;
000016  1844              ADDS     r4,r0,r1
000018  b2a0              UXTH     r0,r4
;;;751    
;;;752        return crc;
;;;753    }
00001a  bd10              POP      {r4,pc}
;;;754    
                          ENDP


                          AREA ||i.chirpAssemble||, CODE, READONLY, ALIGN=1

                  chirpAssemble PROC
;;;121    
;;;122    int chirpAssemble(int dummy, ...)
000000  b40f              PUSH     {r0-r3}
;;;123    {
000002  b538              PUSH     {r3-r5,lr}
;;;124        int res;
;;;125        va_list args;
;;;126    
;;;127        va_start(args, dummy);
000004  a805              ADD      r0,sp,#0x14
000006  9000              STR      r0,[sp,#0]
;;;128        res = assembleHelper(&args);
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       assembleHelper
00000e  4604              MOV      r4,r0
;;;129        va_end(args);
000010  2000              MOVS     r0,#0
000012  9000              STR      r0,[sp,#0]
;;;130    
;;;131        return res;
000014  4620              MOV      r0,r4
;;;132    }
000016  bc38              POP      {r3-r5}
000018  bc08              POP      {r3}
00001a  b004              ADD      sp,sp,#0x10
00001c  4718              BX       r3
;;;133    
                          ENDP


                          AREA ||i.chirpCall||, CODE, READONLY, ALIGN=2

                  chirpCall PROC
;;;301    
;;;302    int chirpCall(uint8_t service, ChirpProc proc, ...)
000000  b40f              PUSH     {r0-r3}
;;;303    {
000002  b530              PUSH     {r4,r5,lr}
000004  b08f              SUB      sp,sp,#0x3c
000006  4604              MOV      r4,r0
;;;304        int res;
;;;305        uint8_t type;
;;;306        va_list args;
;;;307    
;;;308        // if it's just a regular chirpCall (not init or enumerate), we need to be connected
;;;309        if (!(service&CRP_CALL) && !g_connected)
000008  2080              MOVS     r0,#0x80
00000a  4020              ANDS     r0,r0,r4
00000c  2800              CMP      r0,#0
00000e  d109              BNE      |L4.36|
000010  482e              LDR      r0,|L4.204|
000012  6800              LDR      r0,[r0,#0]  ; g_connected
000014  2800              CMP      r0,#0
000016  d105              BNE      |L4.36|
;;;310            return CRP_RES_ERROR_NOT_CONNECTED;
000018  1f80              SUBS     r0,r0,#6
                  |L4.26|
;;;311    
;;;312        // parse args and assemble in g_buf
;;;313        va_start(args, proc);
;;;314        g_len = 0;
;;;315        if ((res=assembleHelper(&args))<0)
;;;316        {
;;;317            va_end(args);
;;;318            return res;
;;;319        }
;;;320    
;;;321        if (service&CRP_CALL) // special case for enumerate and init (internal calls)
;;;322        {
;;;323            type = service;
;;;324            service = SYNC;
;;;325        }
;;;326        else
;;;327            type = CRP_CALL;
;;;328    
;;;329        // linkSend chirpCall data
;;;330        if ((res=sendChirpRetry(type, proc))!=CRP_RES_OK) // convert chirpCall into response
;;;331        {
;;;332            va_end(args);
;;;333            return res;
;;;334        }
;;;335    
;;;336        // if the service is synchronous, linkReceive response while servicing other calls
;;;337        if (service==SYNC)
;;;338        {
;;;339            ChirpProc recvProc;
;;;340            void *recvArgs[CRP_MAX_ARGS+1];
;;;341    
;;;342            while(1)
;;;343            {
;;;344                if ((res=recvChirp(&type, &recvProc, recvArgs, TRUE))==CRP_RES_OK)
;;;345                {
;;;346                    if (type&CRP_RESPONSE)
;;;347                        break;
;;;348                    else // handle calls as they come in
;;;349                        handleChirp(type, recvProc, recvArgs);
;;;350                }
;;;351                else
;;;352                {
;;;353                    va_end(args);
;;;354                    return res;
;;;355                }
;;;356            }
;;;357    
;;;358            // load args
;;;359            if ((res=loadArgs(&args, recvArgs))<0)
;;;360            {
;;;361                va_end(args);
;;;362                return res;
;;;363            }
;;;364        }
;;;365    
;;;366    
;;;367        va_end(args);
;;;368        return CRP_RES_OK;
;;;369    }
00001a  b00f              ADD      sp,sp,#0x3c
00001c  bc30              POP      {r4,r5}
00001e  bc08              POP      {r3}
000020  b004              ADD      sp,sp,#0x10
000022  4718              BX       r3
                  |L4.36|
000024  a814              ADD      r0,sp,#0x50           ;313
000026  900d              STR      r0,[sp,#0x34]         ;313
000028  2000              MOVS     r0,#0                 ;314
00002a  4929              LDR      r1,|L4.208|
00002c  6008              STR      r0,[r1,#0]            ;314  ; g_len
00002e  a80d              ADD      r0,sp,#0x34           ;315
000030  f7fffffe          BL       assembleHelper
000034  1e05              SUBS     r5,r0,#0              ;315
000036  da03              BGE      |L4.64|
000038  2000              MOVS     r0,#0                 ;317
00003a  900d              STR      r0,[sp,#0x34]         ;317
00003c  4628              MOV      r0,r5                 ;318
00003e  e7ec              B        |L4.26|
                  |L4.64|
000040  2080              MOVS     r0,#0x80              ;321
000042  4020              ANDS     r0,r0,r4              ;321
000044  2800              CMP      r0,#0                 ;321
000046  d002              BEQ      |L4.78|
000048  940e              STR      r4,[sp,#0x38]         ;323
00004a  2400              MOVS     r4,#0                 ;324
00004c  e001              B        |L4.82|
                  |L4.78|
00004e  2080              MOVS     r0,#0x80              ;327
000050  900e              STR      r0,[sp,#0x38]         ;327
                  |L4.82|
000052  a810              ADD      r0,sp,#0x40           ;330
000054  210c              MOVS     r1,#0xc               ;330
000056  5e41              LDRSH    r1,[r0,r1]            ;330
000058  a808              ADD      r0,sp,#0x20           ;330
00005a  7e00              LDRB     r0,[r0,#0x18]         ;330
00005c  f7fffffe          BL       sendChirpRetry
000060  0005              MOVS     r5,r0                 ;330
000062  d003              BEQ      |L4.108|
000064  2000              MOVS     r0,#0                 ;332
000066  900d              STR      r0,[sp,#0x34]         ;332
000068  4628              MOV      r0,r5                 ;333
00006a  e7d6              B        |L4.26|
                  |L4.108|
00006c  2c00              CMP      r4,#0                 ;337
00006e  d129              BNE      |L4.196|
000070  e01b              B        |L4.170|
                  |L4.114|
000072  2301              MOVS     r3,#1                 ;344
000074  aa01              ADD      r2,sp,#4              ;344
000076  a90c              ADD      r1,sp,#0x30           ;344
000078  a80e              ADD      r0,sp,#0x38           ;344
00007a  f7fffffe          BL       recvChirp
00007e  0005              MOVS     r5,r0                 ;344
000080  d10f              BNE      |L4.162|
000082  a808              ADD      r0,sp,#0x20           ;346
000084  7e00              LDRB     r0,[r0,#0x18]         ;346
000086  2140              MOVS     r1,#0x40              ;346
000088  4008              ANDS     r0,r0,r1              ;346
00008a  2800              CMP      r0,#0                 ;346
00008c  d000              BEQ      |L4.144|
00008e  e00d              B        |L4.172|
                  |L4.144|
000090  aa01              ADD      r2,sp,#4              ;349
000092  4668              MOV      r0,sp                 ;349
000094  2130              MOVS     r1,#0x30              ;349
000096  5e41              LDRSH    r1,[r0,r1]            ;349
000098  a808              ADD      r0,sp,#0x20           ;349
00009a  7e00              LDRB     r0,[r0,#0x18]         ;349
00009c  f7fffffe          BL       handleChirp
0000a0  e003              B        |L4.170|
                  |L4.162|
0000a2  2000              MOVS     r0,#0                 ;353
0000a4  900d              STR      r0,[sp,#0x34]         ;353
0000a6  4628              MOV      r0,r5                 ;354
0000a8  e7b7              B        |L4.26|
                  |L4.170|
0000aa  e7e2              B        |L4.114|
                  |L4.172|
0000ac  bf00              NOP                            ;347
0000ae  a901              ADD      r1,sp,#4              ;359
0000b0  a80d              ADD      r0,sp,#0x34           ;359
0000b2  f7fffffe          BL       loadArgs
0000b6  1e05              SUBS     r5,r0,#0              ;359
0000b8  da03              BGE      |L4.194|
0000ba  2000              MOVS     r0,#0                 ;361
0000bc  900d              STR      r0,[sp,#0x34]         ;361
0000be  4628              MOV      r0,r5                 ;362
0000c0  e7ab              B        |L4.26|
                  |L4.194|
0000c2  bf00              NOP                            ;364
                  |L4.196|
0000c4  2000              MOVS     r0,#0                 ;367
0000c6  900d              STR      r0,[sp,#0x34]         ;367
0000c8  bf00              NOP                            ;368
0000ca  e7a6              B        |L4.26|
;;;370    
                          ENDP

                  |L4.204|
                          DCD      g_connected
                  |L4.208|
                          DCD      g_len

                          AREA ||i.chirpClose||, CODE, READONLY, ALIGN=2

                  chirpClose PROC
;;;111    
;;;112    int chirpClose()
000000  b510              PUSH     {r4,lr}
;;;113    {
;;;114    #ifndef CRP_SHARED_MEM
;;;115        free(g_buf);
;;;116    #endif
;;;117        free(g_procTable);
000002  4803              LDR      r0,|L5.16|
000004  6800              LDR      r0,[r0,#0]  ; g_procTable
000006  f7fffffe          BL       free
;;;118        return CRP_RES_OK;
00000a  2000              MOVS     r0,#0
;;;119    }
00000c  bd10              POP      {r4,pc}
;;;120    
                          ENDP

00000e  0000              DCW      0x0000
                  |L5.16|
                          DCD      g_procTable

                          AREA ||i.chirpGetProc||, CODE, READONLY, ALIGN=1

                  chirpGetProc PROC
;;;536    
;;;537    ChirpProc chirpGetProc(const char *procName, ProcPtr callback)
000000  b570              PUSH     {r4-r6,lr}
;;;538    {
000002  b086              SUB      sp,sp,#0x18
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;539        uint32_t res;
;;;540        ChirpProc cproc = -1;
000008  2600              MOVS     r6,#0
00000a  43f6              MVNS     r6,r6
;;;541    
;;;542        if (callback)
00000c  2d00              CMP      r5,#0
00000e  d004              BEQ      |L6.26|
;;;543            cproc = updateTable(procName, callback);
000010  4629              MOV      r1,r5
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       updateTable
000018  4606              MOV      r6,r0
                  |L6.26|
;;;544    
;;;545        if (chirpCall(CRP_CALL_ENUMERATE, 0,
00001a  2000              MOVS     r0,#0
00001c  a905              ADD      r1,sp,#0x14
00001e  9002              STR      r0,[sp,#8]
000020  9601              STR      r6,[sp,#4]
000022  9103              STR      r1,[sp,#0xc]
000024  9004              STR      r0,[sp,#0x10]
000026  2002              MOVS     r0,#2
000028  4623              MOV      r3,r4
00002a  22a1              MOVS     r2,#0xa1
00002c  2100              MOVS     r1,#0
00002e  9000              STR      r0,[sp,#0]
000030  20a0              MOVS     r0,#0xa0
000032  f7fffffe          BL       chirpCall
000036  2800              CMP      r0,#0
000038  db03              BLT      |L6.66|
;;;546                      STRING(procName), // linkSend name
;;;547                      INT16(cproc), // linkSend local index
;;;548                      END_SEND_ARGS,
;;;549                      &res, // get remote index
;;;550                      END_RECV_ARGS
;;;551                      )>=0)
;;;552            return res;
00003a  9805              LDR      r0,[sp,#0x14]
00003c  b200              SXTH     r0,r0
                  |L6.62|
;;;553    
;;;554        // a negative ChirpProc is an error
;;;555        return -1;
;;;556    }
00003e  b006              ADD      sp,sp,#0x18
000040  bd70              POP      {r4-r6,pc}
                  |L6.66|
000042  2000              MOVS     r0,#0                 ;555
000044  43c0              MVNS     r0,r0                 ;555
000046  e7fa              B        |L6.62|
;;;557    
                          ENDP


                          AREA ||i.chirpGetType||, CODE, READONLY, ALIGN=1

                  chirpGetType PROC
;;;736    
;;;737    uint8_t chirpGetType(void *arg)
000000  4601              MOV      r1,r0
;;;738    {
;;;739        return *((uint8_t *)arg - 1);
000002  4608              MOV      r0,r1
000004  3820              SUBS     r0,r0,#0x20
000006  7fc0              LDRB     r0,[r0,#0x1f]
;;;740    }
000008  4770              BX       lr
;;;741    
                          ENDP


                          AREA ||i.chirpInit||, CODE, READONLY, ALIGN=1

                  chirpInit PROC
;;;76     
;;;77     __weak int32_t chirpInit(void)
000000  2000              MOVS     r0,#0
;;;78     {
;;;79         return 0;
;;;80     }
000002  4770              BX       lr
;;;81     
                          ENDP


                          AREA ||i.chirpOpen||, CODE, READONLY, ALIGN=2

                  chirpOpen PROC
;;;89     
;;;90     int chirpOpen()
000000  b510              PUSH     {r4,lr}
;;;91     {
;;;92         g_connected = FALSE;
000002  2000              MOVS     r0,#0
000004  4914              LDR      r1,|L9.88|
000006  6008              STR      r0,[r1,#0]  ; g_connected
;;;93         g_remoteInit = FALSE;
000008  4914              LDR      r1,|L9.92|
00000a  6008              STR      r0,[r1,#0]  ; g_remoteInit
;;;94         g_hinformer = FALSE;
00000c  4914              LDR      r1,|L9.96|
00000e  6008              STR      r0,[r1,#0]  ; g_hinformer
;;;95     
;;;96     #ifndef CRP_SHARED_MEM
;;;97         g_bufSize = CRP_BUFSIZE;
;;;98         g_buf = malloc(g_bufSize);
;;;99     #else
;;;100        g_bufSize = linkGetFlags(LINK_FLAG_INDEX_SHARED_MEMORY_SIZE);
000010  2002              MOVS     r0,#2
000012  f7fffffe          BL       linkGetFlags
000016  4913              LDR      r1,|L9.100|
000018  6008              STR      r0,[r1,#0]  ; g_bufSize
;;;101        g_buf = (uint8_t *)linkGetFlags(LINK_FLAG_INDEX_SHARED_MEMORY_LOCATION);
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       linkGetFlags
000020  4911              LDR      r1,|L9.104|
000022  6008              STR      r0,[r1,#0]  ; g_buf
;;;102    #endif
;;;103    
;;;104        g_blkSize = linkBlockSize();
000024  f7fffffe          BL       linkBlockSize
000028  4910              LDR      r1,|L9.108|
00002a  8008              STRH     r0,[r1,#0]
;;;105        g_procTableSize = CRP_PROCTABLE_LEN;
00002c  2020              MOVS     r0,#0x20
00002e  4910              LDR      r1,|L9.112|
000030  8008              STRH     r0,[r1,#0]
;;;106        g_procTable = malloc(sizeof(ProcTableEntry)*g_procTableSize);
000032  8809              LDRH     r1,[r1,#0]  ; g_procTableSize
000034  220c              MOVS     r2,#0xc
000036  4351              MULS     r1,r2,r1
000038  4608              MOV      r0,r1
00003a  f7fffffe          BL       malloc
00003e  490d              LDR      r1,|L9.116|
000040  6008              STR      r0,[r1,#0]  ; g_procTable
;;;107        memset(g_procTable, 0, sizeof(ProcTableEntry)*g_procTableSize);
000042  480b              LDR      r0,|L9.112|
000044  8800              LDRH     r0,[r0,#0]  ; g_procTableSize
000046  220c              MOVS     r2,#0xc
000048  4350              MULS     r0,r2,r0
00004a  4601              MOV      r1,r0
00004c  4809              LDR      r0,|L9.116|
00004e  6800              LDR      r0,[r0,#0]  ; g_procTable
000050  f7fffffe          BL       __aeabi_memclr4
;;;108    
;;;109        return CRP_RES_OK;
000054  2000              MOVS     r0,#0
;;;110    }
000056  bd10              POP      {r4,pc}
;;;111    
                          ENDP

                  |L9.88|
                          DCD      g_connected
                  |L9.92|
                          DCD      g_remoteInit
                  |L9.96|
                          DCD      g_hinformer
                  |L9.100|
                          DCD      g_bufSize
                  |L9.104|
                          DCD      g_buf
                  |L9.108|
                          DCD      g_blkSize
                  |L9.112|
                          DCD      g_procTableSize
                  |L9.116|
                          DCD      g_procTable

                          AREA ||i.chirpRemoteInit||, CODE, READONLY, ALIGN=2

                  chirpRemoteInit PROC
;;;557    
;;;558    int chirpRemoteInit()
000000  b510              PUSH     {r4,lr}
;;;559    {
000002  b088              SUB      sp,sp,#0x20
;;;560        int res;
;;;561        uint32_t responseInt;
;;;562        uint8_t hinformer;
;;;563    
;;;564        if (g_remoteInit)
000004  4812              LDR      r0,|L10.80|
000006  6800              LDR      r0,[r0,#0]  ; g_remoteInit
000008  2800              CMP      r0,#0
00000a  d002              BEQ      |L10.18|
;;;565            return CRP_RES_OK;
00000c  2000              MOVS     r0,#0
                  |L10.14|
;;;566    
;;;567        res = chirpCall(CRP_CALL_INIT, 0,
;;;568                        INT16(g_blkSize), // linkSend block size
;;;569                        UINT8(0),         // send whether we're interested in hints or not (we're not)
;;;570                        END_SEND_ARGS,
;;;571                        &responseInt,
;;;572                        &hinformer,       // receive whether we should send hints
;;;573                        END_RECV_ARGS
;;;574                        );
;;;575        if (res>=0)
;;;576        {
;;;577            g_connected = TRUE;
;;;578            g_hinformer = hinformer;
;;;579            return responseInt;
;;;580        }
;;;581        return res;
;;;582    }
00000e  b008              ADD      sp,sp,#0x20
000010  bd10              POP      {r4,pc}
                  |L10.18|
000012  2000              MOVS     r0,#0                 ;567
000014  a906              ADD      r1,sp,#0x18           ;567
000016  aa07              ADD      r2,sp,#0x1c           ;567
000018  9002              STR      r0,[sp,#8]            ;567
00001a  9203              STR      r2,[sp,#0xc]          ;567
00001c  9104              STR      r1,[sp,#0x10]         ;567
00001e  9005              STR      r0,[sp,#0x14]         ;567
000020  2101              MOVS     r1,#1                 ;567
000022  9100              STR      r1,[sp,#0]            ;567
000024  9001              STR      r0,[sp,#4]            ;567
000026  480b              LDR      r0,|L10.84|
000028  8803              LDRH     r3,[r0,#0]            ;567  ; g_blkSize
00002a  2202              MOVS     r2,#2                 ;567
00002c  2100              MOVS     r1,#0                 ;567
00002e  20a1              MOVS     r0,#0xa1              ;567
000030  f7fffffe          BL       chirpCall
000034  4604              MOV      r4,r0                 ;567
000036  2c00              CMP      r4,#0                 ;575
000038  db08              BLT      |L10.76|
00003a  2001              MOVS     r0,#1                 ;577
00003c  4906              LDR      r1,|L10.88|
00003e  6008              STR      r0,[r1,#0]            ;577  ; g_connected
000040  4668              MOV      r0,sp                 ;578
000042  7e00              LDRB     r0,[r0,#0x18]         ;578
000044  4905              LDR      r1,|L10.92|
000046  6008              STR      r0,[r1,#0]            ;578  ; g_hinformer
000048  9807              LDR      r0,[sp,#0x1c]         ;579
00004a  e7e0              B        |L10.14|
                  |L10.76|
00004c  4620              MOV      r0,r4                 ;581
00004e  e7de              B        |L10.14|
;;;583    
                          ENDP

                  |L10.80|
                          DCD      g_remoteInit
                  |L10.84|
                          DCD      g_blkSize
                  |L10.88|
                          DCD      g_connected
                  |L10.92|
                          DCD      g_hinformer

                          AREA ||i.chirpService||, CODE, READONLY, ALIGN=1

                  chirpService PROC
;;;637    // service deals with calls and callbacks
;;;638    int chirpService()
000000  b510              PUSH     {r4,lr}
;;;639    {
000002  b08e              SUB      sp,sp,#0x38
;;;640        int i = 0;
000004  2400              MOVS     r4,#0
;;;641        uint8_t type;
;;;642        ChirpProc recvProc;
;;;643        void *args[CRP_MAX_ARGS+1];
;;;644    
;;;645        while(recvChirp(&type, &recvProc, args, FALSE)==CRP_RES_OK)
000006  e008              B        |L11.26|
                  |L11.8|
;;;646        {
;;;647            handleChirp(type, recvProc, args);
000008  aa01              ADD      r2,sp,#4
00000a  4668              MOV      r0,sp
00000c  2130              MOVS     r1,#0x30
00000e  5e41              LDRSH    r1,[r0,r1]
000010  a808              ADD      r0,sp,#0x20
000012  7d00              LDRB     r0,[r0,#0x14]
000014  f7fffffe          BL       handleChirp
;;;648            i++;
000018  1c64              ADDS     r4,r4,#1
                  |L11.26|
00001a  2300              MOVS     r3,#0                 ;645
00001c  aa01              ADD      r2,sp,#4              ;645
00001e  a90c              ADD      r1,sp,#0x30           ;645
000020  a80d              ADD      r0,sp,#0x34           ;645
000022  f7fffffe          BL       recvChirp
000026  2800              CMP      r0,#0                 ;645
000028  d0ee              BEQ      |L11.8|
;;;649        }
;;;650    
;;;651        return i;
00002a  4620              MOV      r0,r4
;;;652    }
00002c  b00e              ADD      sp,sp,#0x38
00002e  bd10              POP      {r4,pc}
;;;653    
                          ENDP


                          AREA ||i.chirpSetProc||, CODE, READONLY, ALIGN=1

                  chirpSetProc PROC
;;;583    
;;;584    int chirpSetProc(const char *procName, ProcPtr proc)
000000  b570              PUSH     {r4-r6,lr}
;;;585    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;586        if (updateTable(procName, proc)<0)
000006  4629              MOV      r1,r5
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       updateTable
00000e  2800              CMP      r0,#0
000010  da02              BGE      |L12.24|
;;;587            return CRP_RES_ERROR;
000012  2000              MOVS     r0,#0
000014  43c0              MVNS     r0,r0
                  |L12.22|
;;;588        return CRP_RES_OK;
;;;589    }
000016  bd70              POP      {r4-r6,pc}
                  |L12.24|
000018  2000              MOVS     r0,#0                 ;588
00001a  e7fc              B        |L12.22|
;;;590    
                          ENDP


                          AREA ||i.copyAlign||, CODE, READONLY, ALIGN=1

                  copyAlign PROC
;;;82     // assume that destination is aligned on the correct boundary and copy the source byte by byte
;;;83     void copyAlign(char *dest, const char *src, int size)
000000  b510              PUSH     {r4,lr}
;;;84     {
000002  4603              MOV      r3,r0
;;;85         int i;
;;;86         for (i=0; i<size; i++)
000004  2000              MOVS     r0,#0
000006  e002              B        |L13.14|
                  |L13.8|
;;;87             dest[i] = src[i];
000008  5c0c              LDRB     r4,[r1,r0]
00000a  541c              STRB     r4,[r3,r0]
00000c  1c40              ADDS     r0,r0,#1              ;86
                  |L13.14|
00000e  4290              CMP      r0,r2                 ;86
000010  dbfa              BLT      |L13.8|
;;;88     }
000012  bd10              POP      {r4,pc}
;;;89     
                          ENDP


                          AREA ||i.handleChirp||, CODE, READONLY, ALIGN=2

                  handleChirp PROC
;;;407    
;;;408    int handleChirp(uint8_t type, ChirpProc proc, void *args[])
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;409    {
000002  b08a              SUB      sp,sp,#0x28
000004  4607              MOV      r7,r0
000006  4614              MOV      r4,r2
;;;410        int res;
;;;411        uint32_t responseInt = 0;
000008  2000              MOVS     r0,#0
00000a  9008              STR      r0,[sp,#0x20]
;;;412        uint8_t n;
;;;413        ProcPtr ptr;
;;;414    
;;;415        // reset data in case there is a null response
;;;416        g_len = 4; // leave room for responseInt
00000c  2004              MOVS     r0,#4
00000e  4969              LDR      r1,|L14.436|
000010  6008              STR      r0,[r1,#0]  ; g_len
;;;417    
;;;418        // check for intrinsic calls
;;;419        if (type&CRP_INTRINSIC)
000012  2020              MOVS     r0,#0x20
000014  4038              ANDS     r0,r0,r7
000016  2800              CMP      r0,#0
000018  d013              BEQ      |L14.66|
;;;420        {
;;;421            if (type==CRP_CALL_ENUMERATE)
00001a  2fa0              CMP      r7,#0xa0
00001c  d105              BNE      |L14.42|
;;;422                responseInt = handleEnumerate((char *)args[0], (ChirpProc *)args[1]);
00001e  6861              LDR      r1,[r4,#4]
000020  6820              LDR      r0,[r4,#0]
000022  f7fffffe          BL       handleEnumerate
000026  9008              STR      r0,[sp,#0x20]
000028  e0a5              B        |L14.374|
                  |L14.42|
;;;423            else if (type==CRP_CALL_INIT)
00002a  2fa1              CMP      r7,#0xa1
00002c  d105              BNE      |L14.58|
;;;424                responseInt = handleInit((uint16_t *)args[0], (uint8_t *)args[1]);
00002e  6861              LDR      r1,[r4,#4]
000030  6820              LDR      r0,[r4,#0]
000032  f7fffffe          BL       handleInit
000036  9008              STR      r0,[sp,#0x20]
000038  e09d              B        |L14.374|
                  |L14.58|
;;;425            else
;;;426                return CRP_RES_ERROR;
00003a  2000              MOVS     r0,#0
00003c  43c0              MVNS     r0,r0
                  |L14.62|
;;;427        }
;;;428        else // normal chirpCall
;;;429        {
;;;430            if (proc>=g_procTableSize)
;;;431                return CRP_RES_ERROR; // index exceeded
;;;432    
;;;433            ptr = g_procTable[proc].procPtr;
;;;434            if (ptr==NULL)
;;;435                return CRP_RES_ERROR; // some chirps are not meant to be called in both directions
;;;436    
;;;437            // count args
;;;438            for (n=0; args[n]!=NULL; n++);
;;;439    
;;;440            if (n==0)
;;;441                responseInt = (*ptr)();
;;;442            else if (n==1)
;;;443                responseInt = (*(uint32_t(*)(void*))ptr)(args[0]);
;;;444            else if (n==2)
;;;445                responseInt = (*(uint32_t(*)(void*,void*))ptr)(args[0],args[1]);
;;;446            else if (n==3)
;;;447                responseInt = (*(uint32_t(*)(void*,void*,void*))ptr)(args[0],args[1],args[2]);
;;;448            else if (n==4)
;;;449                responseInt = (*(uint32_t(*)(void*,void*,void*,void*))ptr)(args[0],args[1],args[2],args[3]);
;;;450            else if (n==5)
;;;451                responseInt = (*(uint32_t(*)(void*,void*,void*,void*,void*))ptr)(args[0],args[1],args[2],args[3],args[4]);
;;;452            else if (n==6)
;;;453                responseInt = (*(uint32_t(*)(void*,void*,void*,void*,void*,void*))ptr)(args[0],args[1],args[2],args[3],args[4],args[5]);
;;;454            else if (n==7)
;;;455                responseInt = (*(uint32_t(*)(void*,void*,void*,void*,void*,void*,void*))ptr)(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);
;;;456            else if (n==8)
;;;457                responseInt = (*(uint32_t(*)(void*,void*,void*,void*,void*,void*,void*,void*))ptr)(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7]);
;;;458            else if (n==9)
;;;459                responseInt = (*(uint32_t(*)(void*,void*,void*,void*,void*,void*,void*,void*,void*))ptr)(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8]);
;;;460            else if (n==10)
;;;461                responseInt = (*(uint32_t(*)(void*,void*,void*,void*,void*,void*,void*,void*,void*,void *))ptr)(args[0],args[1],args[2],args[3],args[4],args[5],args[6],args[7],args[8],args[9]);
;;;462        }
;;;463    
;;;464        // if it's a chirp chirpCall, we need to linkSend back the result
;;;465        // result is in g_buf
;;;466        if (type&CRP_CALL)
;;;467        {
;;;468            // write responseInt
;;;469            *(uint32_t *)(g_buf+CRP_HEADER_LEN) = responseInt;
;;;470            // send response
;;;471            if ((res=sendChirpRetry(CRP_RESPONSE | (type&~CRP_CALL), g_procTable[proc].chirpProc))!=CRP_RES_OK) // convert chirpCall into response
;;;472                return res;
;;;473        }
;;;474    
;;;475        return CRP_RES_OK;
;;;476    }
00003e  b00d              ADD      sp,sp,#0x34
000040  bdf0              POP      {r4-r7,pc}
                  |L14.66|
000042  495d              LDR      r1,|L14.440|
000044  8809              LDRH     r1,[r1,#0]            ;430  ; g_procTableSize
000046  980b              LDR      r0,[sp,#0x2c]         ;430
000048  4288              CMP      r0,r1                 ;430
00004a  db02              BLT      |L14.82|
00004c  2000              MOVS     r0,#0                 ;431
00004e  43c0              MVNS     r0,r0                 ;431
000050  e7f5              B        |L14.62|
                  |L14.82|
000052  210c              MOVS     r1,#0xc               ;433
000054  980b              LDR      r0,[sp,#0x2c]         ;433
000056  4348              MULS     r0,r1,r0              ;433
000058  4958              LDR      r1,|L14.444|
00005a  6809              LDR      r1,[r1,#0]            ;433  ; g_procTable
00005c  1840              ADDS     r0,r0,r1              ;433
00005e  6846              LDR      r6,[r0,#4]            ;433
000060  2e00              CMP      r6,#0                 ;434
000062  d101              BNE      |L14.104|
000064  1e70              SUBS     r0,r6,#1              ;435
000066  e7ea              B        |L14.62|
                  |L14.104|
000068  2500              MOVS     r5,#0                 ;438
00006a  e001              B        |L14.112|
                  |L14.108|
00006c  1c68              ADDS     r0,r5,#1              ;438
00006e  b2c5              UXTB     r5,r0                 ;438
                  |L14.112|
000070  00a8              LSLS     r0,r5,#2              ;438
000072  5820              LDR      r0,[r4,r0]            ;438
000074  2800              CMP      r0,#0                 ;438
000076  d1f9              BNE      |L14.108|
000078  2d00              CMP      r5,#0                 ;440
00007a  d102              BNE      |L14.130|
00007c  47b0              BLX      r6                    ;441
00007e  9008              STR      r0,[sp,#0x20]         ;441
000080  e079              B        |L14.374|
                  |L14.130|
000082  2d01              CMP      r5,#1                 ;442
000084  d103              BNE      |L14.142|
000086  6820              LDR      r0,[r4,#0]            ;443
000088  47b0              BLX      r6                    ;443
00008a  9008              STR      r0,[sp,#0x20]         ;443
00008c  e073              B        |L14.374|
                  |L14.142|
00008e  2d02              CMP      r5,#2                 ;444
000090  d104              BNE      |L14.156|
000092  6861              LDR      r1,[r4,#4]            ;445
000094  6820              LDR      r0,[r4,#0]            ;445
000096  47b0              BLX      r6                    ;445
000098  9008              STR      r0,[sp,#0x20]         ;445
00009a  e06c              B        |L14.374|
                  |L14.156|
00009c  2d03              CMP      r5,#3                 ;446
00009e  d104              BNE      |L14.170|
0000a0  4620              MOV      r0,r4                 ;447
0000a2  c807              LDM      r0,{r0-r2}            ;447
0000a4  47b0              BLX      r6                    ;447
0000a6  9008              STR      r0,[sp,#0x20]         ;447
0000a8  e065              B        |L14.374|
                  |L14.170|
0000aa  2d04              CMP      r5,#4                 ;448
0000ac  d106              BNE      |L14.188|
0000ae  1d21              ADDS     r1,r4,#4              ;449
0000b0  c90e              LDM      r1,{r1-r3}            ;449
0000b2  9107              STR      r1,[sp,#0x1c]         ;449
0000b4  6820              LDR      r0,[r4,#0]            ;449
0000b6  47b0              BLX      r6                    ;449
0000b8  9008              STR      r0,[sp,#0x20]         ;449
0000ba  e05c              B        |L14.374|
                  |L14.188|
0000bc  2d05              CMP      r5,#5                 ;450
0000be  d108              BNE      |L14.210|
0000c0  6920              LDR      r0,[r4,#0x10]         ;451
0000c2  9000              STR      r0,[sp,#0]            ;451
0000c4  1d21              ADDS     r1,r4,#4              ;451
0000c6  c90e              LDM      r1,{r1-r3}            ;451
0000c8  9107              STR      r1,[sp,#0x1c]         ;451
0000ca  6820              LDR      r0,[r4,#0]            ;451
0000cc  47b0              BLX      r6                    ;451
0000ce  9008              STR      r0,[sp,#0x20]         ;451
0000d0  e051              B        |L14.374|
                  |L14.210|
0000d2  2d06              CMP      r5,#6                 ;452
0000d4  d109              BNE      |L14.234|
0000d6  6961              LDR      r1,[r4,#0x14]         ;453
0000d8  6920              LDR      r0,[r4,#0x10]         ;453
0000da  9101              STR      r1,[sp,#4]            ;453
0000dc  9000              STR      r0,[sp,#0]            ;453
0000de  4620              MOV      r0,r4                 ;453
0000e0  c80f              LDM      r0,{r0-r3}            ;453
0000e2  9007              STR      r0,[sp,#0x1c]         ;453
0000e4  47b0              BLX      r6                    ;453
0000e6  9008              STR      r0,[sp,#0x20]         ;453
0000e8  e045              B        |L14.374|
                  |L14.234|
0000ea  2d07              CMP      r5,#7                 ;454
0000ec  d10d              BNE      |L14.266|
0000ee  6962              LDR      r2,[r4,#0x14]         ;455
0000f0  6921              LDR      r1,[r4,#0x10]         ;455
0000f2  69a0              LDR      r0,[r4,#0x18]         ;455
0000f4  9201              STR      r2,[sp,#4]            ;455
0000f6  9100              STR      r1,[sp,#0]            ;455
0000f8  9002              STR      r0,[sp,#8]            ;455
0000fa  68e3              LDR      r3,[r4,#0xc]          ;455
0000fc  68a2              LDR      r2,[r4,#8]            ;455
0000fe  9207              STR      r2,[sp,#0x1c]         ;455
000100  6861              LDR      r1,[r4,#4]            ;455
000102  6820              LDR      r0,[r4,#0]            ;455
000104  47b0              BLX      r6                    ;455
000106  9008              STR      r0,[sp,#0x20]         ;455
000108  e035              B        |L14.374|
                  |L14.266|
00010a  2d08              CMP      r5,#8                 ;456
00010c  d10d              BNE      |L14.298|
00010e  6963              LDR      r3,[r4,#0x14]         ;457
000110  6922              LDR      r2,[r4,#0x10]         ;457
000112  69a1              LDR      r1,[r4,#0x18]         ;457
000114  69e0              LDR      r0,[r4,#0x1c]         ;457
000116  9301              STR      r3,[sp,#4]            ;457
000118  9200              STR      r2,[sp,#0]            ;457
00011a  9102              STR      r1,[sp,#8]            ;457
00011c  9003              STR      r0,[sp,#0xc]          ;457
00011e  4620              MOV      r0,r4                 ;457
000120  c80f              LDM      r0,{r0-r3}            ;457
000122  9007              STR      r0,[sp,#0x1c]         ;457
000124  47b0              BLX      r6                    ;457
000126  9008              STR      r0,[sp,#0x20]         ;457
000128  e025              B        |L14.374|
                  |L14.298|
00012a  2d09              CMP      r5,#9                 ;458
00012c  d110              BNE      |L14.336|
00012e  69a3              LDR      r3,[r4,#0x18]         ;459
000130  6962              LDR      r2,[r4,#0x14]         ;459
000132  69e1              LDR      r1,[r4,#0x1c]         ;459
000134  6a20              LDR      r0,[r4,#0x20]         ;459
000136  9302              STR      r3,[sp,#8]            ;459
000138  9201              STR      r2,[sp,#4]            ;459
00013a  9103              STR      r1,[sp,#0xc]          ;459
00013c  9004              STR      r0,[sp,#0x10]         ;459
00013e  6920              LDR      r0,[r4,#0x10]         ;459
000140  9000              STR      r0,[sp,#0]            ;459
000142  1d21              ADDS     r1,r4,#4              ;459
000144  c90e              LDM      r1,{r1-r3}            ;459
000146  9107              STR      r1,[sp,#0x1c]         ;459
000148  6820              LDR      r0,[r4,#0]            ;459
00014a  47b0              BLX      r6                    ;459
00014c  9008              STR      r0,[sp,#0x20]         ;459
00014e  e012              B        |L14.374|
                  |L14.336|
000150  2d0a              CMP      r5,#0xa               ;460
000152  d110              BNE      |L14.374|
000154  69e3              LDR      r3,[r4,#0x1c]         ;461
000156  69a2              LDR      r2,[r4,#0x18]         ;461
000158  6a21              LDR      r1,[r4,#0x20]         ;461
00015a  6a60              LDR      r0,[r4,#0x24]         ;461
00015c  9303              STR      r3,[sp,#0xc]          ;461
00015e  9202              STR      r2,[sp,#8]            ;461
000160  9104              STR      r1,[sp,#0x10]         ;461
000162  9005              STR      r0,[sp,#0x14]         ;461
000164  6961              LDR      r1,[r4,#0x14]         ;461
000166  6920              LDR      r0,[r4,#0x10]         ;461
000168  9101              STR      r1,[sp,#4]            ;461
00016a  9000              STR      r0,[sp,#0]            ;461
00016c  4620              MOV      r0,r4                 ;461
00016e  c80f              LDM      r0,{r0-r3}            ;461
000170  9007              STR      r0,[sp,#0x1c]         ;461
000172  47b0              BLX      r6                    ;461
000174  9008              STR      r0,[sp,#0x20]         ;461
                  |L14.374|
000176  2080              MOVS     r0,#0x80              ;466
000178  4038              ANDS     r0,r0,r7              ;466
00017a  2800              CMP      r0,#0                 ;466
00017c  d018              BEQ      |L14.432|
00017e  4910              LDR      r1,|L14.448|
000180  9808              LDR      r0,[sp,#0x20]         ;469
000182  6809              LDR      r1,[r1,#0]            ;469  ; g_buf
000184  60c8              STR      r0,[r1,#0xc]          ;469
000186  230c              MOVS     r3,#0xc               ;471
000188  9a0b              LDR      r2,[sp,#0x2c]         ;471
00018a  435a              MULS     r2,r3,r2              ;471
00018c  4b0b              LDR      r3,|L14.444|
00018e  681b              LDR      r3,[r3,#0]            ;471  ; g_procTable
000190  18d2              ADDS     r2,r2,r3              ;471
000192  2108              MOVS     r1,#8                 ;471
000194  5e51              LDRSH    r1,[r2,r1]            ;471
000196  463a              MOV      r2,r7                 ;471
000198  2380              MOVS     r3,#0x80              ;471
00019a  439a              BICS     r2,r2,r3              ;471
00019c  2340              MOVS     r3,#0x40              ;471
00019e  431a              ORRS     r2,r2,r3              ;471
0001a0  4610              MOV      r0,r2                 ;471
0001a2  f7fffffe          BL       sendChirpRetry
0001a6  9009              STR      r0,[sp,#0x24]         ;471
0001a8  2800              CMP      r0,#0                 ;471
0001aa  d001              BEQ      |L14.432|
0001ac  9809              LDR      r0,[sp,#0x24]         ;472
0001ae  e746              B        |L14.62|
                  |L14.432|
0001b0  2000              MOVS     r0,#0                 ;475
0001b2  e744              B        |L14.62|
;;;477    
                          ENDP

                  |L14.436|
                          DCD      g_len
                  |L14.440|
                          DCD      g_procTableSize
                  |L14.444|
                          DCD      g_procTable
                  |L14.448|
                          DCD      g_buf

                          AREA ||i.handleEnumerate||, CODE, READONLY, ALIGN=2

                  handleEnumerate PROC
;;;590    
;;;591    int32_t handleEnumerate(char *procName, ChirpProc *callback)
000000  b570              PUSH     {r4-r6,lr}
;;;592    {
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;593        ChirpProc proc;
;;;594        // lookup in table
;;;595        proc = lookupTable(procName);
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       lookupTable
00000c  4605              MOV      r5,r0
;;;596        // set remote index in table
;;;597        g_procTable[proc].chirpProc = *callback;
00000e  8821              LDRH     r1,[r4,#0]
000010  200c              MOVS     r0,#0xc
000012  4368              MULS     r0,r5,r0
000014  4a02              LDR      r2,|L15.32|
000016  6812              LDR      r2,[r2,#0]  ; g_procTable
000018  1880              ADDS     r0,r0,r2
00001a  8101              STRH     r1,[r0,#8]
;;;598    
;;;599        return proc;
00001c  4628              MOV      r0,r5
;;;600    }
00001e  bd70              POP      {r4-r6,pc}
;;;601    
                          ENDP

                  |L15.32|
                          DCD      g_procTable

                          AREA ||i.handleInit||, CODE, READONLY, ALIGN=2

                  handleInit PROC
;;;601    
;;;602    int32_t handleInit(uint16_t *blkSize, uint8_t *hinformer)
000000  b5f8              PUSH     {r3-r7,lr}
;;;603    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;604        int32_t responseInt;
;;;605    
;;;606        g_remoteInit = TRUE;
000006  2001              MOVS     r0,#1
000008  490c              LDR      r1,|L16.60|
00000a  6008              STR      r0,[r1,#0]  ; g_remoteInit
;;;607        responseInt = chirpInit();
00000c  f7fffffe          BL       chirpInit
000010  4606              MOV      r6,r0
;;;608        g_remoteInit = FALSE;
000012  2000              MOVS     r0,#0
000014  4909              LDR      r1,|L16.60|
000016  6008              STR      r0,[r1,#0]  ; g_remoteInit
;;;609        g_connected = TRUE;
000018  2001              MOVS     r0,#1
00001a  4909              LDR      r1,|L16.64|
00001c  6008              STR      r0,[r1,#0]  ; g_connected
;;;610        g_blkSize = *blkSize;  // get block size, write it
00001e  8820              LDRH     r0,[r4,#0]
000020  4908              LDR      r1,|L16.68|
000022  8008              STRH     r0,[r1,#0]
;;;611        g_hinformer = *hinformer;
000024  7828              LDRB     r0,[r5,#0]
000026  4908              LDR      r1,|L16.72|
000028  6008              STR      r0,[r1,#0]  ; g_hinformer
;;;612    
;;;613        CRP_RETURN(UINT8(0), END);
00002a  2000              MOVS     r0,#0
00002c  4603              MOV      r3,r0
00002e  4602              MOV      r2,r0
000030  2101              MOVS     r1,#1
000032  9000              STR      r0,[sp,#0]
000034  f7fffffe          BL       chirpAssemble
;;;614    
;;;615        return responseInt;
000038  4630              MOV      r0,r6
;;;616    
;;;617    }
00003a  bdf8              POP      {r3-r7,pc}
;;;618    
                          ENDP

                  |L16.60|
                          DCD      g_remoteInit
                  |L16.64|
                          DCD      g_connected
                  |L16.68|
                          DCD      g_blkSize
                  |L16.72|
                          DCD      g_hinformer

                          AREA ||i.linkBlockSize||, CODE, READONLY, ALIGN=1

                  linkBlockSize PROC
;;;66     // for gcc-- void __attribute__((weak)) foo()
;;;67     __weak uint32_t linkBlockSize()
000000  2001              MOVS     r0,#1
;;;68     {
;;;69         return CRP_BLK_SIZE;
000002  0240              LSLS     r0,r0,#9
;;;70     }
000004  4770              BX       lr
;;;71     
                          ENDP


                          AREA ||i.linkGetFlags||, CODE, READONLY, ALIGN=1

                  linkGetFlags PROC
;;;71     
;;;72     __weak uint32_t linkGetFlags(uint8_t index)
000000  4601              MOV      r1,r0
;;;73     {
;;;74         return 0;
000002  2000              MOVS     r0,#0
;;;75     }
000004  4770              BX       lr
;;;76     
                          ENDP


                          AREA ||i.loadArgs||, CODE, READONLY, ALIGN=1

                  loadArgs PROC
;;;256    // chirp will write the * pointer value into your ** pointer.
;;;257    int loadArgs(va_list *args, void *recvArgs[])
000000  b5f0              PUSH     {r4-r7,lr}
;;;258    {
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;259        int i;
;;;260        uint8_t type, size;
;;;261        void **recvArg;
;;;262    
;;;263        for (i=0; recvArgs[i]!=NULL && i<CRP_MAX_ARGS; i++)
000006  2300              MOVS     r3,#0
000008  e042              B        |L19.144|
                  |L19.10|
;;;264        {
;;;265            type = chirpGetType(recvArgs[i]);
00000a  0099              LSLS     r1,r3,#2
00000c  5860              LDR      r0,[r4,r1]
00000e  f7fffffe          BL       chirpGetType
000012  4606              MOV      r6,r0
;;;266            recvArg = va_arg(*args, void **);
000014  6811              LDR      r1,[r2,#0]
000016  1d08              ADDS     r0,r1,#4
000018  6010              STR      r0,[r2,#0]
00001a  680d              LDR      r5,[r1,#0]
;;;267            if (recvArg==NULL)
00001c  2d00              CMP      r5,#0
00001e  d101              BNE      |L19.36|
;;;268                return CRP_RES_ERROR_PARSE;
000020  1ee8              SUBS     r0,r5,#3
                  |L19.34|
;;;269    
;;;270            if (!(type&CRP_ARRAY)) // if we're a scalar
;;;271            {
;;;272                size = type&0x0f;
;;;273                if (size==1) *(uint8_t *)recvArg = *(uint8_t *)recvArgs[i];
;;;274                else if (size==2) *(uint16_t *)recvArg = *(uint16_t *)recvArgs[i];
;;;275                else if (size==4) *(uint32_t *)recvArg = *(uint32_t *)recvArgs[i];
;;;276                //else if (size==8) *recvArg = *(double *)recvArgs[i];
;;;277                else return CRP_RES_ERROR_PARSE;
;;;278            }
;;;279            else // we're an array
;;;280            {
;;;281                if (type==CRP_STRING)
;;;282                    *(char **)recvArg = (char *)recvArgs[i];
;;;283                else
;;;284                {
;;;285                    *(uint32_t *)recvArg = *(uint32_t *)recvArgs[i++];
;;;286                    recvArg = va_arg(*args, void **);
;;;287                    if (recvArg==NULL)
;;;288                        return CRP_RES_ERROR_PARSE;
;;;289                    *(void **)recvArg = recvArgs[i];
;;;290                }
;;;291            }
;;;292        }
;;;293        // check to see if last arg is NULL, if not, we have a parse error
;;;294        // if the arg isn't null, it means the caller is expecting data to be
;;;295        // put there.  If data isn't put there, and the caller dereferences, segfault
;;;296        if (va_arg(*args, void **)!=NULL)
;;;297            return CRP_RES_ERROR_PARSE;
;;;298    
;;;299        return CRP_RES_OK;
;;;300    }
000022  bdf0              POP      {r4-r7,pc}
                  |L19.36|
000024  2080              MOVS     r0,#0x80              ;270
000026  4030              ANDS     r0,r0,r6              ;270
000028  2800              CMP      r0,#0                 ;270
00002a  d119              BNE      |L19.96|
00002c  0737              LSLS     r7,r6,#28             ;272
00002e  0f3f              LSRS     r7,r7,#28             ;272
000030  2f01              CMP      r7,#1                 ;273
000032  d104              BNE      |L19.62|
000034  0098              LSLS     r0,r3,#2              ;273
000036  5820              LDR      r0,[r4,r0]            ;273
000038  7800              LDRB     r0,[r0,#0]            ;273
00003a  7028              STRB     r0,[r5,#0]            ;273
00003c  e027              B        |L19.142|
                  |L19.62|
00003e  2f02              CMP      r7,#2                 ;274
000040  d104              BNE      |L19.76|
000042  0098              LSLS     r0,r3,#2              ;274
000044  5820              LDR      r0,[r4,r0]            ;274
000046  8800              LDRH     r0,[r0,#0]            ;274
000048  8028              STRH     r0,[r5,#0]            ;274
00004a  e020              B        |L19.142|
                  |L19.76|
00004c  2f04              CMP      r7,#4                 ;275
00004e  d104              BNE      |L19.90|
000050  0098              LSLS     r0,r3,#2              ;275
000052  5820              LDR      r0,[r4,r0]            ;275
000054  6800              LDR      r0,[r0,#0]            ;275
000056  6028              STR      r0,[r5,#0]            ;275
000058  e019              B        |L19.142|
                  |L19.90|
00005a  2002              MOVS     r0,#2                 ;277
00005c  43c0              MVNS     r0,r0                 ;277
00005e  e7e0              B        |L19.34|
                  |L19.96|
000060  2ea1              CMP      r6,#0xa1              ;281
000062  d103              BNE      |L19.108|
000064  0098              LSLS     r0,r3,#2              ;282
000066  5820              LDR      r0,[r4,r0]            ;282
000068  6028              STR      r0,[r5,#0]            ;282
00006a  e010              B        |L19.142|
                  |L19.108|
00006c  4618              MOV      r0,r3                 ;285
00006e  1c5b              ADDS     r3,r3,#1              ;285
000070  0080              LSLS     r0,r0,#2              ;285
000072  5820              LDR      r0,[r4,r0]            ;285
000074  6800              LDR      r0,[r0,#0]            ;285
000076  6028              STR      r0,[r5,#0]            ;285
000078  6811              LDR      r1,[r2,#0]            ;286
00007a  1d08              ADDS     r0,r1,#4              ;286
00007c  6010              STR      r0,[r2,#0]            ;286
00007e  680d              LDR      r5,[r1,#0]            ;286
000080  2d00              CMP      r5,#0                 ;287
000082  d101              BNE      |L19.136|
000084  1ee8              SUBS     r0,r5,#3              ;288
000086  e7cc              B        |L19.34|
                  |L19.136|
000088  0098              LSLS     r0,r3,#2              ;289
00008a  5820              LDR      r0,[r4,r0]            ;289
00008c  6028              STR      r0,[r5,#0]            ;289
                  |L19.142|
00008e  1c5b              ADDS     r3,r3,#1              ;263
                  |L19.144|
000090  0098              LSLS     r0,r3,#2              ;263
000092  5820              LDR      r0,[r4,r0]            ;263
000094  2800              CMP      r0,#0                 ;263
000096  d001              BEQ      |L19.156|
000098  2b0a              CMP      r3,#0xa               ;263
00009a  dbb6              BLT      |L19.10|
                  |L19.156|
00009c  6811              LDR      r1,[r2,#0]            ;296
00009e  1d08              ADDS     r0,r1,#4              ;296
0000a0  6010              STR      r0,[r2,#0]            ;296
0000a2  6808              LDR      r0,[r1,#0]            ;296
0000a4  2800              CMP      r0,#0                 ;296
0000a6  d002              BEQ      |L19.174|
0000a8  2002              MOVS     r0,#2                 ;297
0000aa  43c0              MVNS     r0,r0                 ;297
0000ac  e7b9              B        |L19.34|
                  |L19.174|
0000ae  2000              MOVS     r0,#0                 ;299
0000b0  e7b7              B        |L19.34|
;;;301    
                          ENDP


                          AREA ||i.lookupTable||, CODE, READONLY, ALIGN=2

                  lookupTable PROC
;;;497    
;;;498    ChirpProc lookupTable(const char *procName)
000000  b570              PUSH     {r4-r6,lr}
;;;499    {
000002  4605              MOV      r5,r0
;;;500        ChirpProc i;
;;;501    
;;;502        for(i=0; i<g_procTableSize; i++)
000004  2400              MOVS     r4,#0
000006  e014              B        |L20.50|
                  |L20.8|
;;;503        {
;;;504            if (g_procTable[i].procName!=NULL && strcmp(g_procTable[i].procName, procName)==0)
000008  200c              MOVS     r0,#0xc
00000a  4360              MULS     r0,r4,r0
00000c  490c              LDR      r1,|L20.64|
00000e  6809              LDR      r1,[r1,#0]  ; g_procTable
000010  5808              LDR      r0,[r1,r0]
000012  2800              CMP      r0,#0
000014  d00b              BEQ      |L20.46|
000016  210c              MOVS     r1,#0xc
000018  4361              MULS     r1,r4,r1
00001a  4a09              LDR      r2,|L20.64|
00001c  6812              LDR      r2,[r2,#0]  ; g_procTable
00001e  5850              LDR      r0,[r2,r1]
000020  4629              MOV      r1,r5
000022  f7fffffe          BL       strcmp
000026  2800              CMP      r0,#0
000028  d101              BNE      |L20.46|
;;;505                return i;
00002a  4620              MOV      r0,r4
                  |L20.44|
;;;506        }
;;;507        return -1;
;;;508    }
00002c  bd70              POP      {r4-r6,pc}
                  |L20.46|
00002e  1c60              ADDS     r0,r4,#1              ;502
000030  b204              SXTH     r4,r0                 ;502
                  |L20.50|
000032  4804              LDR      r0,|L20.68|
000034  8800              LDRH     r0,[r0,#0]            ;502  ; g_procTableSize
000036  4284              CMP      r4,r0                 ;502
000038  dbe6              BLT      |L20.8|
00003a  2000              MOVS     r0,#0                 ;507
00003c  43c0              MVNS     r0,r0                 ;507
00003e  e7f5              B        |L20.44|
;;;509    
                          ENDP

                  |L20.64|
                          DCD      g_procTable
                  |L20.68|
                          DCD      g_procTableSize

                          AREA ||i.reallocTable||, CODE, READONLY, ALIGN=2

                  reallocTable PROC
;;;477    
;;;478    int reallocTable(void)
000000  b570              PUSH     {r4-r6,lr}
;;;479    {
;;;480        ProcTableEntry *newProcTable;
;;;481        int newProcTableSize;
;;;482    
;;;483        // allocate new table, zero
;;;484        newProcTableSize = g_procTableSize+CRP_PROCTABLE_LEN;
000002  4812              LDR      r0,|L21.76|
000004  8800              LDRH     r0,[r0,#0]  ; g_procTableSize
000006  4604              MOV      r4,r0
000008  3420              ADDS     r4,r4,#0x20
;;;485        newProcTable = (ProcTableEntry *)malloc(sizeof(ProcTableEntry)*newProcTableSize);
00000a  210c              MOVS     r1,#0xc
00000c  4361              MULS     r1,r4,r1
00000e  4608              MOV      r0,r1
000010  f7fffffe          BL       malloc
000014  4605              MOV      r5,r0
;;;486        memset(newProcTable, 0, sizeof(ProcTableEntry)*newProcTableSize);
000016  200c              MOVS     r0,#0xc
000018  4360              MULS     r0,r4,r0
00001a  4601              MOV      r1,r0
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       __aeabi_memclr4
;;;487        // copy to new table
;;;488        memcpy(newProcTable, g_procTable, sizeof(ProcTableEntry)*g_procTableSize);
000022  480a              LDR      r0,|L21.76|
000024  8800              LDRH     r0,[r0,#0]  ; g_procTableSize
000026  210c              MOVS     r1,#0xc
000028  4348              MULS     r0,r1,r0
00002a  4602              MOV      r2,r0
00002c  4808              LDR      r0,|L21.80|
00002e  6801              LDR      r1,[r0,#0]  ; g_procTable
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       __aeabi_memcpy4
;;;489        // delete old table
;;;490        free(g_procTable);
000036  4806              LDR      r0,|L21.80|
000038  6800              LDR      r0,[r0,#0]  ; g_procTable
00003a  f7fffffe          BL       free
;;;491        // set to new
;;;492        g_procTable = newProcTable;
00003e  4804              LDR      r0,|L21.80|
000040  6005              STR      r5,[r0,#0]  ; g_procTable
;;;493        g_procTableSize = newProcTableSize;
000042  4902              LDR      r1,|L21.76|
000044  800c              STRH     r4,[r1,#0]
;;;494    
;;;495        return CRP_RES_OK;
000046  2000              MOVS     r0,#0
;;;496    }
000048  bd70              POP      {r4-r6,pc}
;;;497    
                          ENDP

00004a  0000              DCW      0x0000
                  |L21.76|
                          DCD      g_procTableSize
                  |L21.80|
                          DCD      g_procTable

                          AREA ||i.reallocate||, CODE, READONLY, ALIGN=1

                  reallocate PROC
;;;618    
;;;619    int reallocate(uint32_t min)
000000  4601              MOV      r1,r0
;;;620    {
;;;621    #ifdef CRP_SHARED_MEM
;;;622        return CRP_RES_ERROR_MEMORY;
000002  2004              MOVS     r0,#4
000004  43c0              MVNS     r0,r0
;;;623    #else
;;;624        uint8_t *newbuf;
;;;625    
;;;626        min += CRP_BUFSIZE;
;;;627        newbuf = malloc(min);
;;;628        memcpy(newbuf, g_buf, g_bufSize);
;;;629        free(g_buf);
;;;630        g_buf = newbuf;
;;;631        g_bufSize = min;
;;;632    
;;;633        return CRP_RES_OK;
;;;634    #endif
;;;635    }
000006  4770              BX       lr
;;;636    
                          ENDP


                          AREA ||i.recvChirp||, CODE, READONLY, ALIGN=2

                  recvChirp PROC
;;;653    
;;;654    int recvChirp(uint8_t *type, ChirpProc *proc, void *args[], bool wait) // null pointer terminates
000000  b5ff              PUSH     {r0-r7,lr}
;;;655    {
000002  b083              SUB      sp,sp,#0xc
000004  4617              MOV      r7,r2
;;;656        int res;
;;;657        uint8_t dataType, size, a;
;;;658        uint32_t i, len;
;;;659    
;;;660        // linkReceive
;;;661    #ifdef CRP_ERROR_CORRECTED
;;;662        res = recvFull(type, proc, wait);
000006  9a06              LDR      r2,[sp,#0x18]
000008  9904              LDR      r1,[sp,#0x10]
00000a  9803              LDR      r0,[sp,#0xc]
00000c  f7fffffe          BL       recvFull
000010  9002              STR      r0,[sp,#8]
;;;663    #else
;;;664        for (i=0; TRUE; i++)
;;;665        {
;;;666            res = recvHeader(type, proc, wait);
;;;667            if (res==CRP_RES_ERROR_CRC)
;;;668            {
;;;669                if (i<CRP_MAX_NAK)
;;;670                    continue;
;;;671                else
;;;672                    return CRP_RES_ERROR_MAX_NAK;
;;;673            }
;;;674            else if (res==CRP_RES_OK)
;;;675                break;
;;;676            else
;;;677                return res;
;;;678        }
;;;679        res = recvData();
;;;680    #endif
;;;681        if (res!=CRP_RES_OK)
000012  9802              LDR      r0,[sp,#8]
000014  2800              CMP      r0,#0
000016  d002              BEQ      |L23.30|
;;;682            return res;
000018  9802              LDR      r0,[sp,#8]
                  |L23.26|
;;;683    
;;;684        // get responseInt from response
;;;685        if (*type&CRP_RESPONSE)
;;;686        {
;;;687            // add responseInt to arg list
;;;688            args[0] = (void *)(g_buf+CRP_HEADER_LEN);
;;;689            *(g_buf+CRP_HEADER_LEN-1) = CRP_UINT32; // write type so it parses correctly
;;;690            // increment pointer
;;;691            i = CRP_HEADER_LEN+4;
;;;692            a = 1;
;;;693        }
;;;694        else // call has no responseInt
;;;695        {
;;;696            i = CRP_HEADER_LEN;
;;;697            a = 0;
;;;698        }
;;;699        // parse remaining args
;;;700        for(; i<g_len+CRP_HEADER_LEN; a++)
;;;701        {
;;;702            if (a==CRP_MAX_ARGS)
;;;703                return CRP_RES_ERROR;
;;;704    
;;;705            dataType = g_buf[i++];
;;;706            size = dataType&0x0f;
;;;707            if (!(dataType&CRP_ARRAY)) // if we're a scalar
;;;708            {
;;;709                ALIGN(i, size);
;;;710                args[a] = (void *)(g_buf+i);
;;;711                i += dataType&0x0f; // extract size of scalar, add it
;;;712            }
;;;713            else // we're an array
;;;714            {
;;;715                if (dataType==CRP_STRING) // string is a special case
;;;716                {
;;;717                    args[a] = (void *)(g_buf+i);
;;;718                    i += strlen((char *)(g_buf+i))+1; // +1 include null character
;;;719                }
;;;720                else
;;;721                {
;;;722                    ALIGN(i, 4);
;;;723                    len = *(uint32_t *)(g_buf+i);
;;;724                    args[a++] = (void *)(g_buf+i);
;;;725                    i += 4;
;;;726                    ALIGN(i, size);
;;;727                    args[a] = (void *)(g_buf+i);
;;;728                    i += len*size;
;;;729                }
;;;730            }
;;;731        }
;;;732        args[a] = NULL; // terminate list
;;;733    
;;;734        return CRP_RES_OK;
;;;735    }
00001a  b007              ADD      sp,sp,#0x1c
00001c  bdf0              POP      {r4-r7,pc}
                  |L23.30|
00001e  9803              LDR      r0,[sp,#0xc]          ;685
000020  7800              LDRB     r0,[r0,#0]            ;685
000022  2140              MOVS     r1,#0x40              ;685
000024  4008              ANDS     r0,r0,r1              ;685
000026  2800              CMP      r0,#0                 ;685
000028  d00a              BEQ      |L23.64|
00002a  483e              LDR      r0,|L23.292|
00002c  6800              LDR      r0,[r0,#0]            ;688  ; g_buf
00002e  300c              ADDS     r0,r0,#0xc            ;688
000030  6038              STR      r0,[r7,#0]            ;688
000032  2104              MOVS     r1,#4                 ;689
000034  483b              LDR      r0,|L23.292|
000036  6800              LDR      r0,[r0,#0]            ;689  ; g_buf
000038  72c1              STRB     r1,[r0,#0xb]          ;689
00003a  2410              MOVS     r4,#0x10              ;691
00003c  2501              MOVS     r5,#1                 ;692
00003e  e001              B        |L23.68|
                  |L23.64|
000040  240c              MOVS     r4,#0xc               ;696
000042  2500              MOVS     r5,#0                 ;697
                  |L23.68|
000044  e063              B        |L23.270|
                  |L23.70|
000046  2d0a              CMP      r5,#0xa               ;702
000048  d102              BNE      |L23.80|
00004a  2000              MOVS     r0,#0                 ;703
00004c  43c0              MVNS     r0,r0                 ;703
00004e  e7e4              B        |L23.26|
                  |L23.80|
000050  4620              MOV      r0,r4                 ;705
000052  1c64              ADDS     r4,r4,#1              ;705
000054  4933              LDR      r1,|L23.292|
000056  6809              LDR      r1,[r1,#0]            ;705  ; g_buf
000058  5c08              LDRB     r0,[r1,r0]            ;705
00005a  9001              STR      r0,[sp,#4]            ;705
00005c  9801              LDR      r0,[sp,#4]            ;706
00005e  0706              LSLS     r6,r0,#28             ;706
000060  0f36              LSRS     r6,r6,#28             ;706
000062  2180              MOVS     r1,#0x80              ;707
000064  9801              LDR      r0,[sp,#4]            ;707
000066  4008              ANDS     r0,r0,r1              ;707
000068  2800              CMP      r0,#0                 ;707
00006a  d114              BNE      |L23.150|
00006c  1e70              SUBS     r0,r6,#1              ;709
00006e  4020              ANDS     r0,r0,r4              ;709
000070  2800              CMP      r0,#0                 ;709
000072  d004              BEQ      |L23.126|
000074  1e70              SUBS     r0,r6,#1              ;709
000076  4621              MOV      r1,r4                 ;709
000078  4381              BICS     r1,r1,r0              ;709
00007a  1988              ADDS     r0,r1,r6              ;709
00007c  e000              B        |L23.128|
                  |L23.126|
00007e  4620              MOV      r0,r4                 ;709
                  |L23.128|
000080  4604              MOV      r4,r0                 ;709
000082  4828              LDR      r0,|L23.292|
000084  6800              LDR      r0,[r0,#0]            ;710  ; g_buf
000086  1900              ADDS     r0,r0,r4              ;710
000088  00a9              LSLS     r1,r5,#2              ;710
00008a  5078              STR      r0,[r7,r1]            ;710
00008c  9801              LDR      r0,[sp,#4]            ;711
00008e  0700              LSLS     r0,r0,#28             ;711
000090  0f00              LSRS     r0,r0,#28             ;711
000092  1904              ADDS     r4,r0,r4              ;711
000094  e039              B        |L23.266|
                  |L23.150|
000096  9801              LDR      r0,[sp,#4]            ;715
000098  28a1              CMP      r0,#0xa1              ;715
00009a  d10c              BNE      |L23.182|
00009c  4821              LDR      r0,|L23.292|
00009e  6800              LDR      r0,[r0,#0]            ;717  ; g_buf
0000a0  1900              ADDS     r0,r0,r4              ;717
0000a2  00a9              LSLS     r1,r5,#2              ;717
0000a4  5078              STR      r0,[r7,r1]            ;717
0000a6  491f              LDR      r1,|L23.292|
0000a8  6809              LDR      r1,[r1,#0]            ;718  ; g_buf
0000aa  1908              ADDS     r0,r1,r4              ;718
0000ac  f7fffffe          BL       strlen
0000b0  1c40              ADDS     r0,r0,#1              ;718
0000b2  1904              ADDS     r4,r0,r4              ;718
0000b4  e029              B        |L23.266|
                  |L23.182|
0000b6  07a0              LSLS     r0,r4,#30             ;722
0000b8  0f80              LSRS     r0,r0,#30             ;722
0000ba  2800              CMP      r0,#0                 ;722
0000bc  d003              BEQ      |L23.198|
0000be  08a0              LSRS     r0,r4,#2              ;722
0000c0  0080              LSLS     r0,r0,#2              ;722
0000c2  1d00              ADDS     r0,r0,#4              ;722
0000c4  e000              B        |L23.200|
                  |L23.198|
0000c6  4620              MOV      r0,r4                 ;722
                  |L23.200|
0000c8  4604              MOV      r4,r0                 ;722
0000ca  4816              LDR      r0,|L23.292|
0000cc  6800              LDR      r0,[r0,#0]            ;723  ; g_buf
0000ce  5900              LDR      r0,[r0,r4]            ;723
0000d0  9000              STR      r0,[sp,#0]            ;723
0000d2  4814              LDR      r0,|L23.292|
0000d4  6800              LDR      r0,[r0,#0]            ;724  ; g_buf
0000d6  1902              ADDS     r2,r0,r4              ;724
0000d8  4629              MOV      r1,r5                 ;724
0000da  1c68              ADDS     r0,r5,#1              ;724
0000dc  b2c5              UXTB     r5,r0                 ;724
0000de  0088              LSLS     r0,r1,#2              ;724
0000e0  503a              STR      r2,[r7,r0]            ;724
0000e2  1d24              ADDS     r4,r4,#4              ;725
0000e4  1e70              SUBS     r0,r6,#1              ;726
0000e6  4020              ANDS     r0,r0,r4              ;726
0000e8  2800              CMP      r0,#0                 ;726
0000ea  d004              BEQ      |L23.246|
0000ec  1e70              SUBS     r0,r6,#1              ;726
0000ee  4621              MOV      r1,r4                 ;726
0000f0  4381              BICS     r1,r1,r0              ;726
0000f2  1988              ADDS     r0,r1,r6              ;726
0000f4  e000              B        |L23.248|
                  |L23.246|
0000f6  4620              MOV      r0,r4                 ;726
                  |L23.248|
0000f8  4604              MOV      r4,r0                 ;726
0000fa  480a              LDR      r0,|L23.292|
0000fc  6800              LDR      r0,[r0,#0]            ;727  ; g_buf
0000fe  1900              ADDS     r0,r0,r4              ;727
000100  00a9              LSLS     r1,r5,#2              ;727
000102  5078              STR      r0,[r7,r1]            ;727
000104  9800              LDR      r0,[sp,#0]            ;728
000106  4370              MULS     r0,r6,r0              ;728
000108  1904              ADDS     r4,r0,r4              ;728
                  |L23.266|
00010a  1c68              ADDS     r0,r5,#1              ;700
00010c  b2c5              UXTB     r5,r0                 ;700
                  |L23.270|
00010e  4806              LDR      r0,|L23.296|
000110  6800              LDR      r0,[r0,#0]            ;700  ; g_len
000112  300c              ADDS     r0,r0,#0xc            ;700
000114  4284              CMP      r4,r0                 ;700
000116  d396              BCC      |L23.70|
000118  2000              MOVS     r0,#0                 ;732
00011a  00a9              LSLS     r1,r5,#2              ;732
00011c  5078              STR      r0,[r7,r1]            ;732
00011e  bf00              NOP                            ;734
000120  e77b              B        |L23.26|
;;;736    
                          ENDP

000122  0000              DCW      0x0000
                  |L23.292|
                          DCD      g_buf
                  |L23.296|
                          DCD      g_len

                          AREA ||i.recvFull||, CODE, READONLY, ALIGN=2

                  recvFull PROC
;;;937    #ifdef CRP_ERROR_CORRECTED
;;;938    int recvFull(uint8_t *type, ChirpProc *proc, bool wait)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;939    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;940        int res;
;;;941        uint32_t startCode;
;;;942    
;;;943        // receive header, with startcode check to make sure we're synced
;;;944        while(1)
000006  e01c              B        |L24.66|
                  |L24.8|
;;;945        {
;;;946            if ((res=linkReceive(g_buf, CRP_MAX_HEADER_LEN, wait?CRP_HEADER_TIMEOUT:0))<0)
000008  9802              LDR      r0,[sp,#8]
00000a  2800              CMP      r0,#0
00000c  d002              BEQ      |L24.20|
00000e  20ff              MOVS     r0,#0xff
000010  30f5              ADDS     r0,r0,#0xf5
000012  e000              B        |L24.22|
                  |L24.20|
000014  2000              MOVS     r0,#0
                  |L24.22|
000016  4602              MOV      r2,r0
000018  2140              MOVS     r1,#0x40
00001a  4812              LDR      r0,|L24.100|
00001c  6800              LDR      r0,[r0,#0]  ; g_buf
00001e  f7fffffe          BL       linkReceive
000022  1e04              SUBS     r4,r0,#0
000024  da01              BGE      |L24.42|
;;;947                return res;
000026  4620              MOV      r0,r4
                  |L24.40|
;;;948            // check to see if we received less data than expected
;;;949            if (res<CRP_MAX_HEADER_LEN)
;;;950                return CRP_RES_ERROR;
;;;951    
;;;952            startCode = *(uint32_t *)g_buf;
;;;953            if (startCode==CRP_START_CODE)
;;;954                break;
;;;955        }
;;;956        *type = *(uint8_t *)(g_buf+4);
;;;957        *proc = *(ChirpProc *)(g_buf+6);
;;;958        g_len = *(uint32_t *)(g_buf+8);
;;;959    
;;;960    #ifndef CRP_SHARED_MEM
;;;961        if (g_len+CRP_HEADER_LEN>g_bufSize && (res=reallocate(g_len+CRP_HEADER_LEN))<0)
;;;962            return res;
;;;963    
;;;964        if (g_len+CRP_HEADER_LEN>CRP_MAX_HEADER_LEN)
;;;965        {
;;;966            if ((res=linkReceive(g_buf+CRP_MAX_HEADER_LEN, g_len-(CRP_MAX_HEADER_LEN-CRP_HEADER_LEN), CRP_IDLE_TIMEOUT))<0)
;;;967                return res;
;;;968            // check to see if we received less data than expected
;;;969            if (res<(int)g_len-(CRP_MAX_HEADER_LEN-(int)CRP_HEADER_LEN))
;;;970                return CRP_RES_ERROR;
;;;971        }
;;;972    #endif
;;;973    
;;;974        return CRP_RES_OK;
;;;975    }
000028  bdfe              POP      {r1-r7,pc}
                  |L24.42|
00002a  2c40              CMP      r4,#0x40              ;949
00002c  da02              BGE      |L24.52|
00002e  2000              MOVS     r0,#0                 ;950
000030  43c0              MVNS     r0,r0                 ;950
000032  e7f9              B        |L24.40|
                  |L24.52|
000034  480b              LDR      r0,|L24.100|
000036  6800              LDR      r0,[r0,#0]            ;952  ; g_buf
000038  6807              LDR      r7,[r0,#0]            ;952
00003a  480b              LDR      r0,|L24.104|
00003c  4287              CMP      r7,r0                 ;953
00003e  d100              BNE      |L24.66|
000040  e000              B        |L24.68|
                  |L24.66|
000042  e7e1              B        |L24.8|
                  |L24.68|
000044  bf00              NOP                            ;954
000046  4807              LDR      r0,|L24.100|
000048  6800              LDR      r0,[r0,#0]            ;956  ; g_buf
00004a  7900              LDRB     r0,[r0,#4]            ;956
00004c  7028              STRB     r0,[r5,#0]            ;956
00004e  4805              LDR      r0,|L24.100|
000050  6800              LDR      r0,[r0,#0]            ;957  ; g_buf
000052  88c0              LDRH     r0,[r0,#6]            ;957
000054  8030              STRH     r0,[r6,#0]            ;957
000056  4803              LDR      r0,|L24.100|
000058  6800              LDR      r0,[r0,#0]            ;958  ; g_buf
00005a  6880              LDR      r0,[r0,#8]            ;958
00005c  4903              LDR      r1,|L24.108|
00005e  6008              STR      r0,[r1,#0]            ;958  ; g_len
000060  2000              MOVS     r0,#0                 ;974
000062  e7e1              B        |L24.40|
;;;976    #endif
                          ENDP

                  |L24.100|
                          DCD      g_buf
                  |L24.104|
                          DCD      0xaaaa5555
                  |L24.108|
                          DCD      g_len

                          AREA ||i.sendChirp||, CODE, READONLY, ALIGN=1

                  sendChirp PROC
;;;388    
;;;389    int sendChirp(uint8_t type, ChirpProc proc)
000000  b570              PUSH     {r4-r6,lr}
;;;390    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;391        int res;
;;;392    #ifdef CRP_ERROR_CORRECTED
;;;393        res = sendFull(type, proc);
000006  4631              MOV      r1,r6
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       sendFull
00000e  4604              MOV      r4,r0
;;;394    #else
;;;395        // we'll linkSend forever as long as we get naks
;;;396        // we rely on receiver to give up
;;;397        while((res=sendHeader(type, proc))==CRP_RES_ERROR_CRC);
;;;398        if (res!=CRP_RES_OK)
;;;399            return res;
;;;400        res = sendData();
;;;401    #endif
;;;402    
;;;403        if (res!=CRP_RES_OK)
000010  2c00              CMP      r4,#0
000012  d001              BEQ      |L25.24|
;;;404            return res;
000014  4620              MOV      r0,r4
                  |L25.22|
;;;405        return CRP_RES_OK;
;;;406    }
000016  bd70              POP      {r4-r6,pc}
                  |L25.24|
000018  2000              MOVS     r0,#0                 ;405
00001a  e7fc              B        |L25.22|
;;;407    
                          ENDP


                          AREA ||i.sendChirpRetry||, CODE, READONLY, ALIGN=2

                  sendChirpRetry PROC
;;;370    
;;;371    int sendChirpRetry(uint8_t type, ChirpProc proc)
000000  b5f8              PUSH     {r3-r7,lr}
;;;372    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;373        int i, res;
;;;374    
;;;375        for (i=0; i<CRP_RETRIES; i++)
000006  2500              MOVS     r5,#0
000008  e008              B        |L26.28|
                  |L26.10|
;;;376        {
;;;377            res = sendChirp(type, proc);
00000a  4639              MOV      r1,r7
00000c  4630              MOV      r0,r6
00000e  f7fffffe          BL       sendChirp
000012  4604              MOV      r4,r0
;;;378            if (res==CRP_RES_OK)
000014  2c00              CMP      r4,#0
000016  d100              BNE      |L26.26|
;;;379                break;
000018  e002              B        |L26.32|
                  |L26.26|
00001a  1c6d              ADDS     r5,r5,#1              ;375
                  |L26.28|
00001c  2d03              CMP      r5,#3                 ;375
00001e  dbf4              BLT      |L26.10|
                  |L26.32|
000020  bf00              NOP      
;;;380        }
;;;381    
;;;382        // if sending the chirp fails after retries, we should assume we're no longer connected
;;;383        if (res<0)
000022  2c00              CMP      r4,#0
000024  da02              BGE      |L26.44|
;;;384            g_connected = FALSE;
000026  2000              MOVS     r0,#0
000028  4901              LDR      r1,|L26.48|
00002a  6008              STR      r0,[r1,#0]  ; g_connected
                  |L26.44|
;;;385    
;;;386        return res;
00002c  4620              MOV      r0,r4
;;;387    }
00002e  bdf8              POP      {r3-r7,pc}
;;;388    
                          ENDP

                  |L26.48|
                          DCD      g_connected

                          AREA ||i.sendFull||, CODE, READONLY, ALIGN=2

                  sendFull PROC
;;;755    #ifdef CRP_ERROR_CORRECTED
;;;756    int sendFull(uint8_t type, ChirpProc proc)
000000  b570              PUSH     {r4-r6,lr}
;;;757    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;758        int res;
;;;759    
;;;760        *(uint32_t *)g_buf = CRP_START_CODE;
000006  480e              LDR      r0,|L27.64|
000008  490e              LDR      r1,|L27.68|
00000a  6809              LDR      r1,[r1,#0]  ; g_buf
00000c  6008              STR      r0,[r1,#0]
;;;761        *(uint8_t *)(g_buf+4) = type;
00000e  480d              LDR      r0,|L27.68|
000010  6800              LDR      r0,[r0,#0]  ; g_buf
000012  7104              STRB     r4,[r0,#4]
;;;762        *(ChirpProc *)(g_buf+6) = proc;
000014  480b              LDR      r0,|L27.68|
000016  6800              LDR      r0,[r0,#0]  ; g_buf
000018  80c5              STRH     r5,[r0,#6]
;;;763        *(uint32_t *)(g_buf+8) = g_len;
00001a  480b              LDR      r0,|L27.72|
00001c  6800              LDR      r0,[r0,#0]  ; g_len
00001e  4909              LDR      r1,|L27.68|
000020  6809              LDR      r1,[r1,#0]  ; g_buf
000022  6088              STR      r0,[r1,#8]
;;;764        // linkSend header
;;;765        if ((res=linkSend(g_buf, CRP_MAX_HEADER_LEN, CRP_SEND_TIMEOUT))<0)
000024  22ff              MOVS     r2,#0xff
000026  32f5              ADDS     r2,r2,#0xf5
000028  2140              MOVS     r1,#0x40
00002a  4806              LDR      r0,|L27.68|
00002c  6800              LDR      r0,[r0,#0]  ; g_buf
00002e  f7fffffe          BL       linkSend
000032  1e06              SUBS     r6,r0,#0
000034  da01              BGE      |L27.58|
;;;766            return res;
000036  4630              MOV      r0,r6
                  |L27.56|
;;;767    
;;;768    #ifndef CRP_SHARED_MEM
;;;769        // if we haven't sent everything yet....
;;;770        if (g_len+CRP_HEADER_LEN>CRP_MAX_HEADER_LEN)
;;;771        {
;;;772            if ((res=linkSend(g_buf+CRP_MAX_HEADER_LEN, g_len-(CRP_MAX_HEADER_LEN-CRP_HEADER_LEN), CRP_SEND_TIMEOUT))<0)
;;;773                return res;
;;;774        }
;;;775    #endif
;;;776    
;;;777        return CRP_RES_OK;
;;;778    }
000038  bd70              POP      {r4-r6,pc}
                  |L27.58|
00003a  2000              MOVS     r0,#0                 ;777
00003c  e7fc              B        |L27.56|
;;;779    #endif
                          ENDP

00003e  0000              DCW      0x0000
                  |L27.64|
                          DCD      0xaaaa5555
                  |L27.68|
                          DCD      g_buf
                  |L27.72|
                          DCD      g_len

                          AREA ||i.updateTable||, CODE, READONLY, ALIGN=2

                  updateTable PROC
;;;510    
;;;511    ChirpProc updateTable(const char *procName, ProcPtr procPtr)
000000  b570              PUSH     {r4-r6,lr}
;;;512    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;513        ChirpProc proc;
;;;514        // if it exists already, update,
;;;515        // if it doesn't exist, add it
;;;516        if (procName==NULL)
000006  2d00              CMP      r5,#0
000008  d101              BNE      |L28.14|
;;;517            return -1;
00000a  1e40              SUBS     r0,r0,#1
                  |L28.12|
;;;518    
;;;519        proc = lookupTable(procName);
;;;520        if (proc<0) // next empty entry
;;;521        {
;;;522            for (proc=0; proc<g_procTableSize && g_procTable[proc].procName; proc++);
;;;523            if (proc==g_procTableSize)
;;;524            {
;;;525                reallocTable();
;;;526                return updateTable(procName, procPtr);
;;;527            }
;;;528        }
;;;529    
;;;530        // add to table
;;;531        g_procTable[proc].procName = procName;
;;;532        g_procTable[proc].procPtr = procPtr;
;;;533    
;;;534        return proc;
;;;535    }
00000c  bd70              POP      {r4-r6,pc}
                  |L28.14|
00000e  4628              MOV      r0,r5                 ;519
000010  f7fffffe          BL       lookupTable
000014  4604              MOV      r4,r0                 ;519
000016  2c00              CMP      r4,#0                 ;520
000018  da19              BGE      |L28.78|
00001a  2400              MOVS     r4,#0                 ;522
00001c  e001              B        |L28.34|
                  |L28.30|
00001e  1c60              ADDS     r0,r4,#1              ;522
000020  b204              SXTH     r4,r0                 ;522
                  |L28.34|
000022  4811              LDR      r0,|L28.104|
000024  8800              LDRH     r0,[r0,#0]            ;522  ; g_procTableSize
000026  4284              CMP      r4,r0                 ;522
000028  da06              BGE      |L28.56|
00002a  200c              MOVS     r0,#0xc               ;522
00002c  4360              MULS     r0,r4,r0              ;522
00002e  490f              LDR      r1,|L28.108|
000030  6809              LDR      r1,[r1,#0]            ;522  ; g_procTable
000032  5808              LDR      r0,[r1,r0]            ;522
000034  2800              CMP      r0,#0                 ;522
000036  d1f2              BNE      |L28.30|
                  |L28.56|
000038  480b              LDR      r0,|L28.104|
00003a  8800              LDRH     r0,[r0,#0]            ;523  ; g_procTableSize
00003c  4284              CMP      r4,r0                 ;523
00003e  d106              BNE      |L28.78|
000040  f7fffffe          BL       reallocTable
000044  4631              MOV      r1,r6                 ;526
000046  4628              MOV      r0,r5                 ;526
000048  f7fffffe          BL       updateTable
00004c  e7de              B        |L28.12|
                  |L28.78|
00004e  200c              MOVS     r0,#0xc               ;531
000050  4360              MULS     r0,r4,r0              ;531
000052  4906              LDR      r1,|L28.108|
000054  6809              LDR      r1,[r1,#0]            ;531  ; g_procTable
000056  500d              STR      r5,[r1,r0]            ;531
000058  200c              MOVS     r0,#0xc               ;532
00005a  4360              MULS     r0,r4,r0              ;532
00005c  4903              LDR      r1,|L28.108|
00005e  6809              LDR      r1,[r1,#0]            ;532  ; g_procTable
000060  1840              ADDS     r0,r0,r1              ;532
000062  6046              STR      r6,[r0,#4]            ;532
000064  4620              MOV      r0,r4                 ;534
000066  e7d1              B        |L28.12|
;;;536    
                          ENDP

                  |L28.104|
                          DCD      g_procTableSize
                  |L28.108|
                          DCD      g_procTable

                          AREA ||.data||, DATA, ALIGN=2

                  g_procTable
                          DCD      0x00000000
                  g_procTableSize
000004  0000              DCB      0x00,0x00
                  g_blkSize
000006  0000              DCB      0x00,0x00
                  g_connected
                          DCD      0x00000000
                  g_buf
                          DCD      0x00000000
                  g_len
                          DCD      0x00000000
                  g_bufSize
                          DCD      0x00000000
                  g_remoteInit
                          DCD      0x00000000
                  g_hinformer
                          DCD      0x00000000

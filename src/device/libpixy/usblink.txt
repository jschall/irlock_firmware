; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--cpp --list --split_sections --debug -c --asm --interleave -o.\usblink.o --asm_dir=.\ --list_dir=.\ --depend=.\usblink.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I. -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\usblink.crf usblink.cpp]
                          THUMB

                          AREA ||i._ZN7USBLink4sendEPKhjt||, CODE, READONLY, ALIGN=2

                  _ZN7USBLink4sendEPKhjt PROC ; USBLink::send(const unsigned char*, unsigned, unsigned short)
;;;40     
;;;41     int USBLink::send(const uint8_t *data, uint32_t len, uint16_t timeoutMs)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;42     {
000004  4682              MOV      r10,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
;;;43     	uint32_t time, start, timeout = timeoutMs * CLKFREQ_MS;
00000c  4814              LDR      r0,|L1.96|
00000e  fb06f900          MUL      r9,r6,r0
;;;44     
;;;45      	if (!USB_handleState())
000012  f7fffffe          BL       USB_handleState
000016  b928              CBNZ     r0,|L1.36|
;;;46     	{
;;;47     		g_sendComplete = 0;
000018  2000              MOVS     r0,#0
00001a  4912              LDR      r1,|L1.100|
00001c  7008              STRB     r0,[r1,#0]
;;;48     		return -1;
00001e  1e40              SUBS     r0,r0,#1
                  |L1.32|
;;;49     	}
;;;50     
;;;51     	USB_Send(data, len);
;;;52     	while(1)
;;;53     	{
;;;54     		start = g_sendTimerStart; // avoid race condition with usb interrupt routine-- sample here 
;;;55     		time = LPC_TIMER1->TC; // time is guaranteed to be more recent than start
;;;56     		if ((uint32_t)(time-start) > timeout || g_sendComplete)
;;;57     			break;
;;;58     	}
;;;59       	if (g_sendComplete)
;;;60     		return len;
;;;61     	else
;;;62     	{
;;;63     		USB_SendReset();
;;;64     		return LINK_RESULT_ERROR_SEND_TIMEOUT;
;;;65     	}
;;;66     }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L1.36|
000024  4621              MOV      r1,r4                 ;51
000026  4628              MOV      r0,r5                 ;51
000028  f7fffffe          BL       USB_Send
00002c  e00c              B        |L1.72|
                  |L1.46|
00002e  480e              LDR      r0,|L1.104|
000030  f8d08000          LDR      r8,[r0,#0]            ;54  ; g_sendTimerStart
000034  480d              LDR      r0,|L1.108|
000036  6887              LDR      r7,[r0,#8]            ;55
000038  eba70008          SUB      r0,r7,r8              ;56
00003c  4548              CMP      r0,r9                 ;56
00003e  d802              BHI      |L1.70|
000040  4808              LDR      r0,|L1.100|
000042  7800              LDRB     r0,[r0,#0]            ;56  ; g_sendComplete
000044  b100              CBZ      r0,|L1.72|
                  |L1.70|
000046  e000              B        |L1.74|
                  |L1.72|
000048  e7f1              B        |L1.46|
                  |L1.74|
00004a  bf00              NOP                            ;57
00004c  4805              LDR      r0,|L1.100|
00004e  7800              LDRB     r0,[r0,#0]            ;59  ; g_sendComplete
000050  b108              CBZ      r0,|L1.86|
000052  4620              MOV      r0,r4                 ;60
000054  e7e4              B        |L1.32|
                  |L1.86|
000056  f7fffffe          BL       USB_SendReset
00005a  f06f0065          MVN      r0,#0x65              ;64
00005e  e7df              B        |L1.32|
;;;67     
                          ENDP

                  |L1.96|
                          DCD      0x00031ce0
                  |L1.100|
                          DCD      g_sendComplete
                  |L1.104|
                          DCD      g_sendTimerStart
                  |L1.108|
                          DCD      0x40085000

                          AREA ||i._ZN7USBLink7receiveEPhjt||, CODE, READONLY, ALIGN=2

                  _ZN7USBLink7receiveEPhjt PROC ; USBLink::receive(unsigned char*, unsigned, unsigned short)
;;;67     
;;;68     int USBLink::receive(uint8_t *data, uint32_t len, uint16_t timeoutMs)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;69     {
000004  4682              MOV      r10,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
00000a  461e              MOV      r6,r3
;;;70     	uint32_t time, start, timeout = timeoutMs * CLKFREQ_MS;
00000c  482c              LDR      r0,|L2.192|
00000e  fb06f800          MUL      r8,r6,r0
;;;71     
;;;72      	if (!USB_handleState())
000012  f7fffffe          BL       USB_handleState
000016  b938              CBNZ     r0,|L2.40|
;;;73     	{
;;;74     		g_bufUsed = 0;
000018  2000              MOVS     r0,#0
00001a  492a              LDR      r1,|L2.196|
00001c  6008              STR      r0,[r1,#0]  ; g_bufUsed
;;;75     		g_recvComplete = 0;
00001e  492a              LDR      r1,|L2.200|
000020  7008              STRB     r0,[r1,#0]
;;;76     		return -1;
000022  1e40              SUBS     r0,r0,#1
                  |L2.36|
;;;77     	}
;;;78     
;;;79     	if (timeout==0) // this is special case... 
;;;80     	{
;;;81     		if (len>GBUF_SIZE || g_bufUsed!=0&&g_bufUsed!=len)
;;;82     			return LINK_RESULT_ERROR;
;;;83     
;;;84     		if (g_bufUsed==0)
;;;85     		{
;;;86     			g_bufUsed = len;
;;;87     			// register	receive buffer
;;;88     			USB_Recv(g_buf, g_bufUsed);
;;;89     		}
;;;90     		else if (g_recvComplete) // if it has come in, then copy
;;;91     		{
;;;92     			memcpy((void *)data, (void *)g_buf, len);
;;;93     			g_bufUsed = 0;
;;;94     			return len;
;;;95     		}
;;;96     		return 0;
;;;97     	}
;;;98     	else
;;;99     	{
;;;100    		if (g_bufUsed!=0) // if we have a receive pending, reset
;;;101    			USB_RecvReset();			
;;;102    		USB_Recv(data, len);
;;;103    	}
;;;104    
;;;105       	// wait
;;;106    	while(1)
;;;107    	{
;;;108    		start = g_recvTimerStart; // avoid race condition with usb interrupt routine-- sample here 
;;;109    		time = LPC_TIMER1->TC; // time is guaranteed to be more recent than start
;;;110    		if ((uint32_t)(time-start) > timeout || g_recvComplete)
;;;111    			break;
;;;112    	}
;;;113      	if (g_recvComplete)
;;;114    		return len;
;;;115    	else 
;;;116    	{
;;;117    		USB_RecvReset();
;;;118    		return LINK_RESULT_ERROR_RECV_TIMEOUT;
;;;119    	}
;;;120    }
000024  e8bd87f0          POP      {r4-r10,pc}
                  |L2.40|
000028  f1b80f00          CMP      r8,#0                 ;79
00002c  d124              BNE      |L2.120|
00002e  2c40              CMP      r4,#0x40              ;81
000030  d806              BHI      |L2.64|
000032  4824              LDR      r0,|L2.196|
000034  6800              LDR      r0,[r0,#0]            ;81  ; g_bufUsed
000036  b130              CBZ      r0,|L2.70|
000038  4822              LDR      r0,|L2.196|
00003a  6800              LDR      r0,[r0,#0]            ;81  ; g_bufUsed
00003c  42a0              CMP      r0,r4                 ;81
00003e  d002              BEQ      |L2.70|
                  |L2.64|
000040  f06f0063          MVN      r0,#0x63              ;82
000044  e7ee              B        |L2.36|
                  |L2.70|
000046  481f              LDR      r0,|L2.196|
000048  6800              LDR      r0,[r0,#0]            ;84  ; g_bufUsed
00004a  b930              CBNZ     r0,|L2.90|
00004c  481d              LDR      r0,|L2.196|
00004e  6004              STR      r4,[r0,#0]            ;86  ; g_bufUsed
000050  6801              LDR      r1,[r0,#0]            ;88  ; g_bufUsed
000052  481e              LDR      r0,|L2.204|
000054  f7fffffe          BL       USB_Recv
000058  e00c              B        |L2.116|
                  |L2.90|
00005a  481b              LDR      r0,|L2.200|
00005c  7800              LDRB     r0,[r0,#0]            ;90  ; g_recvComplete
00005e  b148              CBZ      r0,|L2.116|
000060  4622              MOV      r2,r4                 ;92
000062  491a              LDR      r1,|L2.204|
000064  4628              MOV      r0,r5                 ;92
000066  f7fffffe          BL       __aeabi_memcpy
00006a  2000              MOVS     r0,#0                 ;93
00006c  4915              LDR      r1,|L2.196|
00006e  6008              STR      r0,[r1,#0]            ;93  ; g_bufUsed
000070  4620              MOV      r0,r4                 ;94
000072  e7d7              B        |L2.36|
                  |L2.116|
000074  2000              MOVS     r0,#0                 ;96
000076  e7d5              B        |L2.36|
                  |L2.120|
000078  4812              LDR      r0,|L2.196|
00007a  6800              LDR      r0,[r0,#0]            ;100  ; g_bufUsed
00007c  b108              CBZ      r0,|L2.130|
00007e  f7fffffe          BL       USB_RecvReset
                  |L2.130|
000082  4621              MOV      r1,r4                 ;102
000084  4628              MOV      r0,r5                 ;102
000086  f7fffffe          BL       USB_Recv
00008a  e00c              B        |L2.166|
                  |L2.140|
00008c  4810              LDR      r0,|L2.208|
00008e  6807              LDR      r7,[r0,#0]            ;108  ; g_recvTimerStart
000090  4810              LDR      r0,|L2.212|
000092  f8d09008          LDR      r9,[r0,#8]            ;109
000096  eba90007          SUB      r0,r9,r7              ;110
00009a  4540              CMP      r0,r8                 ;110
00009c  d802              BHI      |L2.164|
00009e  480a              LDR      r0,|L2.200|
0000a0  7800              LDRB     r0,[r0,#0]            ;110  ; g_recvComplete
0000a2  b100              CBZ      r0,|L2.166|
                  |L2.164|
0000a4  e000              B        |L2.168|
                  |L2.166|
0000a6  e7f1              B        |L2.140|
                  |L2.168|
0000a8  bf00              NOP                            ;111
0000aa  4807              LDR      r0,|L2.200|
0000ac  7800              LDRB     r0,[r0,#0]            ;113  ; g_recvComplete
0000ae  b108              CBZ      r0,|L2.180|
0000b0  4620              MOV      r0,r4                 ;114
0000b2  e7b7              B        |L2.36|
                  |L2.180|
0000b4  f7fffffe          BL       USB_RecvReset
0000b8  f06f0064          MVN      r0,#0x64              ;118
0000bc  e7b2              B        |L2.36|
;;;121    
                          ENDP

0000be  0000              DCW      0x0000
                  |L2.192|
                          DCD      0x00031ce0
                  |L2.196|
                          DCD      g_bufUsed
                  |L2.200|
                          DCD      g_recvComplete
                  |L2.204|
                          DCD      g_buf
                  |L2.208|
                          DCD      g_recvTimerStart
                  |L2.212|
                          DCD      0x40085000

                          AREA ||i._ZN7USBLink8getTimerEv||, CODE, READONLY, ALIGN=1

                  _ZN7USBLink8getTimerEv PROC ; USBLink::getTimer()
;;;127    
;;;128    uint32_t USBLink::getTimer()
000000  b510              PUSH     {r4,lr}
;;;129    {
000002  4604              MOV      r4,r0
;;;130    	return ::getTimer(m_timer);
000004  68e0              LDR      r0,[r4,#0xc]
000006  f7fffffe          BL       getTimer
;;;131    }
00000a  bd10              POP      {r4,pc}
                          ENDP


                          AREA ||i._ZN7USBLink8setTimerEv||, CODE, READONLY, ALIGN=1

                  _ZN7USBLink8setTimerEv PROC ; USBLink::setTimer()
;;;122    
;;;123    void USBLink::setTimer()
000000  b510              PUSH     {r4,lr}
;;;124    {
000002  4604              MOV      r4,r0
;;;125    	::setTimer(&m_timer);
000004  f104000c          ADD      r0,r4,#0xc
000008  f7fffffe          BL       setTimer
;;;126    }
00000c  bd10              POP      {r4,pc}
;;;127    
                          ENDP


                          AREA ||i._ZN7USBLinkC1Ev||, CODE, READONLY, ALIGN=2

                  _ZN7USBLinkC2Ev                  ; Alternate entry point ; USBLink::USBLink__sub_object()
                  _ZN7USBLinkC1Ev PROC ; USBLink::USBLink()
;;;31     
;;;32     USBLink::USBLink()
;;;33     {
;;;34     	m_flags = LINK_FLAG_ERROR_CORRECTED;
;;;35     }
;;;36     
000000  4905              LDR      r1,|L5.24|
000002  6001              STR      r1,[r0,#0]
000004  2100              MOVS     r1,#0
000006  6041              STR      r1,[r0,#4]
000008  6081              STR      r1,[r0,#8]
00000a  bf00              NOP      
00000c  4903              LDR      r1,|L5.28|
00000e  6001              STR      r1,[r0,#0]
000010  2102              MOVS     r1,#2
000012  6041              STR      r1,[r0,#4]
000014  4770              BX       lr
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      _ZTV4Link+0x8 ; vtable for Link
                  |L5.28|
                          DCD      _ZTV7USBLink+0x8 ; vtable for USBLink

                          AREA ||i._ZN7USBLinkD1Ev||, CODE, READONLY, ALIGN=1

                  _ZN7USBLinkD2Ev                  ; Alternate entry point ; USBLink::~USBLink__sub_object()
                  _ZN7USBLinkD1Ev PROC ; USBLink::~USBLink()
;;;36     
;;;37     USBLink::~USBLink()
;;;38     {
;;;39     }
;;;40     
000000  bf00              NOP      
000002  bf00              NOP      
000004  bf00              NOP      
000006  4770              BX       lr
                          ENDP


                          AREA ||.ARM.exidx||, LINKORDER=||i._ZN7USBLinkC1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          DCD      0x00000000
                          RELOC 42, ||i._ZN7USBLinkC1Ev||
                          DCD      0x00000001

                          AREA ||area_number.8||, LINKORDER=||i._ZN7USBLinkD1Ev||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.8||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7USBLinkD1Ev||
                          DCD      0x00000001

                          AREA ||area_number.9||, LINKORDER=||i._ZN7USBLink4sendEPKhjt||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.9||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7USBLink4sendEPKhjt||
                          DCD      0x00000001

                          AREA ||area_number.10||, LINKORDER=||i._ZN7USBLink7receiveEPhjt||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.10||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7USBLink7receiveEPhjt||
                          DCD      0x00000001

                          AREA ||area_number.11||, LINKORDER=||i._ZN7USBLink8setTimerEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.11||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7USBLink8setTimerEv||
                          DCD      0x00000001

                          AREA ||area_number.12||, LINKORDER=||i._ZN7USBLink8getTimerEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN7USBLink8getTimerEv||
                          DCD      0x00000001

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  g_buf
                          %        64

                          AREA ||.data||, DATA, ALIGN=2

                  g_bufUsed
                          DCD      0x00000000

                          AREA ||.constdata__ZTV7USBLink||, COMGROUP=_ZTV7USBLink, DATA, READONLY, ALIGN=2

                  _ZTV7USBLink ; vtable for USBLink
                          DCD      0x00000000
                          DCD      _ZTI7USBLink ; typeinfo for USBLink
                          DCD      _ZN7USBLink4sendEPKhjt ; USBLink::send(const unsigned char*, unsigned, unsigned short)
                          DCD      _ZN7USBLink7receiveEPhjt ; USBLink::receive(unsigned char*, unsigned, unsigned short)
                          DCD      _ZN7USBLink8setTimerEv ; USBLink::setTimer()
                          DCD      _ZN7USBLink8getTimerEv ; USBLink::getTimer()
                          DCD      _ZN4Link8getFlagsEh ; Link::getFlags(unsigned char)
                          DCD      _ZN4Link9blockSizeEv ; Link::blockSize()
                          DCD      _ZN4Link9getBufferEPPhPj ; Link::getBuffer(unsigned char**, unsigned*)

                          AREA ||i._ZN4Link8getFlagsEh||, COMGROUP=_ZN4Link8getFlagsEh, CODE, READONLY, ALIGN=1

                  _ZN4Link8getFlagsEh PROC ; Link::getFlags(unsigned char)
;;;54         virtual uint32_t getTimer() = 0; // returns elapsed time in milliseconds since setTimer() was called
;;;55         virtual uint32_t getFlags(uint8_t index=LINK_FLAG_INDEX_FLAGS)
000000  4602              MOV      r2,r0
;;;56         {
;;;57             if (index==LINK_FLAG_INDEX_FLAGS)
000002  b909              CBNZ     r1,|L50.8|
;;;58                 return m_flags;
000004  6850              LDR      r0,[r2,#4]
                  |L50.6|
;;;59             else
;;;60                 return 0;
;;;61         }
000006  4770              BX       lr
                  |L50.8|
000008  2000              MOVS     r0,#0                 ;60
00000a  e7fc              B        |L50.6|
;;;62         virtual uint32_t blockSize()
                          ENDP


                          AREA ||area_number.51||, COMGROUP=_ZN4Link8getFlagsEh, LINKORDER=||i._ZN4Link8getFlagsEh||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.51||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Link8getFlagsEh||
                          DCD      0x00000001

                          AREA ||i._ZN4Link9blockSizeEv||, COMGROUP=_ZN4Link9blockSizeEv, CODE, READONLY, ALIGN=1

                  _ZN4Link9blockSizeEv PROC ; Link::blockSize()
;;;61         }
;;;62         virtual uint32_t blockSize()
000000  4601              MOV      r1,r0
;;;63         {
;;;64             return m_blockSize;
000002  6888              LDR      r0,[r1,#8]
;;;65         }
000004  4770              BX       lr
;;;66         virtual int getBuffer(uint8_t **buf, uint32_t *len)
                          ENDP


                          AREA ||area_number.58||, COMGROUP=_ZN4Link9blockSizeEv, LINKORDER=||i._ZN4Link9blockSizeEv||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.58||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Link9blockSizeEv||
                          DCD      0x00000001

                          AREA ||i._ZN4Link9getBufferEPPhPj||, COMGROUP=_ZN4Link9getBufferEPPhPj, CODE, READONLY, ALIGN=1

                  _ZN4Link9getBufferEPPhPj PROC ; Link::getBuffer(unsigned char**, unsigned*)
;;;65         }
;;;66         virtual int getBuffer(uint8_t **buf, uint32_t *len)
000000  4603              MOV      r3,r0
;;;67         {
;;;68             return LINK_RESULT_ERROR;
000002  f06f0063          MVN      r0,#0x63
;;;69         }
000006  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||area_number.65||, COMGROUP=_ZN4Link9getBufferEPPhPj, LINKORDER=||i._ZN4Link9getBufferEPPhPj||, DATA, READONLY, SECTYPE={SHT_ARM_EXIDX}, ALIGN=2

                          EXPORTAS ||area_number.65||, ||.ARM.exidx||
                          DCD      0x00000000
                          RELOC 42, ||i._ZN4Link9getBufferEPPhPj||
                          DCD      0x00000001

                          AREA ||.constdata__ZTV4Link||, COMGROUP=_ZTV4Link, DATA, READONLY, ALIGN=2

                  _ZTV4Link ; vtable for Link
                          DCD      0x00000000
                          DCD      _ZTI4Link ; typeinfo for Link
                          DCD      __cxa_pure_virtual
                          DCD      __cxa_pure_virtual
                          DCD      __cxa_pure_virtual
                          DCD      __cxa_pure_virtual
                          DCD      _ZN4Link8getFlagsEh ; Link::getFlags(unsigned char)
                          DCD      _ZN4Link9blockSizeEv ; Link::blockSize()
                          DCD      _ZN4Link9getBufferEPPhPj ; Link::getBuffer(unsigned char**, unsigned*)

                          AREA ||.constdata__ZTI7USBLink||, COMGROUP=_ZTI7USBLink, DATA, READONLY, ALIGN=2

                  _ZTI7USBLink ; typeinfo for USBLink
                          DCD      _ZTVN10__cxxabiv120__si_class_type_infoE+0x8 ; vtable for __cxxabiv1::__si_class_type_info
                          DCD      _ZTS7USBLink ; typeinfo name for USBLink
                          DCD      _ZTI4Link ; typeinfo for Link

                          AREA ||.constdata__ZTI4Link||, COMGROUP=_ZTI4Link, DATA, READONLY, ALIGN=2

                  _ZTI4Link ; typeinfo for Link
                          DCD      _ZTVN10__cxxabiv117__class_type_infoE+0x8 ; vtable for __cxxabiv1::__class_type_info
                          DCD      _ZTS4Link ; typeinfo name for Link

                          AREA ||.constdata__ZTS7USBLink||, COMGROUP=_ZTS7USBLink, DATA, READONLY, ALIGN=0

                  _ZTS7USBLink ; typeinfo name for USBLink
000000  37555342          DCB      0x37,0x55,0x53,0x42
000004  4c696e6b          DCB      0x4c,0x69,0x6e,0x6b
000008  00                DCB      0x00

                          AREA ||.constdata__ZTS4Link||, COMGROUP=_ZTS4Link, DATA, READONLY, ALIGN=0

                  _ZTS4Link ; typeinfo name for Link
000000  344c696e          DCB      0x34,0x4c,0x69,0x6e
000004  6b00              DCB      0x6b,0x00

;*** Start embedded assembler ***

#line 1 "usblink.cpp"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_usblink_cpp_fb8849c0___Z7__REV16j|
#line 130 ".\\core_cmInstr.h"
|__asm___11_usblink_cpp_fb8849c0___Z7__REV16j| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___11_usblink_cpp_fb8849c0___Z7__REVSHi|
#line 144
|__asm___11_usblink_cpp_fb8849c0___Z7__REVSHi| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***

; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\usbhw.o --asm_dir=.\ --list_dir=.\ --depend=.\usbhw.d --cpu=Cortex-M4.fp --apcs=interwork -O0 -I. -I..\..\common -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.0\CMSIS\Include -DCORE_M4 -DIPC_MASTER -DPIXY --omf_browse=.\usbhw.crf usbhw.c]
                          THUMB

                          AREA ||i.EPAdr||, CODE, READONLY, ALIGN=1

                  EPAdr PROC
;;;86     
;;;87     uint32_t EPAdr (uint32_t EPNum) {
000000  4601              MOV      r1,r0
;;;88       uint32_t val;
;;;89     
;;;90       val = (EPNum & 0x0F) << 1;
000002  070a              LSLS     r2,r1,#28
000004  0ed0              LSRS     r0,r2,#27
;;;91       if (EPNum & 0x80) {
000006  f0010280          AND      r2,r1,#0x80
00000a  b102              CBZ      r2,|L1.14|
;;;92         val += 1;
00000c  1c40              ADDS     r0,r0,#1
                  |L1.14|
;;;93       }
;;;94       return (val);
;;;95     }
00000e  4770              BX       lr
;;;96     
                          ENDP


                          AREA ||i.USB0_IRQHandler||, CODE, READONLY, ALIGN=2

                  USB0_IRQHandler PROC
;;;670    #ifdef USE_USB0
;;;671    void USB0_IRQHandler (void)
000000  b570              PUSH     {r4-r6,lr}
;;;672    #else
;;;673    void USB1_IRQHandler (void)
;;;674    #endif
;;;675    {
;;;676      uint32_t disr, val, n;
;;;677    
;;;678      disr = LPC_USB->USBSTS_D;                      /* Device Interrupt Status */
000002  486b              LDR      r0,|L2.432|
000004  6806              LDR      r6,[r0,#0]
;;;679      LPC_USB->USBSTS_D = disr;
000006  486b              LDR      r0,|L2.436|
000008  f8c06144          STR      r6,[r0,#0x144]
;;;680    
;;;681    //  printf("USB interrupt: 0x%08x\n",disr);
;;;682    
;;;683    //	LPC_UART1->THR = 'U';
;;;684    //	LPC_UART1->THR = 'S';
;;;685    //	LPC_UART1->THR = 'B';
;;;686    //	LPC_UART1->THR = '\n';
;;;687    
;;;688    
;;;689      /* Device Status Interrupt (Reset, Connect change, Suspend/Resume) */
;;;690      if (disr & USBSTS_URI)                      /* Reset */
00000c  f0060040          AND      r0,r6,#0x40
000010  b140              CBZ      r0,|L2.36|
;;;691      {
;;;692    //												  	LPC_UART1->THR = 'R';
;;;693    //												  	LPC_UART1->THR = '\n';
;;;694        USB_Reset();
000012  f7fffffe          BL       USB_Reset
;;;695        if (g_drv.USB_Reset_Event)
000016  4868              LDR      r0,|L2.440|
000018  6880              LDR      r0,[r0,#8]  ; g_drv
00001a  b110              CBZ      r0,|L2.34|
;;;696          g_drv.USB_Reset_Event();
00001c  4966              LDR      r1,|L2.440|
00001e  6888              LDR      r0,[r1,#8]  ; g_drv
000020  4780              BLX      r0
                  |L2.34|
;;;697        return;
;;;698    	//goto isr_end;
;;;699      }
;;;700    
;;;701      if (disr & USBSTS_SLI)                   /* Suspend */
;;;702      {
;;;703    //												  LPC_UART1->THR = 'U';
;;;704    //												  	LPC_UART1->THR = '\n';
;;;705        if (g_drv.USB_Suspend_Event)
;;;706          g_drv.USB_Suspend_Event();
;;;707      }
;;;708    
;;;709      if (disr & USBSTS_PCI)                  /* Resume */
;;;710      {
;;;711    //												  	LPC_UART1->THR = 'P';
;;;712    //												  	LPC_UART1->THR = '\n';
;;;713        /* check if device isoperating in HS mode or full speed */
;;;714        if (LPC_USB->PORTSC1_D & (1<<9))
;;;715          DevStatusFS2HS = TRUE;
;;;716    
;;;717        if (g_drv.USB_Resume_Event)
;;;718          g_drv.USB_Resume_Event();
;;;719      }
;;;720    
;;;721      /* handle setup status interrupts */
;;;722      val = LPC_USB->ENDPTSETUPSTAT;
;;;723      /* Only EP0 will have setup packets so call EP0 handler */
;;;724      if (val)
;;;725      {
;;;726    //												    LPC_UART1->THR = 'S';
;;;727    //												  	LPC_UART1->THR = '\n';
;;;728        /* Clear the endpoint complete CTRL OUT & IN when */
;;;729        /* a Setup is received */
;;;730        LPC_USB->ENDPTCOMPLETE = 0x00010001;
;;;731        /* enable NAK inetrrupts */
;;;732        LPC_USB->ENDPTNAKEN |= 0x00010001;
;;;733        if (g_drv.USB_P_EP[0]){
;;;734    //														LPC_UART1->THR = 's';
;;;735    //												  		LPC_UART1->THR = '\n';
;;;736            g_drv.USB_P_EP[0](USB_EVT_SETUP);
;;;737    	}
;;;738      }
;;;739    
;;;740      /* handle completion interrupts */
;;;741      val = LPC_USB->ENDPTCOMPLETE;
;;;742      if (val)
;;;743      {
;;;744    //														LPC_UART1->THR = 'C';
;;;745    //													  	LPC_UART1->THR = '\n';
;;;746    
;;;747        LPC_USB->ENDPTNAK = val;
;;;748        for (n = 0; n < EP_NUM_MAX / 2; n++)
;;;749        {
;;;750          if (val & (1<<n))
;;;751          {
;;;752            if (g_drv.USB_P_EP[n])
;;;753              g_drv.USB_P_EP[n](USB_EVT_OUT);
;;;754    
;;;755            LPC_USB->ENDPTCOMPLETE = (1<<n);
;;;756          }
;;;757          if (val & (1<<(n + 16)))
;;;758          {
;;;759            ep_TD [(n << 1) + 1 ].total_bytes &= 0xC0;
;;;760            if (g_drv.USB_P_EP[n])
;;;761              g_drv.USB_P_EP[n](USB_EVT_IN);
;;;762            LPC_USB->ENDPTCOMPLETE = (1<<(n + 16));
;;;763          }
;;;764        }
;;;765      }
;;;766    
;;;767      if (disr & USBSTS_NAKI)
;;;768      {
;;;769    //												  	LPC_UART1->THR = 'N';
;;;770    //												  	LPC_UART1->THR = '\n';
;;;771        val = LPC_USB->ENDPTNAK;
;;;772        val &= LPC_USB->ENDPTNAKEN;
;;;773        /* handle NAK interrupts */
;;;774        if (val)
;;;775        {
;;;776          for (n = 0; n < EP_NUM_MAX / 2; n++)
;;;777          {
;;;778            if (val & (1<<n))
;;;779            {
;;;780              if (g_drv.USB_P_EP[n])
;;;781                g_drv.USB_P_EP[n](USB_EVT_OUT_NAK);
;;;782            }
;;;783            if (val & (1<<(n + 16)))
;;;784            {
;;;785              if (g_drv.USB_P_EP[n])
;;;786                g_drv.USB_P_EP[n](USB_EVT_IN_NAK);
;;;787            }
;;;788          }
;;;789          LPC_USB->ENDPTNAK = val;
;;;790        }
;;;791      }
;;;792    
;;;793      /* Start of Frame Interrupt */
;;;794      if (disr & USBSTS_SRI)
;;;795      {
;;;796    //												  	LPC_UART1->THR = 'F';
;;;797    //												  	LPC_UART1->THR = '\n';
;;;798        if (g_drv.USB_SOF_Event)
;;;799          g_drv.USB_SOF_Event();
;;;800      }
;;;801    
;;;802      /* Error Interrupt */
;;;803      if (disr & USBSTS_UEI)
;;;804      {
;;;805    //													  LPC_UART1->THR = 'E';
;;;806    //													  	LPC_UART1->THR = '\n';
;;;807        if (g_drv.USB_Error_Event)
;;;808          g_drv.USB_Error_Event(disr);
;;;809      }
;;;810    
;;;811    //    LPC_UART1->THR = 'r';
;;;812    //  	LPC_UART1->THR = '\n';
;;;813    //isr_end:
;;;814    //  LPC_VIC->VectAddr = 0;                   /* Acknowledge Interrupt */
;;;815      return;
;;;816    }
000022  bd70              POP      {r4-r6,pc}
                  |L2.36|
000024  f4067080          AND      r0,r6,#0x100          ;701
000028  b128              CBZ      r0,|L2.54|
00002a  4863              LDR      r0,|L2.440|
00002c  68c0              LDR      r0,[r0,#0xc]          ;705  ; g_drv
00002e  b110              CBZ      r0,|L2.54|
000030  4961              LDR      r1,|L2.440|
000032  68c8              LDR      r0,[r1,#0xc]          ;706  ; g_drv
000034  4780              BLX      r0                    ;706
                  |L2.54|
000036  f0060004          AND      r0,r6,#4              ;709
00003a  b170              CBZ      r0,|L2.90|
00003c  485c              LDR      r0,|L2.432|
00003e  3040              ADDS     r0,r0,#0x40           ;714
000040  6800              LDR      r0,[r0,#0]            ;714
000042  f4007000          AND      r0,r0,#0x200          ;714
000046  b110              CBZ      r0,|L2.78|
000048  2001              MOVS     r0,#1                 ;715
00004a  495c              LDR      r1,|L2.444|
00004c  6008              STR      r0,[r1,#0]            ;715  ; DevStatusFS2HS
                  |L2.78|
00004e  485a              LDR      r0,|L2.440|
000050  6900              LDR      r0,[r0,#0x10]         ;717  ; g_drv
000052  b110              CBZ      r0,|L2.90|
000054  4958              LDR      r1,|L2.440|
000056  6908              LDR      r0,[r1,#0x10]         ;718  ; g_drv
000058  4780              BLX      r0                    ;718
                  |L2.90|
00005a  4855              LDR      r0,|L2.432|
00005c  3068              ADDS     r0,r0,#0x68           ;722
00005e  6805              LDR      r5,[r0,#0]            ;722
000060  b195              CBZ      r5,|L2.136|
000062  1380              ASRS     r0,r0,#14             ;730
000064  4952              LDR      r1,|L2.432|
000066  3178              ADDS     r1,r1,#0x78           ;730
000068  6008              STR      r0,[r1,#0]            ;730
00006a  4852              LDR      r0,|L2.436|
00006c  f8d0017c          LDR      r0,[r0,#0x17c]        ;732
000070  f0401001          ORR      r0,r0,#0x10001        ;732
000074  494f              LDR      r1,|L2.436|
000076  f8c1017c          STR      r0,[r1,#0x17c]        ;732
00007a  484f              LDR      r0,|L2.440|
00007c  6ac0              LDR      r0,[r0,#0x2c]         ;733  ; g_drv
00007e  b118              CBZ      r0,|L2.136|
000080  484d              LDR      r0,|L2.440|
000082  6ac1              LDR      r1,[r0,#0x2c]         ;736  ; g_drv
000084  2001              MOVS     r0,#1                 ;736
000086  4788              BLX      r1                    ;736
                  |L2.136|
000088  4849              LDR      r0,|L2.432|
00008a  3078              ADDS     r0,r0,#0x78           ;741
00008c  6805              LDR      r5,[r0,#0]            ;741
00008e  2d00              CMP      r5,#0                 ;742
000090  d044              BEQ      |L2.284|
000092  4847              LDR      r0,|L2.432|
000094  3034              ADDS     r0,r0,#0x34           ;747
000096  6005              STR      r5,[r0,#0]            ;747
000098  2400              MOVS     r4,#0                 ;748
00009a  e03d              B        |L2.280|
                  |L2.156|
00009c  2001              MOVS     r0,#1                 ;750
00009e  40a0              LSLS     r0,r0,r4              ;750
0000a0  4028              ANDS     r0,r0,r5              ;750
0000a2  b178              CBZ      r0,|L2.196|
0000a4  4844              LDR      r0,|L2.440|
0000a6  302c              ADDS     r0,r0,#0x2c           ;752
0000a8  f8500024          LDR      r0,[r0,r4,LSL #2]     ;752
0000ac  b128              CBZ      r0,|L2.186|
0000ae  4842              LDR      r0,|L2.440|
0000b0  302c              ADDS     r0,r0,#0x2c           ;753
0000b2  f8501024          LDR      r1,[r0,r4,LSL #2]     ;753
0000b6  2002              MOVS     r0,#2                 ;753
0000b8  4788              BLX      r1                    ;753
                  |L2.186|
0000ba  2001              MOVS     r0,#1                 ;755
0000bc  40a0              LSLS     r0,r0,r4              ;755
0000be  493c              LDR      r1,|L2.432|
0000c0  3178              ADDS     r1,r1,#0x78           ;755
0000c2  6008              STR      r0,[r1,#0]            ;755
                  |L2.196|
0000c4  f1040010          ADD      r0,r4,#0x10           ;757
0000c8  2101              MOVS     r1,#1                 ;757
0000ca  fa01f000          LSL      r0,r1,r0              ;757
0000ce  4028              ANDS     r0,r0,r5              ;757
0000d0  b308              CBZ      r0,|L2.278|
0000d2  2001              MOVS     r0,#1                 ;759
0000d4  eb000044          ADD      r0,r0,r4,LSL #1       ;759
0000d8  4939              LDR      r1,|L2.448|
0000da  eb011040          ADD      r0,r1,r0,LSL #5       ;759
0000de  6840              LDR      r0,[r0,#4]            ;759
0000e0  f00000c0          AND      r0,r0,#0xc0           ;759
0000e4  2101              MOVS     r1,#1                 ;759
0000e6  eb010144          ADD      r1,r1,r4,LSL #1       ;759
0000ea  4a35              LDR      r2,|L2.448|
0000ec  eb021141          ADD      r1,r2,r1,LSL #5       ;759
0000f0  6048              STR      r0,[r1,#4]            ;759
0000f2  4831              LDR      r0,|L2.440|
0000f4  302c              ADDS     r0,r0,#0x2c           ;760
0000f6  f8500024          LDR      r0,[r0,r4,LSL #2]     ;760
0000fa  b128              CBZ      r0,|L2.264|
0000fc  482e              LDR      r0,|L2.440|
0000fe  302c              ADDS     r0,r0,#0x2c           ;761
000100  f8501024          LDR      r1,[r0,r4,LSL #2]     ;761
000104  2003              MOVS     r0,#3                 ;761
000106  4788              BLX      r1                    ;761
                  |L2.264|
000108  f1040010          ADD      r0,r4,#0x10           ;762
00010c  2101              MOVS     r1,#1                 ;762
00010e  4081              LSLS     r1,r1,r0              ;762
000110  4827              LDR      r0,|L2.432|
000112  3078              ADDS     r0,r0,#0x78           ;762
000114  6001              STR      r1,[r0,#0]            ;762
                  |L2.278|
000116  1c64              ADDS     r4,r4,#1              ;748
                  |L2.280|
000118  2c04              CMP      r4,#4                 ;748
00011a  d3bf              BCC      |L2.156|
                  |L2.284|
00011c  f4063080          AND      r0,r6,#0x10000        ;767
000120  b380              CBZ      r0,|L2.388|
000122  4823              LDR      r0,|L2.432|
000124  3034              ADDS     r0,r0,#0x34           ;771
000126  6805              LDR      r5,[r0,#0]            ;771
000128  4822              LDR      r0,|L2.436|
00012a  f8d0017c          LDR      r0,[r0,#0x17c]        ;772
00012e  4005              ANDS     r5,r5,r0              ;772
000130  b345              CBZ      r5,|L2.388|
000132  2400              MOVS     r4,#0                 ;776
000134  e021              B        |L2.378|
                  |L2.310|
000136  2001              MOVS     r0,#1                 ;778
000138  40a0              LSLS     r0,r0,r4              ;778
00013a  4028              ANDS     r0,r0,r5              ;778
00013c  b150              CBZ      r0,|L2.340|
00013e  481e              LDR      r0,|L2.440|
000140  302c              ADDS     r0,r0,#0x2c           ;780
000142  f8500024          LDR      r0,[r0,r4,LSL #2]     ;780
000146  b128              CBZ      r0,|L2.340|
000148  481b              LDR      r0,|L2.440|
00014a  302c              ADDS     r0,r0,#0x2c           ;781
00014c  f8501024          LDR      r1,[r0,r4,LSL #2]     ;781
000150  2004              MOVS     r0,#4                 ;781
000152  4788              BLX      r1                    ;781
                  |L2.340|
000154  f1040010          ADD      r0,r4,#0x10           ;783
000158  2101              MOVS     r1,#1                 ;783
00015a  fa01f000          LSL      r0,r1,r0              ;783
00015e  4028              ANDS     r0,r0,r5              ;783
000160  b150              CBZ      r0,|L2.376|
000162  4815              LDR      r0,|L2.440|
000164  302c              ADDS     r0,r0,#0x2c           ;785
000166  f8500024          LDR      r0,[r0,r4,LSL #2]     ;785
00016a  b128              CBZ      r0,|L2.376|
00016c  4812              LDR      r0,|L2.440|
00016e  302c              ADDS     r0,r0,#0x2c           ;786
000170  f8501024          LDR      r1,[r0,r4,LSL #2]     ;786
000174  2005              MOVS     r0,#5                 ;786
000176  4788              BLX      r1                    ;786
                  |L2.376|
000178  1c64              ADDS     r4,r4,#1              ;776
                  |L2.378|
00017a  2c04              CMP      r4,#4                 ;776
00017c  d3db              BCC      |L2.310|
00017e  480c              LDR      r0,|L2.432|
000180  3034              ADDS     r0,r0,#0x34           ;789
000182  6005              STR      r5,[r0,#0]            ;789
                  |L2.388|
000184  f0060080          AND      r0,r6,#0x80           ;794
000188  b128              CBZ      r0,|L2.406|
00018a  480b              LDR      r0,|L2.440|
00018c  6980              LDR      r0,[r0,#0x18]         ;798  ; g_drv
00018e  b110              CBZ      r0,|L2.406|
000190  4909              LDR      r1,|L2.440|
000192  6988              LDR      r0,[r1,#0x18]         ;799  ; g_drv
000194  4780              BLX      r0                    ;799
                  |L2.406|
000196  f0060002          AND      r0,r6,#2              ;803
00019a  b130              CBZ      r0,|L2.426|
00019c  4806              LDR      r0,|L2.440|
00019e  69c0              LDR      r0,[r0,#0x1c]         ;807  ; g_drv
0001a0  b118              CBZ      r0,|L2.426|
0001a2  4805              LDR      r0,|L2.440|
0001a4  69c1              LDR      r1,[r0,#0x1c]         ;808  ; g_drv
0001a6  4630              MOV      r0,r6                 ;808
0001a8  4788              BLX      r1                    ;808
                  |L2.426|
0001aa  bf00              NOP                            ;815
0001ac  e739              B        |L2.34|
                          ENDP

0001ae  0000              DCW      0x0000
                  |L2.432|
                          DCD      0x40006144
                  |L2.436|
                          DCD      0x40006000
                  |L2.440|
                          DCD      g_drv
                  |L2.444|
                          DCD      DevStatusFS2HS
                  |L2.448|
                          DCD      ep_TD

                          AREA ||i.USB_ClrStallEP||, CODE, READONLY, ALIGN=2

                  USB_ClrStallEP PROC
;;;500    
;;;501    void USB_ClrStallEP (uint32_t EPNum) {
000000  4601              MOV      r1,r0
;;;502      uint32_t lep;
;;;503    
;;;504      lep = EPNum & 0x0F;
000002  f001000f          AND      r0,r1,#0xf
;;;505      if (EPNum & 0x80)
000006  f0010280          AND      r2,r1,#0x80
00000a  b17a              CBZ      r2,|L3.44|
;;;506      {
;;;507        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] &= ~EPCTRL_TXS;
00000c  4a0f              LDR      r2,|L3.76|
00000e  f8522020          LDR      r2,[r2,r0,LSL #2]
000012  f4223380          BIC      r3,r2,#0x10000
000016  4a0d              LDR      r2,|L3.76|
000018  f8423020          STR      r3,[r2,r0,LSL #2]
;;;508        /* reset data toggle */
;;;509        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] |= EPCTRL_TXR;
00001c  f8522020          LDR      r2,[r2,r0,LSL #2]
000020  f4420380          ORR      r3,r2,#0x400000
000024  4a09              LDR      r2,|L3.76|
000026  f8423020          STR      r3,[r2,r0,LSL #2]
00002a  e00e              B        |L3.74|
                  |L3.44|
;;;510      }
;;;511      else
;;;512      {
;;;513        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] &= ~EPCTRL_RXS;
00002c  4a07              LDR      r2,|L3.76|
00002e  f8522020          LDR      r2,[r2,r0,LSL #2]
000032  f0220301          BIC      r3,r2,#1
000036  4a05              LDR      r2,|L3.76|
000038  f8423020          STR      r3,[r2,r0,LSL #2]
;;;514        /* reset data toggle */
;;;515        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] |= EPCTRL_RXR;
00003c  f8522020          LDR      r2,[r2,r0,LSL #2]
000040  f0420340          ORR      r3,r2,#0x40
000044  4a01              LDR      r2,|L3.76|
000046  f8423020          STR      r3,[r2,r0,LSL #2]
                  |L3.74|
;;;516      }
;;;517    }
00004a  4770              BX       lr
;;;518    
                          ENDP

                  |L3.76|
                          DCD      0x400061c0

                          AREA ||i.USB_ConfigEP||, CODE, READONLY, ALIGN=2

                  USB_ConfigEP PROC
;;;340    
;;;341    void USB_ConfigEP (USB_ENDPOINT_DESCRIPTOR *pEPD) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4603              MOV      r3,r0
;;;342      uint32_t num, lep;
;;;343      uint32_t ep_cfg;
;;;344      uint8_t  bmAttributes;
;;;345    
;;;346      lep = pEPD->bEndpointAddress & 0x7F;
000004  7898              LDRB     r0,[r3,#2]
000006  f000077f          AND      r7,r0,#0x7f
;;;347      num = EPAdr(pEPD->bEndpointAddress);
00000a  7898              LDRB     r0,[r3,#2]
00000c  f7fffffe          BL       EPAdr
000010  4605              MOV      r5,r0
;;;348    
;;;349      ep_cfg = ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep];
000012  481d              LDR      r0,|L4.136|
000014  f8504027          LDR      r4,[r0,r7,LSL #2]
;;;350      /* mask the attributes we are not-intersetd in */
;;;351      bmAttributes = pEPD->bmAttributes & USB_ENDPOINT_TYPE_MASK;
000018  78d8              LDRB     r0,[r3,#3]
00001a  f0000603          AND      r6,r0,#3
;;;352      /* set EP type */
;;;353      if (bmAttributes != USB_ENDPOINT_TYPE_ISOCHRONOUS)
00001e  2e01              CMP      r6,#1
000020  d012              BEQ      |L4.72|
;;;354      {
;;;355        /* init EP capabilities */
;;;356        ep_QH[num].cap  = QH_MAXP(pEPD->wMaxPacketSize)
000022  8898              LDRH     r0,[r3,#4]
000024  f3c00009          UBFX     r0,r0,#0,#10
000028  f44f4100          MOV      r1,#0x8000
00002c  ea414000          ORR      r0,r1,r0,LSL #16
000030  f0405000          ORR      r0,r0,#0x20000000
000034  4915              LDR      r1,|L4.140|
000036  eb011185          ADD      r1,r1,r5,LSL #6
00003a  6008              STR      r0,[r1,#0]
;;;357                          | QH_IOS | QH_ZLT ;
;;;358        /* The next DTD pointer is INVALID */
;;;359        ep_TD[num].next_dTD = 0x01 ;
00003c  2001              MOVS     r0,#1
00003e  4914              LDR      r1,|L4.144|
000040  eb011145          ADD      r1,r1,r5,LSL #5
000044  6008              STR      r0,[r1,#0]
000046  e005              B        |L4.84|
                  |L4.72|
;;;360      }
;;;361      else
;;;362      {
;;;363        /* init EP capabilities */
;;;364        ep_QH[num].cap  = QH_MAXP(0x400) | QH_ZLT;
000048  f04f5000          MOV      r0,#0x20000000
00004c  490f              LDR      r1,|L4.140|
00004e  eb011185          ADD      r1,r1,r5,LSL #6
000052  6008              STR      r0,[r1,#0]
                  |L4.84|
;;;365      }
;;;366      /* setup EP control register */
;;;367      if (pEPD->bEndpointAddress & 0x80)
000054  7898              LDRB     r0,[r3,#2]
000056  f0000080          AND      r0,r0,#0x80
00005a  b140              CBZ      r0,|L4.110|
;;;368      {
;;;369        ep_cfg &= ~0xFFFF0000;
00005c  b2a4              UXTH     r4,r4
;;;370        ep_cfg |= EPCTRL_TX_TYPE(bmAttributes)
00005e  f0060003          AND      r0,r6,#3
000062  f44f0180          MOV      r1,#0x400000
000066  ea414080          ORR      r0,r1,r0,LSL #18
00006a  4304              ORRS     r4,r4,r0
00006c  e007              B        |L4.126|
                  |L4.110|
;;;371                  | EPCTRL_TXR;
;;;372      }
;;;373      else
;;;374      {
;;;375        ep_cfg &= ~0xFFFF;
00006e  f36f040f          BFC      r4,#0,#16
;;;376        ep_cfg |= EPCTRL_RX_TYPE(bmAttributes)
000072  f0060003          AND      r0,r6,#3
000076  2140              MOVS     r1,#0x40
000078  ea410080          ORR      r0,r1,r0,LSL #2
00007c  4304              ORRS     r4,r4,r0
                  |L4.126|
;;;377                  | EPCTRL_RXR;
;;;378      }
;;;379      ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] = ep_cfg;
00007e  4802              LDR      r0,|L4.136|
000080  f8404027          STR      r4,[r0,r7,LSL #2]
;;;380      return;
;;;381    }
000084  bdf0              POP      {r4-r7,pc}
;;;382    
                          ENDP

000086  0000              DCW      0x0000
                  |L4.136|
                          DCD      0x400061c0
                  |L4.140|
                          DCD      ep_QH
                  |L4.144|
                          DCD      ep_TD

                          AREA ||i.USB_Configure||, CODE, READONLY, ALIGN=1

                  USB_Configure PROC
;;;329    
;;;330    void USB_Configure (uint32_t cfg) {
000000  4770              BX       lr
;;;331    
;;;332    }
;;;333    
                          ENDP


                          AREA ||i.USB_Connect||, CODE, READONLY, ALIGN=2

                  USB_Connect PROC
;;;167     */
;;;168    void USB_Connect (uint32_t con) {
000000  b138              CBZ      r0,|L6.18|
;;;169      if (con)
;;;170        LPC_USB->USBCMD_D |= USBCMD_RS;
000002  4908              LDR      r1,|L6.36|
000004  6809              LDR      r1,[r1,#0]
000006  f0410101          ORR      r1,r1,#1
00000a  4a07              LDR      r2,|L6.40|
00000c  f8c21140          STR      r1,[r2,#0x140]
000010  e006              B        |L6.32|
                  |L6.18|
;;;171      else
;;;172        LPC_USB->USBCMD_D &= ~USBCMD_RS;
000012  4904              LDR      r1,|L6.36|
000014  6809              LDR      r1,[r1,#0]
000016  f0210101          BIC      r1,r1,#1
00001a  4a03              LDR      r2,|L6.40|
00001c  f8c21140          STR      r1,[r2,#0x140]
                  |L6.32|
;;;173    }
000020  4770              BX       lr
;;;174    
                          ENDP

000022  0000              DCW      0x0000
                  |L6.36|
                          DCD      0x40006140
                  |L6.40|
                          DCD      0x40006000

                          AREA ||i.USB_DirCtrlEP||, CODE, READONLY, ALIGN=1

                  USB_DirCtrlEP PROC
;;;388    
;;;389    void USB_DirCtrlEP (uint32_t dir) {
000000  4770              BX       lr
;;;390      /* Not needed */
;;;391    }
;;;392    
                          ENDP


                          AREA ||i.USB_DisableEP||, CODE, READONLY, ALIGN=2

                  USB_DisableEP PROC
;;;427    
;;;428    void USB_DisableEP (uint32_t EPNum) {
000000  b510              PUSH     {r4,lr}
;;;429      uint32_t lep, bitpos;
;;;430    
;;;431      lep = EPNum & 0x0F;
000002  f000010f          AND      r1,r0,#0xf
;;;432      if (EPNum & 0x80)
000006  f0000380          AND      r3,r0,#0x80
00000a  b143              CBZ      r3,|L8.30|
;;;433      {
;;;434        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] &= ~EPCTRL_TXE;
00000c  4b12              LDR      r3,|L8.88|
00000e  f8533021          LDR      r3,[r3,r1,LSL #2]
000012  f4230400          BIC      r4,r3,#0x800000
000016  4b10              LDR      r3,|L8.88|
000018  f8434021          STR      r4,[r3,r1,LSL #2]
00001c  e01b              B        |L8.86|
                  |L8.30|
;;;435      }
;;;436      else
;;;437      {
;;;438        /* disable NAK interrupt */
;;;439        bitpos = USB_EP_BITPOS(EPNum);
00001e  f0000380          AND      r3,r0,#0x80
000022  b123              CBZ      r3,|L8.46|
000024  f0000307          AND      r3,r0,#7
000028  f0430310          ORR      r3,r3,#0x10
00002c  e001              B        |L8.50|
                  |L8.46|
00002e  f0000307          AND      r3,r0,#7
                  |L8.50|
000032  461a              MOV      r2,r3
;;;440        LPC_USB->ENDPTNAKEN &= ~(1<<bitpos);
000034  4b08              LDR      r3,|L8.88|
000036  3b44              SUBS     r3,r3,#0x44
000038  681b              LDR      r3,[r3,#0]
00003a  2401              MOVS     r4,#1
00003c  4094              LSLS     r4,r4,r2
00003e  43a3              BICS     r3,r3,r4
000040  4c06              LDR      r4,|L8.92|
000042  f8c4317c          STR      r3,[r4,#0x17c]
;;;441        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] &= ~EPCTRL_RXE;
000046  4b04              LDR      r3,|L8.88|
000048  f8533021          LDR      r3,[r3,r1,LSL #2]
00004c  f0230480          BIC      r4,r3,#0x80
000050  4b01              LDR      r3,|L8.88|
000052  f8434021          STR      r4,[r3,r1,LSL #2]
                  |L8.86|
;;;442      }
;;;443    }
000056  bd10              POP      {r4,pc}
;;;444    
                          ENDP

                  |L8.88|
                          DCD      0x400061c0
                  |L8.92|
                          DCD      0x40006000

                          AREA ||i.USB_EnableEP||, CODE, READONLY, ALIGN=2

                  USB_EnableEP PROC
;;;401    
;;;402    void USB_EnableEP (uint32_t EPNum) {
000000  b510              PUSH     {r4,lr}
;;;403      uint32_t lep, bitpos;
;;;404    
;;;405      lep = EPNum & 0x0F;
000002  f000010f          AND      r1,r0,#0xf
;;;406    
;;;407      if (EPNum & 0x80)
000006  f0000380          AND      r3,r0,#0x80
00000a  b143              CBZ      r3,|L9.30|
;;;408      {
;;;409        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] |= EPCTRL_TXE;
00000c  4b12              LDR      r3,|L9.88|
00000e  f8533021          LDR      r3,[r3,r1,LSL #2]
000012  f4430400          ORR      r4,r3,#0x800000
000016  4b10              LDR      r3,|L9.88|
000018  f8434021          STR      r4,[r3,r1,LSL #2]
00001c  e01b              B        |L9.86|
                  |L9.30|
;;;410      }
;;;411      else
;;;412      {
;;;413        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] |= EPCTRL_RXE;
00001e  4b0e              LDR      r3,|L9.88|
000020  f8533021          LDR      r3,[r3,r1,LSL #2]
000024  f0430480          ORR      r4,r3,#0x80
000028  4b0b              LDR      r3,|L9.88|
00002a  f8434021          STR      r4,[r3,r1,LSL #2]
;;;414        /* enable NAK interrupt */
;;;415        bitpos = USB_EP_BITPOS(EPNum);
00002e  f0000380          AND      r3,r0,#0x80
000032  b123              CBZ      r3,|L9.62|
000034  f0000307          AND      r3,r0,#7
000038  f0430310          ORR      r3,r3,#0x10
00003c  e001              B        |L9.66|
                  |L9.62|
00003e  f0000307          AND      r3,r0,#7
                  |L9.66|
000042  461a              MOV      r2,r3
;;;416        LPC_USB->ENDPTNAKEN |= (1<<bitpos);
000044  4b04              LDR      r3,|L9.88|
000046  3b44              SUBS     r3,r3,#0x44
000048  681b              LDR      r3,[r3,#0]
00004a  2401              MOVS     r4,#1
00004c  4094              LSLS     r4,r4,r2
00004e  4323              ORRS     r3,r3,r4
000050  4c02              LDR      r4,|L9.92|
000052  f8c4317c          STR      r3,[r4,#0x17c]
                  |L9.86|
;;;417      }
;;;418    }
000056  bd10              POP      {r4,pc}
;;;419    
                          ENDP

                  |L9.88|
                          DCD      0x400061c0
                  |L9.92|
                          DCD      0x40006000

                          AREA ||i.USB_Init||, CODE, READONLY, ALIGN=2

                  USB_Init PROC
;;;102    
;;;103    void USB_Init (LPC_USBDRV_INIT_T* cbs)
000000  b510              PUSH     {r4,lr}
;;;104    {
000002  4604              MOV      r4,r0
;;;105      memcpy(&g_drv, cbs, sizeof(LPC_USBDRV_INIT_T));
000004  223c              MOVS     r2,#0x3c
000006  4621              MOV      r1,r4
000008  4823              LDR      r0,|L10.152|
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;106      /*maxp for EP0 should be atleast 8 */
;;;107      if( g_drv.ep0_maxp == 0)
00000e  4822              LDR      r0,|L10.152|
000010  6800              LDR      r0,[r0,#0]  ; g_drv
000012  b910              CBNZ     r0,|L10.26|
;;;108        g_drv.ep0_maxp = 64;
000014  2040              MOVS     r0,#0x40
000016  4920              LDR      r1,|L10.152|
000018  6008              STR      r0,[r1,#0]  ; g_drv
                  |L10.26|
;;;109    
;;;110    #ifdef USE_USB0
;;;111    	scu_pinmux(0x8,1,MD_PLN_FAST,FUNC1);    //  0: motocon pcap0_1          1: usb0 usb0_ind1           2:  nc                      3: gpio4 gpio4_1
00001a  2301              MOVS     r3,#1
00001c  22f0              MOVS     r2,#0xf0
00001e  4619              MOV      r1,r3
000020  2008              MOVS     r0,#8
000022  f7fffffe          BL       scu_pinmux
;;;112    	scu_pinmux(0x8,2,MD_PLN_FAST,FUNC1);    //  0: motocon pcap0_0          1: usb0 usb0_ind0           2:  nc                      3: gpio4 gpio4_2
000026  2301              MOVS     r3,#1
000028  22f0              MOVS     r2,#0xf0
00002a  2102              MOVS     r1,#2
00002c  2008              MOVS     r0,#8
00002e  f7fffffe          BL       scu_pinmux
;;;113    #endif
;;;114    #ifdef USE_USB0
;;;115    	CGU_SetPLL0();
000032  f7fffffe          BL       CGU_SetPLL0
;;;116    	CGU_EnableEntity(CGU_CLKSRC_PLL0, ENABLE);
000036  2101              MOVS     r1,#1
000038  2007              MOVS     r0,#7
00003a  f7fffffe          BL       CGU_EnableEntity
;;;117    	CGU_EntityConnect(CGU_CLKSRC_PLL0, CGU_BASE_USB0);
00003e  2112              MOVS     r1,#0x12
000040  2007              MOVS     r0,#7
000042  f7fffffe          BL       CGU_EntityConnect
;;;118    #else
;;;119    	CGU_EntityConnect(CGU_CLKSRC_PLL1, CGU_BASE_USB1);
;;;120    	/* enable USB phy */
;;;121        LPC_CREG->CREG0 &= ~(1 << 5);
;;;122        /* enable USB1_DP and USB1_DN on chip FS phy */
;;;123        LPC_SCU->SFSUSB = 0x12;
;;;124        /* enable USB1_VBUS */
;;;125        scu_pinmux(0x2, 5, MD_PLN | MD_EZI | MD_ZI, FUNC2);
;;;126    
;;;127    #endif
;;;128    	/* Turn on the phy */
;;;129    #ifdef USE_USB0
;;;130    	LPC_CREG->CREG0 &= ~(1<<5);
000046  4815              LDR      r0,|L10.156|
000048  6840              LDR      r0,[r0,#4]
00004a  f0200020          BIC      r0,r0,#0x20
00004e  4913              LDR      r1,|L10.156|
000050  6048              STR      r0,[r1,#4]
;;;131    #endif
;;;132    	/* reset the controller */
;;;133    	LPC_USB->USBCMD_D = USBCMD_RST;
000052  2002              MOVS     r0,#2
000054  4912              LDR      r1,|L10.160|
000056  6008              STR      r0,[r1,#0]
;;;134    	/* wait for reset to complete */
;;;135    	while (LPC_USB->USBCMD_D & USBCMD_RST);
000058  bf00              NOP      
                  |L10.90|
00005a  4811              LDR      r0,|L10.160|
00005c  6800              LDR      r0,[r0,#0]
00005e  f0000002          AND      r0,r0,#2
000062  2800              CMP      r0,#0
000064  d1f9              BNE      |L10.90|
;;;136    
;;;137    	/* Program the controller to be the USB device controller */
;;;138    	LPC_USB->USBMODE_D =   USBMODE_CM_DEV
000066  201a              MOVS     r0,#0x1a
000068  490d              LDR      r1,|L10.160|
00006a  3168              ADDS     r1,r1,#0x68
00006c  6008              STR      r0,[r1,#0]
;;;139    	                  | USBMODE_SDIS
;;;140    	                  | USBMODE_SLOM ;
;;;141    
;;;142    	/* set OTG transcever in proper state, device is present
;;;143    	on the port(CCS=1), port enable/disable status change(PES=1). */
;;;144    #ifdef USE_USB0	
;;;145    	LPC_USB->OTGSC = (1<<3) | (1<<0) /*| (1<<16)| (1<<24)| (1<<25)| (1<<26)| (1<<27)| (1<<28)| (1<<29)| (1<<30)*/;
00006e  2009              MOVS     r0,#9
000070  490c              LDR      r1,|L10.164|
000072  f8c101a4          STR      r0,[r1,#0x1a4]
;;;146    #else
;;;147    	/* force full speed */
;;;148    	LPC_USB->PORTSC1_D |= (1<<24);
;;;149    #endif
;;;150    
;;;151    #ifdef USE_USB0
;;;152    	NVIC_EnableIRQ(USB0_IRQn); //  enable USB0 interrrupts
000076  2008              MOVS     r0,#8
000078  2101              MOVS     r1,#1
00007a  4081              LSLS     r1,r1,r0
00007c  0942              LSRS     r2,r0,#5
00007e  0092              LSLS     r2,r2,#2
000080  f10222e0          ADD      r2,r2,#0xe000e000
000084  f8c21100          STR      r1,[r2,#0x100]
000088  bf00              NOP      
;;;153    #else
;;;154      	NVIC_EnableIRQ(USB1_IRQn); //  enable USB1 interrrupts
;;;155    #endif
;;;156    
;;;157    	USB_Reset();
00008a  f7fffffe          BL       USB_Reset
;;;158    	USB_SetAddress(0);
00008e  2000              MOVS     r0,#0
000090  f7fffffe          BL       USB_SetAddress
;;;159    	return;
;;;160    }
000094  bd10              POP      {r4,pc}
;;;161    
                          ENDP

000096  0000              DCW      0x0000
                  |L10.152|
                          DCD      g_drv
                  |L10.156|
                          DCD      0x40043000
                  |L10.160|
                          DCD      0x40006140
                  |L10.164|
                          DCD      0x40006000

                          AREA ||i.USB_ProgDTD||, CODE, READONLY, ALIGN=2

                  USB_ProgDTD PROC
;;;527     */
;;;528    void USB_ProgDTD(uint32_t Edpt, uint32_t ptrBuff, uint32_t TsfSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;529    {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
;;;530      DTD_T*  pDTD;
;;;531    
;;;532      pDTD = (DTD_T*)&ep_TD[ Edpt ];
00000a  481e              LDR      r0,|L11.132|
00000c  eb001445          ADD      r4,r0,r5,LSL #5
;;;533    
;;;534      /* Zero out the device transfer descriptors */
;;;535      memset((void*)pDTD, 0, sizeof(DTD_T));
000010  2120              MOVS     r1,#0x20
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       __aeabi_memclr4
;;;536      /* The next DTD pointer is INVALID */
;;;537      pDTD->next_dTD = 0x01 ;
000018  2001              MOVS     r0,#1
00001a  6020              STR      r0,[r4,#0]
;;;538    
;;;539      /* Length */
;;;540      pDTD->total_bytes = ((TsfSize & 0x7fff) << 16);
00001c  0478              LSLS     r0,r7,#17
00001e  0840              LSRS     r0,r0,#1
000020  6060              STR      r0,[r4,#4]
;;;541      pDTD->total_bytes |= TD_IOC ;
000022  6860              LDR      r0,[r4,#4]
000024  f4404000          ORR      r0,r0,#0x8000
000028  6060              STR      r0,[r4,#4]
;;;542      pDTD->total_bytes |= 0x80 ;
00002a  6860              LDR      r0,[r4,#4]
00002c  f0400080          ORR      r0,r0,#0x80
000030  6060              STR      r0,[r4,#4]
;;;543    
;;;544      pDTD->buffer0 = ptrBuff;
000032  60a6              STR      r6,[r4,#8]
;;;545      pDTD->buffer1 = (ptrBuff + 0x1000) & 0xfffff000;
000034  f5065080          ADD      r0,r6,#0x1000
000038  f36f000b          BFC      r0,#0,#12
00003c  60e0              STR      r0,[r4,#0xc]
;;;546      pDTD->buffer2 = (ptrBuff + 0x2000) & 0xfffff000;
00003e  f5065000          ADD      r0,r6,#0x2000
000042  f36f000b          BFC      r0,#0,#12
000046  6120              STR      r0,[r4,#0x10]
;;;547      pDTD->buffer3 = (ptrBuff + 0x3000) & 0xfffff000;
000048  f5065040          ADD      r0,r6,#0x3000
00004c  f36f000b          BFC      r0,#0,#12
000050  6160              STR      r0,[r4,#0x14]
;;;548      pDTD->buffer4 = (ptrBuff + 0x4000) & 0xfffff000;
000052  f5064080          ADD      r0,r6,#0x4000
000056  f36f000b          BFC      r0,#0,#12
00005a  61a0              STR      r0,[r4,#0x18]
;;;549    
;;;550      ep_QH[Edpt].next_dTD = (uint32_t)(&ep_TD[ Edpt ]);
00005c  4809              LDR      r0,|L11.132|
00005e  eb001045          ADD      r0,r0,r5,LSL #5
000062  4909              LDR      r1,|L11.136|
000064  eb011185          ADD      r1,r1,r5,LSL #6
000068  6088              STR      r0,[r1,#8]
;;;551      ep_QH[Edpt].total_bytes &= (~0xC0) ;
00006a  4807              LDR      r0,|L11.136|
00006c  eb001085          ADD      r0,r0,r5,LSL #6
000070  68c0              LDR      r0,[r0,#0xc]
000072  f02000c0          BIC      r0,r0,#0xc0
000076  4904              LDR      r1,|L11.136|
000078  eb011185          ADD      r1,r1,r5,LSL #6
00007c  60c8              STR      r0,[r1,#0xc]
;;;552    }
00007e  e8bd81f0          POP      {r4-r8,pc}
;;;553    
                          ENDP

000082  0000              DCW      0x0000
                  |L11.132|
                          DCD      ep_TD
                  |L11.136|
                          DCD      ep_QH

                          AREA ||i.USB_ReadEP||, CODE, READONLY, ALIGN=2

                  USB_ReadEP PROC
;;;630    
;;;631    uint32_t USB_ReadEP(uint32_t EPNum, uint8_t *pData)
000000  b5f0              PUSH     {r4-r7,lr}
;;;632    {
000002  4603              MOV      r3,r0
000004  460f              MOV      r7,r1
;;;633      uint32_t cnt, n;
;;;634      DTD_T*  pDTD ;
;;;635    
;;;636      n = EPAdr(EPNum);
000006  4618              MOV      r0,r3
000008  f7fffffe          BL       EPAdr
00000c  4605              MOV      r5,r0
;;;637      pDTD = (DTD_T*)&ep_TD[n];
00000e  4807              LDR      r0,|L12.44|
000010  eb001645          ADD      r6,r0,r5,LSL #5
;;;638    
;;;639      /* return the total bytes read */
;;;640      cnt  = (pDTD->total_bytes >> 16) & 0x7FFF;
000014  6870              LDR      r0,[r6,#4]
000016  f3c0440e          UBFX     r4,r0,#16,#15
;;;641      cnt = ep_read_len[EPNum & 0x0F] - cnt;
00001a  f003000f          AND      r0,r3,#0xf
00001e  4904              LDR      r1,|L12.48|
000020  f8510020          LDR      r0,[r1,r0,LSL #2]
000024  1b04              SUBS     r4,r0,r4
;;;642      return (cnt);	   
000026  4620              MOV      r0,r4
;;;643    }
000028  bdf0              POP      {r4-r7,pc}
;;;644    
                          ENDP

00002a  0000              DCW      0x0000
                  |L12.44|
                          DCD      ep_TD
                  |L12.48|
                          DCD      ep_read_len

                          AREA ||i.USB_ReadReqEP||, CODE, READONLY, ALIGN=2

                  USB_ReadReqEP PROC
;;;610    
;;;611    uint32_t USB_ReadReqEP(uint32_t EPNum, uint8_t *pData, uint32_t len)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;612    {
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
000008  4615              MOV      r5,r2
;;;613      uint32_t num = EPAdr(EPNum);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       EPAdr
000010  4607              MOV      r7,r0
;;;614      uint32_t n = USB_EP_BITPOS(EPNum);
000012  f0040080          AND      r0,r4,#0x80
000016  b120              CBZ      r0,|L13.34|
000018  f0040007          AND      r0,r4,#7
00001c  f0400010          ORR      r0,r0,#0x10
000020  e001              B        |L13.38|
                  |L13.34|
000022  f0040007          AND      r0,r4,#7
                  |L13.38|
000026  4680              MOV      r8,r0
;;;615    
;;;616      USB_ProgDTD(num, (uint32_t)pData, len);
000028  462a              MOV      r2,r5
00002a  4631              MOV      r1,r6
00002c  4638              MOV      r0,r7
00002e  f7fffffe          BL       USB_ProgDTD
;;;617      ep_read_len[EPNum & 0x0F] = len;
000032  f004000f          AND      r0,r4,#0xf
000036  4907              LDR      r1,|L13.84|
000038  f8415020          STR      r5,[r1,r0,LSL #2]
;;;618      /* prime the endpoint for read */
;;;619      LPC_USB->ENDPTPRIME |= (1<<n);
00003c  4806              LDR      r0,|L13.88|
00003e  6800              LDR      r0,[r0,#0]
000040  2101              MOVS     r1,#1
000042  fa01f108          LSL      r1,r1,r8
000046  4308              ORRS     r0,r0,r1
000048  4904              LDR      r1,|L13.92|
00004a  f8c101b0          STR      r0,[r1,#0x1b0]
;;;620      return len;
00004e  4628              MOV      r0,r5
;;;621    }
000050  e8bd81f0          POP      {r4-r8,pc}
;;;622    /*
                          ENDP

                  |L13.84|
                          DCD      ep_read_len
                  |L13.88|
                          DCD      0x400061b0
                  |L13.92|
                          DCD      0x40006000

                          AREA ||i.USB_ReadSetupPkt||, CODE, READONLY, ALIGN=2

                  USB_ReadSetupPkt PROC
;;;561    */
;;;562    uint32_t USB_ReadSetupPkt(uint32_t EPNum, uint32_t *pData)
000000  b5f0              PUSH     {r4-r7,lr}
;;;563    {
000002  4606              MOV      r6,r0
000004  460b              MOV      r3,r1
;;;564      uint32_t setup_int, cnt = 0;
000006  2700              MOVS     r7,#0
;;;565      uint32_t num = EPAdr(EPNum);
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       EPAdr
00000e  4605              MOV      r5,r0
;;;566    
;;;567      setup_int = LPC_USB->ENDPTSETUPSTAT ;
000010  4819              LDR      r0,|L14.120|
000012  6804              LDR      r4,[r0,#0]
;;;568      /* Clear the setup interrupt */
;;;569      LPC_USB->ENDPTSETUPSTAT = setup_int;
000014  4819              LDR      r0,|L14.124|
000016  f8c041ac          STR      r4,[r0,#0x1ac]
;;;570    
;;;571      /* ********************************** */
;;;572      /*  Check if we have received a setup */
;;;573      /* ********************************** */
;;;574      if (setup_int & (1<<0))                    /* Check only for bit 0 */
00001a  f0040001          AND      r0,r4,#1
00001e  b308              CBZ      r0,|L14.100|
;;;575        /* No setup are admitted on other endpoints than 0 */
;;;576      {
;;;577        do
000020  bf00              NOP      
                  |L14.34|
;;;578        {
;;;579          /* Setup in a setup - must considere only the second setup */
;;;580          /*- Set the tripwire */
;;;581          LPC_USB->USBCMD_D |= USBCMD_SUTW ;
000022  4815              LDR      r0,|L14.120|
000024  386c              SUBS     r0,r0,#0x6c
000026  6800              LDR      r0,[r0,#0]
000028  f4405000          ORR      r0,r0,#0x2000
00002c  4913              LDR      r1,|L14.124|
00002e  f8c10140          STR      r0,[r1,#0x140]
;;;582    
;;;583          /* Transfer Set-up data to the gtmudsCore_Request buffer */
;;;584          pData[0] = ep_QH[num].setup[0];
000032  4813              LDR      r0,|L14.128|
000034  eb001085          ADD      r0,r0,r5,LSL #6
000038  6a80              LDR      r0,[r0,#0x28]
00003a  6018              STR      r0,[r3,#0]
;;;585          pData[1] = ep_QH[num].setup[1];
00003c  4810              LDR      r0,|L14.128|
00003e  eb001085          ADD      r0,r0,r5,LSL #6
000042  6ac0              LDR      r0,[r0,#0x2c]
000044  6058              STR      r0,[r3,#4]
;;;586          cnt = 8;
000046  2708              MOVS     r7,#8
;;;587    
;;;588        }
;;;589        while (!(LPC_USB->USBCMD_D & USBCMD_SUTW)) ;
000048  480b              LDR      r0,|L14.120|
00004a  386c              SUBS     r0,r0,#0x6c
00004c  6800              LDR      r0,[r0,#0]
00004e  f4005000          AND      r0,r0,#0x2000
000052  2800              CMP      r0,#0
000054  d0e5              BEQ      |L14.34|
;;;590    
;;;591        /* setup in a setup - Clear the tripwire */
;;;592        LPC_USB->USBCMD_D &= (~USBCMD_SUTW);
000056  4808              LDR      r0,|L14.120|
000058  386c              SUBS     r0,r0,#0x6c
00005a  6800              LDR      r0,[r0,#0]
00005c  f4205000          BIC      r0,r0,#0x2000
000060  f8c10140          STR      r0,[r1,#0x140]
                  |L14.100|
;;;593      }
;;;594      while ((setup_int = LPC_USB->ENDPTSETUPSTAT) != 0)
000064  e001              B        |L14.106|
                  |L14.102|
;;;595      {
;;;596        /* Clear the setup interrupt */
;;;597        LPC_USB->ENDPTSETUPSTAT = setup_int;
000066  4804              LDR      r0,|L14.120|
000068  6004              STR      r4,[r0,#0]
                  |L14.106|
00006a  4803              LDR      r0,|L14.120|
00006c  6800              LDR      r0,[r0,#0]            ;594
00006e  0004              MOVS     r4,r0                 ;594
000070  d1f9              BNE      |L14.102|
;;;598      }
;;;599      return cnt;
000072  4638              MOV      r0,r7
;;;600    }
000074  bdf0              POP      {r4-r7,pc}
;;;601    
                          ENDP

000076  0000              DCW      0x0000
                  |L14.120|
                          DCD      0x400061ac
                  |L14.124|
                          DCD      0x40006000
                  |L14.128|
                          DCD      ep_QH

                          AREA ||i.USB_Reset||, CODE, READONLY, ALIGN=2

                  USB_Reset PROC
;;;181    
;;;182    void USB_Reset (void)
000000  b510              PUSH     {r4,lr}
;;;183    {
;;;184      uint32_t i;
;;;185    
;;;186      DevStatusFS2HS = FALSE;
000002  2000              MOVS     r0,#0
000004  4943              LDR      r1,|L15.276|
000006  6008              STR      r0,[r1,#0]  ; DevStatusFS2HS
;;;187      /* disable all EPs */
;;;188      LPC_USB->ENDPTCTRL0 &= ~(EPCTRL_RXE | EPCTRL_TXE);
000008  4843              LDR      r0,|L15.280|
00000a  6800              LDR      r0,[r0,#0]
00000c  f0201080          BIC      r0,r0,#0x800080
000010  4942              LDR      r1,|L15.284|
000012  f8c101c0          STR      r0,[r1,#0x1c0]
;;;189      LPC_USB->ENDPTCTRL2 &= ~(EPCTRL_RXE | EPCTRL_TXE);
000016  4608              MOV      r0,r1
000018  f8d001c8          LDR      r0,[r0,#0x1c8]
00001c  f0201080          BIC      r0,r0,#0x800080
000020  f8c101c8          STR      r0,[r1,#0x1c8]
;;;190      LPC_USB->ENDPTCTRL3 &= ~(EPCTRL_RXE | EPCTRL_TXE);
000024  4608              MOV      r0,r1
000026  f8d001cc          LDR      r0,[r0,#0x1cc]
00002a  f0201080          BIC      r0,r0,#0x800080
00002e  493a              LDR      r1,|L15.280|
000030  310c              ADDS     r1,r1,#0xc
000032  6008              STR      r0,[r1,#0]
;;;191    
;;;192      /* Clear all pending interrupts */
;;;193      LPC_USB->ENDPTNAK   = 0xFFFFFFFF;
000034  f04f30ff          MOV      r0,#0xffffffff
000038  4937              LDR      r1,|L15.280|
00003a  3948              SUBS     r1,r1,#0x48
00003c  6008              STR      r0,[r1,#0]
;;;194      LPC_USB->ENDPTNAKEN = 0;
00003e  2000              MOVS     r0,#0
000040  1d09              ADDS     r1,r1,#4
000042  6008              STR      r0,[r1,#0]
;;;195      LPC_USB->USBSTS_D     = 0xFFFFFFFF;
000044  1e40              SUBS     r0,r0,#1
000046  4935              LDR      r1,|L15.284|
000048  f8c10144          STR      r0,[r1,#0x144]
;;;196      LPC_USB->ENDPTSETUPSTAT = LPC_USB->ENDPTSETUPSTAT;
00004c  4832              LDR      r0,|L15.280|
00004e  3814              SUBS     r0,r0,#0x14
000050  6800              LDR      r0,[r0,#0]
000052  f8c101ac          STR      r0,[r1,#0x1ac]
;;;197      LPC_USB->ENDPTCOMPLETE  = LPC_USB->ENDPTCOMPLETE;
000056  4830              LDR      r0,|L15.280|
000058  1f00              SUBS     r0,r0,#4
00005a  6800              LDR      r0,[r0,#0]
00005c  492e              LDR      r1,|L15.280|
00005e  1f09              SUBS     r1,r1,#4
000060  6008              STR      r0,[r1,#0]
;;;198      while (LPC_USB->ENDPTPRIME)                  /* Wait until all bits are 0 */
000062  bf00              NOP      
                  |L15.100|
000064  482c              LDR      r0,|L15.280|
000066  3810              SUBS     r0,r0,#0x10
000068  6800              LDR      r0,[r0,#0]
00006a  2800              CMP      r0,#0
00006c  d1fa              BNE      |L15.100|
;;;199      {
;;;200      }
;;;201      LPC_USB->ENDPTFLUSH = 0xFFFFFFFF;
00006e  1e40              SUBS     r0,r0,#1
000070  4929              LDR      r1,|L15.280|
000072  390c              SUBS     r1,r1,#0xc
000074  6008              STR      r0,[r1,#0]
;;;202      while (LPC_USB->ENDPTFLUSH); /* Wait until all bits are 0 */
000076  bf00              NOP      
                  |L15.120|
000078  4827              LDR      r0,|L15.280|
00007a  380c              SUBS     r0,r0,#0xc
00007c  6800              LDR      r0,[r0,#0]
00007e  2800              CMP      r0,#0
000080  d1fa              BNE      |L15.120|
;;;203    
;;;204    
;;;205      /* Set the interrupt Threshold control interval to 0 */
;;;206      LPC_USB->USBCMD_D &= ~0x00FF0000;
000082  4825              LDR      r0,|L15.280|
000084  3880              SUBS     r0,r0,#0x80
000086  6800              LDR      r0,[r0,#0]
000088  f420007f          BIC      r0,r0,#0xff0000
00008c  4923              LDR      r1,|L15.284|
00008e  f8c10140          STR      r0,[r1,#0x140]
;;;207    
;;;208      /* Zero out the Endpoint queue heads */
;;;209      memset((void*)ep_QH, 0, EP_NUM_MAX * sizeof(DQH_T));
000092  1549              ASRS     r1,r1,#21
000094  4822              LDR      r0,|L15.288|
000096  f7fffffe          BL       __aeabi_memclr4
;;;210      /* Zero out the device transfer descriptors */
;;;211      memset((void*)ep_TD, 0, EP_NUM_MAX * sizeof(DTD_T));
00009a  f44f7180          MOV      r1,#0x100
00009e  4821              LDR      r0,|L15.292|
0000a0  f7fffffe          BL       __aeabi_memclr4
;;;212      memset((void*)ep_read_len, 0, sizeof(ep_read_len));
0000a4  4820              LDR      r0,|L15.296|
0000a6  2100              MOVS     r1,#0
0000a8  6001              STR      r1,[r0,#0]  ; ep_read_len
0000aa  6041              STR      r1,[r0,#4]  ; ep_read_len
0000ac  6081              STR      r1,[r0,#8]  ; ep_read_len
0000ae  60c1              STR      r1,[r0,#0xc]  ; ep_read_len
;;;213      /* Configure the Endpoint List Address */
;;;214      /* make sure it in on 64 byte boundary !!! */
;;;215      /* init list address */
;;;216      LPC_USB->ENDPOINTLISTADDR = (uint32_t)ep_QH;
0000b0  481b              LDR      r0,|L15.288|
0000b2  4919              LDR      r1,|L15.280|
0000b4  3968              SUBS     r1,r1,#0x68
0000b6  6008              STR      r0,[r1,#0]
;;;217      /* Initialize device queue heads for non ISO endpoint only */
;;;218      for (i = 0; i < EP_NUM_MAX; i++)
0000b8  2400              MOVS     r4,#0
0000ba  e007              B        |L15.204|
                  |L15.188|
;;;219      {
;;;220        ep_QH[i].next_dTD = (uint32_t)&ep_TD[i];
0000bc  4819              LDR      r0,|L15.292|
0000be  eb001044          ADD      r0,r0,r4,LSL #5
0000c2  4917              LDR      r1,|L15.288|
0000c4  eb011184          ADD      r1,r1,r4,LSL #6
0000c8  6088              STR      r0,[r1,#8]
0000ca  1c64              ADDS     r4,r4,#1              ;218
                  |L15.204|
0000cc  2c08              CMP      r4,#8                 ;218
0000ce  d3f5              BCC      |L15.188|
;;;221      }
;;;222      /* Enable interrupts */
;;;223      LPC_USB->USBINTR_D =  USBSTS_UI
0000d0  4816              LDR      r0,|L15.300|
0000d2  4911              LDR      r1,|L15.280|
0000d4  3978              SUBS     r1,r1,#0x78
0000d6  6008              STR      r0,[r1,#0]
;;;224                         | USBSTS_UEI
;;;225                         | USBSTS_PCI
;;;226                         | USBSTS_URI
;;;227                         | USBSTS_SLI
;;;228                         | USBSTS_NAKI;
;;;229    //  LPC_USB->usbintr |= (0x1<<7);		/* Test SOF */
;;;230      /* enable ep0 IN and ep0 OUT */
;;;231      ep_QH[0].cap  = QH_MAXP(g_drv.ep0_maxp)
0000d8  4815              LDR      r0,|L15.304|
0000da  8800              LDRH     r0,[r0,#0]  ; g_drv
0000dc  f3c00009          UBFX     r0,r0,#0,#10
0000e0  13c9              ASRS     r1,r1,#15
0000e2  ea414000          ORR      r0,r1,r0,LSL #16
0000e6  f0405000          ORR      r0,r0,#0x20000000
0000ea  490d              LDR      r1,|L15.288|
0000ec  6008              STR      r0,[r1,#0]  ; ep_QH
;;;232                      | QH_IOS
;;;233                      | QH_ZLT;
;;;234      ep_QH[1].cap  = QH_MAXP(g_drv.ep0_maxp)
0000ee  4810              LDR      r0,|L15.304|
0000f0  8800              LDRH     r0,[r0,#0]  ; g_drv
0000f2  f3c00009          UBFX     r0,r0,#0,#10
0000f6  f44f4100          MOV      r1,#0x8000
0000fa  ea414000          ORR      r0,r1,r0,LSL #16
0000fe  f0405000          ORR      r0,r0,#0x20000000
000102  4907              LDR      r1,|L15.288|
000104  6408              STR      r0,[r1,#0x40]  ; ep_QH
;;;235                      | QH_IOS
;;;236                      | QH_ZLT;
;;;237      /* enable EP0 */
;;;238      LPC_USB->ENDPTCTRL0 = EPCTRL_RXE | EPCTRL_RXR | EPCTRL_TXE | EPCTRL_TXR;
000106  f04f10c0          MOV      r0,#0xc000c0
00010a  4904              LDR      r1,|L15.284|
00010c  f8c101c0          STR      r0,[r1,#0x1c0]
;;;239      return;
;;;240    
;;;241    }
000110  bd10              POP      {r4,pc}
;;;242    
                          ENDP

000112  0000              DCW      0x0000
                  |L15.276|
                          DCD      DevStatusFS2HS
                  |L15.280|
                          DCD      0x400061c0
                  |L15.284|
                          DCD      0x40006000
                  |L15.288|
                          DCD      ep_QH
                  |L15.292|
                          DCD      ep_TD
                  |L15.296|
                          DCD      ep_read_len
                  |L15.300|
                          DCD      0x00010147
                  |L15.304|
                          DCD      g_drv

                          AREA ||i.USB_ResetEP||, CODE, READONLY, ALIGN=2

                  USB_ResetEP PROC
;;;452    
;;;453    void USB_ResetEP (uint32_t EPNum) {
000000  b510              PUSH     {r4,lr}
;;;454      uint32_t bit_pos = USB_EP_BITPOS(EPNum);
000002  f0000380          AND      r3,r0,#0x80
000006  b123              CBZ      r3,|L16.18|
000008  f0000307          AND      r3,r0,#7
00000c  f0430310          ORR      r3,r3,#0x10
000010  e001              B        |L16.22|
                  |L16.18|
000012  f0000307          AND      r3,r0,#7
                  |L16.22|
000016  461a              MOV      r2,r3
;;;455      uint32_t lep = EPNum & 0x0F;
000018  f000010f          AND      r1,r0,#0xf
;;;456    
;;;457      /* flush EP buffers */
;;;458      LPC_USB->ENDPTFLUSH = (1<<bit_pos);
00001c  2301              MOVS     r3,#1
00001e  4093              LSLS     r3,r3,r2
000020  4c11              LDR      r4,|L16.104|
000022  6023              STR      r3,[r4,#0]
;;;459      while (LPC_USB->ENDPTFLUSH & (1<<bit_pos));
000024  bf00              NOP      
                  |L16.38|
000026  4b10              LDR      r3,|L16.104|
000028  681b              LDR      r3,[r3,#0]
00002a  2401              MOVS     r4,#1
00002c  4094              LSLS     r4,r4,r2
00002e  4023              ANDS     r3,r3,r4
000030  2b00              CMP      r3,#0
000032  d1f8              BNE      |L16.38|
;;;460      /* reset data toggles */
;;;461      if (EPNum & 0x80)
000034  f0000380          AND      r3,r0,#0x80
000038  b153              CBZ      r3,|L16.80|
;;;462      {
;;;463        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] |= EPCTRL_TXR;
00003a  4b0b              LDR      r3,|L16.104|
00003c  330c              ADDS     r3,r3,#0xc
00003e  f8533021          LDR      r3,[r3,r1,LSL #2]
000042  f4430480          ORR      r4,r3,#0x400000
000046  4b08              LDR      r3,|L16.104|
000048  330c              ADDS     r3,r3,#0xc
00004a  f8434021          STR      r4,[r3,r1,LSL #2]
00004e  e009              B        |L16.100|
                  |L16.80|
;;;464      }
;;;465      else
;;;466      {
;;;467        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] |= EPCTRL_RXR;
000050  4b05              LDR      r3,|L16.104|
000052  330c              ADDS     r3,r3,#0xc
000054  f8533021          LDR      r3,[r3,r1,LSL #2]
000058  f0430440          ORR      r4,r3,#0x40
00005c  4b02              LDR      r3,|L16.104|
00005e  330c              ADDS     r3,r3,#0xc
000060  f8434021          STR      r4,[r3,r1,LSL #2]
                  |L16.100|
;;;468      }
;;;469    }
000064  bd10              POP      {r4,pc}
;;;470    
                          ENDP

000066  0000              DCW      0x0000
                  |L16.104|
                          DCD      0x400061b4

                          AREA ||i.USB_Resume||, CODE, READONLY, ALIGN=1

                  USB_Resume PROC
;;;260    
;;;261    void USB_Resume (void) {
000000  4770              BX       lr
;;;262      /* Performed by Hardware */
;;;263    }
;;;264    
                          ENDP


                          AREA ||i.USB_SetAddress||, CODE, READONLY, ALIGN=2

                  USB_SetAddress PROC
;;;298    
;;;299    void USB_SetAddress (uint32_t adr) {
000000  0641              LSLS     r1,r0,#25
;;;300      LPC_USB->DEVICEADDR = USBDEV_ADDR(adr);
000002  4a04              LDR      r2,|L18.20|
000004  6011              STR      r1,[r2,#0]
;;;301      LPC_USB->DEVICEADDR |= USBDEV_ADDR_AD;
000006  4904              LDR      r1,|L18.24|
000008  f8d11154          LDR      r1,[r1,#0x154]
00000c  f0417180          ORR      r1,r1,#0x1000000
000010  6011              STR      r1,[r2,#0]
;;;302    }
000012  4770              BX       lr
;;;303    
                          ENDP

                  |L18.20|
                          DCD      0x40006154
                  |L18.24|
                          DCD      0x40006000

                          AREA ||i.USB_SetStallEP||, CODE, READONLY, ALIGN=2

                  USB_SetStallEP PROC
;;;478    
;;;479    void USB_SetStallEP (uint32_t EPNum) {
000000  4601              MOV      r1,r0
;;;480      uint32_t lep;
;;;481    
;;;482      lep = EPNum & 0x0F;
000002  f001000f          AND      r0,r1,#0xf
;;;483      if (EPNum & 0x80)
000006  f0010280          AND      r2,r1,#0x80
00000a  b142              CBZ      r2,|L19.30|
;;;484      {
;;;485        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] |= EPCTRL_TXS;
00000c  4a08              LDR      r2,|L19.48|
00000e  f8522020          LDR      r2,[r2,r0,LSL #2]
000012  f4423380          ORR      r3,r2,#0x10000
000016  4a06              LDR      r2,|L19.48|
000018  f8423020          STR      r3,[r2,r0,LSL #2]
00001c  e007              B        |L19.46|
                  |L19.30|
;;;486      }
;;;487      else
;;;488      {
;;;489        ((uint32_t*)&(LPC_USB->ENDPTCTRL0))[lep] |= EPCTRL_RXS;
00001e  4a04              LDR      r2,|L19.48|
000020  f8522020          LDR      r2,[r2,r0,LSL #2]
000024  f0420301          ORR      r3,r2,#1
000028  4a01              LDR      r2,|L19.48|
00002a  f8423020          STR      r3,[r2,r0,LSL #2]
                  |L19.46|
;;;490      }
;;;491    }
00002e  4770              BX       lr
;;;492    
                          ENDP

                  |L19.48|
                          DCD      0x400061c0

                          AREA ||i.USB_SetTestMode||, CODE, READONLY, ALIGN=2

                  USB_SetTestMode PROC
;;;309    
;;;310    uint32_t USB_SetTestMode(uint8_t mode)
000000  4601              MOV      r1,r0
;;;311    {
;;;312      uint32_t portsc;
;;;313    
;;;314      if ((mode > 0) && (mode < 8))
000002  2900              CMP      r1,#0
000004  dd0c              BLE      |L20.32|
000006  2908              CMP      r1,#8
000008  da0a              BGE      |L20.32|
;;;315      {
;;;316        portsc = LPC_USB->PORTSC1_D & ~(0xF << 16);
00000a  4806              LDR      r0,|L20.36|
00000c  6800              LDR      r0,[r0,#0]
00000e  f4202270          BIC      r2,r0,#0xf0000
;;;317    
;;;318        LPC_USB->PORTSC1_D = portsc | (mode << 16);
000012  ea424001          ORR      r0,r2,r1,LSL #16
000016  4b04              LDR      r3,|L20.40|
000018  f8c30184          STR      r0,[r3,#0x184]
;;;319        return TRUE;
00001c  2001              MOVS     r0,#1
                  |L20.30|
;;;320      }
;;;321      return (FALSE);
;;;322    }
00001e  4770              BX       lr
                  |L20.32|
000020  2000              MOVS     r0,#0                 ;321
000022  e7fc              B        |L20.30|
;;;323    
                          ENDP

                  |L20.36|
                          DCD      0x40006184
                  |L20.40|
                          DCD      0x40006000

                          AREA ||i.USB_Suspend||, CODE, READONLY, ALIGN=1

                  USB_Suspend PROC
;;;249    
;;;250    void USB_Suspend (void) {
000000  4770              BX       lr
;;;251      /* Performed by Hardware */
;;;252    }
;;;253    
                          ENDP


                          AREA ||i.USB_WakeUp||, CODE, READONLY, ALIGN=2

                  USB_WakeUp PROC
;;;271    
;;;272    void USB_WakeUp (void) {
000000  4803              LDR      r0,|L22.16|
;;;273    
;;;274      //if (USB_DeviceStatus & USB_GETSTATUS_REMOTE_WAKEUP)
;;;275      {
;;;276        /* Set FPR bit in PORTSCX reg p63 */
;;;277        LPC_USB->PORTSC1_D |= USBPRTS_FPR ;
000002  6800              LDR      r0,[r0,#0]
000004  f0400040          ORR      r0,r0,#0x40
000008  4902              LDR      r1,|L22.20|
00000a  f8c10184          STR      r0,[r1,#0x184]
;;;278      }
;;;279    }
00000e  4770              BX       lr
;;;280    
                          ENDP

                  |L22.16|
                          DCD      0x40006184
                  |L22.20|
                          DCD      0x40006000

                          AREA ||i.USB_WakeUpCfg||, CODE, READONLY, ALIGN=1

                  USB_WakeUpCfg PROC
;;;287    
;;;288    void USB_WakeUpCfg (uint32_t cfg) {
000000  4770              BX       lr
;;;289      /* Not needed */
;;;290    }
;;;291    
                          ENDP


                          AREA ||i.USB_WriteEP||, CODE, READONLY, ALIGN=2

                  USB_WriteEP PROC
;;;653    */
;;;654    uint32_t USB_WriteEP(uint32_t EPNum, uint8_t *pData, uint32_t cnt)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;655    {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
;;;656      uint32_t n = USB_EP_BITPOS(EPNum);
00000a  f0040080          AND      r0,r4,#0x80
00000e  b120              CBZ      r0,|L24.26|
000010  f0040007          AND      r0,r4,#7
000014  f0400010          ORR      r0,r0,#0x10
000018  e001              B        |L24.30|
                  |L24.26|
00001a  f0040007          AND      r0,r4,#7
                  |L24.30|
00001e  4606              MOV      r6,r0
;;;657    
;;;658      USB_ProgDTD(EPAdr(EPNum), (uint32_t)pData, cnt);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       EPAdr
000026  4680              MOV      r8,r0
000028  462a              MOV      r2,r5
00002a  4639              MOV      r1,r7
00002c  f7fffffe          BL       USB_ProgDTD
;;;659      /* prime the endpoint for transmit */
;;;660      LPC_USB->ENDPTPRIME |= (1<<n);
000030  4809              LDR      r0,|L24.88|
000032  6800              LDR      r0,[r0,#0]
000034  2101              MOVS     r1,#1
000036  40b1              LSLS     r1,r1,r6
000038  4308              ORRS     r0,r0,r1
00003a  4908              LDR      r1,|L24.92|
00003c  f8c101b0          STR      r0,[r1,#0x1b0]
;;;661    
;;;662      /* check if priming succeeded */
;;;663      while (LPC_USB->ENDPTPRIME & (1<<n));
000040  bf00              NOP      
                  |L24.66|
000042  4805              LDR      r0,|L24.88|
000044  6801              LDR      r1,[r0,#0]
000046  2001              MOVS     r0,#1
000048  40b0              LSLS     r0,r0,r6
00004a  4001              ANDS     r1,r1,r0
00004c  2900              CMP      r1,#0
00004e  d1f8              BNE      |L24.66|
;;;664      return (cnt);
000050  4628              MOV      r0,r5
;;;665    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;666    
                          ENDP

000056  0000              DCW      0x0000
                  |L24.88|
                          DCD      0x400061b0
                  |L24.92|
                          DCD      0x40006000

                          AREA ||.bss||, DATA, NOINIT, ALIGN=11

                  ep_QH
                          %        512
                  ep_TD
                          %        256
                  ep_read_len
                          %        16
                  g_drv
                          %        60

                          AREA ||.data||, DATA, ALIGN=2

                  DevStatusFS2HS
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "usbhw.c"
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_usbhw_c_fc39a1c5____REV16|
#line 130 ".\\core_cmInstr.h"
|__asm___7_usbhw_c_fc39a1c5____REV16| PROC
#line 131

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___7_usbhw_c_fc39a1c5____REVSH|
#line 144
|__asm___7_usbhw_c_fc39a1c5____REVSH| PROC
#line 145

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
